
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Woody Block Puzzle Clone</title>
    <style>
        body { background: #8d6e63; display: flex; flex-direction: column; align-items: center; font-family: 'Arial', sans-serif; margin: 0; padding: 20px; }
        #score { color: white; font-size: 48px; font-weight: bold; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }

        /* æ£‹ç›¤å®¹å™¨ */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 45px);
            grid-template-rows: repeat(8, 45px);
            gap: 2px;
            background: #5d4037;
            padding: 10px;
            border-radius: 8px;
            border: 5px solid #4e342e;
        }
        .cell {
            width: 45px;
            height: 45px;
            background: #4e342e;
            border-radius: 4px;
            position: relative;
        }

        /* æ–¹å¡Šæ¨£å¼ï¼šä»¿åœ–ç‰‡çš„ç«‹é«”æ„Ÿ */
        .filled {
            background: #81c784;
            box-shadow: inset 3px 3px 0 rgba(255,255,255,0.4), inset -3px -3px 0 rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .ghost {
            background: rgba(255, 255, 255, 0.2);
        }

        /* ä¸‹æ–¹å¾…é¸å€ */
        #pieces-area {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 40px;
            height: 150px;
            width: 100%;
            align-items: center;
        }
        .piece-container {
            cursor: grab;
            position: relative;

        }
        .p-cell {
            width: 45px;
            height: 45px;
            border-radius: 4px;
            position: absolute;
        }

        @keyframes scorePopup {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -100%) scale(1);
            }
        }

        /* é˜²æ­¢æ‹–æ›³æ™‚çš„æ–‡å­—é¸å– */
        .piece-container {
            touch-action: none;
            -webkit-touch-callout: none;
        }

        .piece-container:active {
            cursor: grabbing;
        }

        /* ========== çµ±ä¸€å½ˆçª—æ¨£å¼ ========== */

        /* é€šçŸ¥å½ˆçª— */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            min-width: 300px;
            max-width: 500px;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            z-index: 10000;
            font-size: 16px;
            backdrop-filter: blur(10px);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notification-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .notification-message {
            flex: 1;
            line-height: 1.5;
        }

        .notification-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: inherit;
            opacity: 0.6;
            transition: opacity 0.2s;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            opacity: 1;
        }

        /* ä¸åŒé¡å‹çš„é€šçŸ¥é¡è‰² */
        .notification-success {
            background: linear-gradient(135deg, #4caf50 0%, #81c784 100%);
            color: white;
        }

        .notification-error {
            background: linear-gradient(135deg, #f44336 0%, #ef5350 100%);
            color: white;
        }

        .notification-warning {
            background: linear-gradient(135deg, #ff9800 0%, #ffb74d 100%);
            color: white;
        }

        .notification-info {
            background: linear-gradient(135deg, #2196f3 0%, #42a5f5 100%);
            color: white;
        }

        /* ç¢ºèªå°è©±æ¡† */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dialog-overlay.show {
            opacity: 1;
        }

        .dialog-box {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .dialog-overlay.show .dialog-box {
            transform: scale(1);
        }

        .dialog-content {
            text-align: center;
            margin-bottom: 24px;
        }

        .dialog-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .dialog-message {
            font-size: 18px;
            line-height: 1.6;
            color: #333;
        }

        .dialog-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .dialog-btn {
            padding: 12px 32px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dialog-btn-cancel {
            background: #e0e0e0;
            color: #666;
        }

        .dialog-btn-cancel:hover {
            background: #d0d0d0;
        }

        .dialog-btn-confirm {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
        }

        .dialog-btn-confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        /* ========================================
   ğŸ® æŒ‰é’®å®¹å™¨æ ·å¼ï¼ˆæ¡Œé¢ç‰ˆï¼‰
   ======================================== */
        #buttons-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
            padding: 0 20px;
        }

        .game-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .game-button:active {
            transform: translateY(0);
        }

        /* ========================================
   ğŸ® æŒ‰é’®å®¹å™¨åŸºç¡€æ ·å¼
   ======================================== */
        #buttons-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
            padding: 0 20px;
        }

        .game-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* ========================================
     ğŸ“± æ‰‹æœºç‰ˆå“åº”å¼è®¾è®¡ - ä¿®æ­£ç‰ˆ
     ======================================== */
        @media (max-width: 768px) {
            /* å…¨åŸŸè¨­å®šï¼šç¢ºä¿æ‰‹æ©Ÿç‰ˆä¸ç”¢ç”Ÿæ²è»¸ */
            * {
                box-sizing: border-box;
                -webkit-tap-highlight-color: transparent;
            }

            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                min-height: 100vh;  /* âœ… æ”¹ç”¨ min-height */
                overflow-x: hidden; /* âœ… åªç¦æ­¢æ©«å‘æ»¾å‹• */
                overflow-y: auto;   /* âœ… å…è¨±ç¸±å‘æ»¾å‹• */
            }

            body {
                background: #8d6e63 !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: space-between !important;
                align-items: center !important;
                padding: 8px 5px 5px 5px !important;
                font-family: 'Arial', sans-serif !important;
            }

            /* ===== 1ï¸âƒ£ åˆ†æ•°åŒº - æœ€ä¸Šæ–¹ ===== */
            #score {
                color: white !important;
                font-size: 36px !important;
                font-weight: bold !important;
                margin: 5px 0 !important;
                padding: 0 !important;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5) !important;
                text-align: center !important;
                width: 100% !important;
                flex-shrink: 0 !important;
                order: 1 !important;
            }

            /* ===== 2ï¸âƒ£ æ£‹ç›˜åŒº - ä¸­é—´ï¼ˆå æ»¡å®½åº¦ï¼‰===== */
            #board {
                display: grid !important;
                grid-template-columns: repeat(8, 1fr) !important;
                grid-template-rows: repeat(8, 1fr) !important;
                gap: 2px !important;
                background: #5d4037 !important;
                padding: 8px !important;
                border-radius: 8px !important;
                border: 4px solid #4e342e !important;

                /* ä½¿ç”¨ vw è®©æ£‹ç›˜å æ»¡å±å¹•å®½åº¦ */
                width: min(90vw, 420px) !important;
                height: min(90vw, 420px) !important;
                max-width: 420px !important;
                max-height: 420px !important;

                margin: 0 auto !important;
                flex-shrink: 0 !important;
                order: 2 !important;
            }

            /* ğŸ”¥ ä¿®å¤ï¼šåªæ”¹å°ºå¯¸ï¼Œä¸æ”¹é¢œè‰² */
            .cell {
                width: 100% !important;
                height: 100% !important;
                border-radius: 3px !important;
                position: relative !important;
                /* ä¸è®¾ç½® backgroundï¼Œè®©å®ƒä¿æŒåŸæœ¬çš„é¢œè‰² */
            }

            /* ğŸ”¥ ä¿®å¤ï¼šä¼˜åŒ–ç«‹ä½“æ„Ÿï¼Œä¸æ”¹é¢œè‰² */
            .filled {
                box-shadow: inset 2px 2px 0 rgba(255,255,255,0.4),
                inset -2px -2px 0 rgba(0,0,0,0.2) !important;
                border-radius: 3px !important;
                /* ä¸è®¾ç½® backgroundï¼Œè®©æ–¹å—ä¿æŒåŸæœ¬çš„é¢œè‰² */
            }

            /* ===== 3ï¸âƒ£ å¾…é€‰åŒº - ç¬¬ä¸‰ä½ç½® ===== */
            #pieces-area {
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                gap: 15px !important;
                margin: 8px 0 !important;
                height: 130px !important;
                width: 100% !important;
                max-width: 420px !important;
                flex-shrink: 0 !important;
                order: 3 !important;
            }

            .piece-container {
                cursor: grab !important;
                position: relative !important;
                transform: scale(0.85) !important;
                touch-action: none !important;
                -webkit-touch-callout: none !important;
                -webkit-user-select: none !important;
                user-select: none !important;
            }

            .piece-container:active {
                cursor: grabbing !important;
            }

            .p-cell {
                width: 42px !important;
                height: 42px !important;
                border-radius: 4px !important;
                position: absolute !important;
                /* ä¸è®¾ç½® backgroundï¼Œè®©æ–¹å—ä¿æŒåŸæœ¬çš„é¢œè‰² */
            }

            /* ===== 4ï¸âƒ£ æŒ‰é’®åŒº - æœ€åº•éƒ¨ï¼ˆæ•´é½æ’åˆ—ï¼‰===== */
            #buttons-container {
                width: 100% !important;
                max-width: 420px !important;
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 6px !important;
                padding: 8px 10px 10px 10px !important;
                margin: 0 !important;
                background: rgba(0,0,0,0.15) !important;
                border-top: 2px solid #4e342e !important;
                border-radius: 8px 8px 0 0 !important;
                flex-shrink: 0 !important;
                order: 4 !important;
            }

            /* ğŸ”¥ ä¿®å¤ï¼šåªæ”¹å¸ƒå±€ï¼Œä¸æ”¹é¢œè‰² */
            .game-button,
            #buttons-container button {
                padding: 10px 8px !important;
                font-size: 13px !important;
                border-radius: 6px !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                margin: 0 !important;
                width: 100% !important;
                -webkit-tap-highlight-color: transparent !important;
                touch-action: manipulation !important;
                box-sizing: border-box !important;
                /* ğŸ”¥ ä¸è®¾ç½® background å’Œ colorï¼Œä¿æŒåŸæœ¬çš„æŒ‰é’®é¢œè‰² */
            }

            /* ===== é€šçŸ¥å’Œå¯¹è¯æ¡†è°ƒæ•´ ===== */
            .notification {
                top: 10px !important;
                right: 10px !important;
                left: 10px !important;
                max-width: none !important;
                min-width: auto !important;
                font-size: 14px !important;
            }

            .dialog-box {
                width: 85% !important;
                max-width: 380px !important;
                padding: 20px !important;
            }

            .dialog-message {
                font-size: 16px !important;
            }

            .dialog-btn {
                padding: 10px 24px !important;
                font-size: 14px !important;
            }

            /* ===== å±å¹•å°ºå¯¸é€‚é… ===== */

            /* è¶…å°å±å¹• (â‰¤360px) */
            @media (max-width: 360px) {
                body {
                    padding: 5px 3px 3px 3px !important;
                }

                #score {
                    font-size: 30px !important;
                    margin: 3px 0 !important;
                }

                #board {
                    width: min(92vw, 340px) !important;
                    height: min(92vw, 340px) !important;
                    max-width: 340px !important;
                    max-height: 340px !important;
                    padding: 6px !important;
                    gap: 1px !important;
                }

                #pieces-area {
                    height: 110px !important;
                    gap: 10px !important;
                    margin: 6px 0 !important;
                }



                .p-cell {
                    width: 38px !important;
                    height: 38px !important;
                }

                #buttons-container {
                    max-width: 340px !important;
                    gap: 5px !important;
                    padding: 6px 8px 8px 8px !important;
                }

                .game-button,
                #buttons-container button {
                    padding: 8px 5px !important;
                    font-size: 11px !important;
                }
            }

            /* æ ‡å‡†å±å¹• (361-430px) */
            @media (min-width: 361px) and (max-width: 430px) {
                #score {
                    font-size: 34px !important;
                }

                #board {
                    width: min(90vw, 390px) !important;
                    height: min(90vw, 390px) !important;
                }

                #pieces-area {
                    max-width: 390px !important;
                }

                #buttons-container {
                    max-width: 390px !important;
                }
            }

            /* å¤§å±å¹• (431-768px) */
            @media (min-width: 431px) and (max-width: 768px) {
                #score {
                    font-size: 40px !important;
                    margin: 8px 0 !important;
                }

                #board {
                    width: min(85vw, 480px) !important;
                    height: min(85vw, 480px) !important;
                    max-width: 480px !important;
                    max-height: 480px !important;
                    padding: 10px !important;
                }

                #pieces-area {
                    height: 150px !important;
                    gap: 20px !important;
                    max-width: 480px !important;
                }

                .piece-container {
                    transform: scale(0.95) !important;
                }

                .p-cell {
                    width: 45px !important;
                    height: 45px !important;
                }

                #buttons-container {
                    max-width: 480px !important;
                    gap: 8px !important;
                    padding: 10px 12px 12px 12px !important;
                }

                .game-button,
                #buttons-container button {
                    padding: 11px 10px !important;
                    font-size: 14px !important;
                }
            }

            /* ===== æ¨ªå±æ¨¡å¼ä¼˜åŒ– ===== */
            @media (orientation: landscape) {
                body {
                    flex-direction: row !important;
                    justify-content: center !important;
                    align-items: center !important;
                    gap: 10px !important;
                    padding: 5px !important;
                }

                #score {
                    position: absolute !important;
                    top: 5px !important;
                    left: 50% !important;
                    transform: translateX(-50%) !important;
                    font-size: 22px !important;
                    margin: 0 !important;
                    order: 0 !important;
                }

                #board {
                    height: min(85vh, 380px) !important;
                    width: min(85vh, 380px) !important;
                    max-height: 380px !important;
                    max-width: 380px !important;
                    margin: 0 !important;
                    order: 1 !important;
                }

                #pieces-area {
                    height: min(85vh, 380px) !important;
                    max-height: 380px !important;
                    flex-direction: column !important;
                    width: auto !important;
                    margin: 0 !important;
                    order: 2 !important;
                    gap: 12px !important;
                }

                .piece-container {
                    transform: scale(0.75) !important;
                }

                #buttons-container {
                    position: absolute !important;
                    bottom: 5px !important;
                    left: 50% !important;
                    transform: translateX(-50%) !important;
                    width: auto !important;
                    max-width: 90vw !important;
                    grid-template-columns: repeat(5, 1fr) !important;
                    margin: 0 !important;
                    order: 3 !important;
                    background: rgba(0,0,0,0.25) !important;
                }

                .game-button,
                #buttons-container button {
                    padding: 6px 8px !important;
                    font-size: 11px !important;
                }
            }
        }

        /* ğŸ”¥ çµ±ä¸€æŒ‰éˆ•é¡è‰²ç‚ºç¶ è‰² */
        .game-button,
        #buttons-container button {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%) !important;
            color: white !important;
            border: 2px solid #388e3c !important;
            font-weight: bold !important;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3) !important;
        }

        /* æŒ‰éˆ•æŒ‰ä¸‹æ•ˆæœ */
        .game-button:active,
        #buttons-container button:active {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%) !important;
            transform: scale(0.95) !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3) !important;
        }


        /* ===== è¨­å®šé¢æ¿æ‰‹æ©Ÿç‰ˆå„ªåŒ– ===== */
        @media (max-width: 768px) {
            #game-settings-panel {
                /* å°ºå¯¸èª¿æ•´ */
                min-width: auto !important;
                width: 92vw !important;
                max-width: 420px !important;
                max-height: 80vh !important;

                /* å…§è·èª¿æ•´ */
                padding: 25px 20px 15px 20px !important;

                /* å…è¨±æ»¾å‹• */
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }

            /* é—œé–‰æŒ‰éˆ•ä½ç½®èª¿æ•´ */
            #top-close-btn {
                top: 10px !important;
                right: 10px !important;
                width: 32px !important;
                height: 32px !important;
                font-size: 18px !important;
            }
        }

    </style>
</head>
<body>
<div id="score">0</div>
<div id="board"></div>
<div id="pieces-area"></div>
<div id="buttons-container"></div>

<script>
    const boardSize = 8;
    const boardElement = document.getElementById('board');
    const piecesArea = document.getElementById('pieces-area');
    let boardState = Array(8).fill().map(() => Array(8).fill(0));
    let dragOffset = { r: 0, c: 0 };
    let currentShape = null;

    let isDragging = false;
    let draggedPiece = null;
    let ghostElement = null;
    let dragStartX = 0;
    let dragStartY = 0;
    let pieceStartX = 0;
    let pieceStartY = 0;

    // ===== æ–°å¢ï¼šè¨ˆåˆ†ç³»çµ±è®Šæ•¸ =====
    let streakCount = 0; // é€£çºŒæ¶ˆé™¤å›åˆæ•¸
    let lastMoveCleared = false; // ä¸Šä¸€æ­¥æ˜¯å¦æœ‰æ¶ˆé™¤

    // åœ¨ let moveHistory = []; å¾Œé¢åŠ å…¥ï¼š

    let aiSolution = null; // å„²å­˜ AI æ‰¾åˆ°çš„è§£æ³•

    // ===== ç„¡ç›¡æ¨¡å¼å®Œæ•´ä¿®å¾©ç‰ˆ =====

    let endlessModeActive = false;
    let endlessModeType = null;
    let endlessModeTimer = null;
    let endlessModeTimeRemaining = 0;
    let endlessModeStartTime = 0;
    let endlessModeScore = 0;
    let endlessModeHighScores = {
        get timed() { return highScoreManager.getScore('timed'); },
        get infinite() { return highScoreManager.getScore('infinite'); },
        get ai() { return highScoreManager.getScore('ai'); }
    };



    // Combo åŠ åˆ†è¡¨ï¼ˆBlock Blast å®˜æ–¹æ•¸å€¼ï¼‰
    const comboBonus = {
        1: 20,
        2: 30,
        3: 40,
        4: 50,
        5: 60,
        6: 70,
        7: 80,
        8: 90,
        9: 100
    };

    // åœ¨ const boardSize = 8; å¾Œé¢ï¼ŒallShapes å®šç¾©ä¹‹å‰åŠ å…¥ï¼š

    // ===== å·¥å…·å‡½æ•¸å€ =====

    // æ·±æ‹·è²æ£‹ç›¤
    function cloneBoard(board) {
        return board.map(row => [...row]);
    }

    // æ·±æ‹·è²æ–¹å¡Š
    function cloneShape(shapeObj) {
        return {
            s: shapeObj.s.map(row => [...row]),
            color: shapeObj.color,
            name: shapeObj.name
        };
    }

    // æ£‹ç›¤æª¢æŸ¥ï¼ˆæ”¯æ´è‡ªè¨‚æ£‹ç›¤ï¼‰
    function canPlaceOnBoard(shape, r, c, board) {
        return shape.every((row, i) => row.every((val, j) =>
            !val || (r+i >= 0 && r+i < 8 && c+j >= 0 && c+j < 8 && !board[r+i][c+j])
        ));
    }

    // æª¢æŸ¥å–®å€‹æ–¹å¡Šæ˜¯å¦æœ‰å¯æ”¾ç½®ä½ç½®
    function hasValidPlacement(shape, board) {
        for(let r = 0; r < 8; r++) {
            for(let c = 0; c < 8; c++) {
                if(canPlaceOnBoard(shape, r, c, board)) {
                    return true;
                }
            }
        }
        return false;
    }

    // æ¨¡æ“¬æ”¾ç½®æ–¹å¡Š
    function simulatePlace(shape, r, c, board) {
        const newBoard = cloneBoard(board);
        shape.forEach((row, i) => {
            row.forEach((val, j) => {
                if(val) newBoard[r+i][c+j] = 1;
            });
        });
        return newBoard;
    }

    // ===== æ­£ç¢ºçš„å®Œæ•´æ¶ˆé™¤é‚è¼¯ =====
    function simulateLineClear(board) {
        let currentBoard = cloneBoard(board);
        let iteration = 0;
        const maxIterations = 20; // é˜²æ­¢ç„¡é™å¾ªç’°

        while (iteration < maxIterations) {
            iteration++;

            // ğŸ”‘ é—œéµï¼šæ¯ä¸€è¼ªéƒ½è¦ã€ŒåŒæ™‚æª¢æŸ¥ã€æ‰€æœ‰è¡Œå’Œåˆ—
            const rowsToClear = [];
            const colsToClear = [];

            // 1ï¸âƒ£ æ‰¾å‡ºæ‰€æœ‰éœ€è¦æ¶ˆé™¤çš„è¡Œ
            for (let r = 0; r < 8; r++) {
                if (currentBoard[r].every(v => v)) {
                    rowsToClear.push(r);
                }
            }

            // 2ï¸âƒ£ æ‰¾å‡ºæ‰€æœ‰éœ€è¦æ¶ˆé™¤çš„åˆ—
            for (let c = 0; c < 8; c++) {
                if (currentBoard.every(row => row[c])) {
                    colsToClear.push(c);
                }
            }

            // 3ï¸âƒ£ å¦‚æœæ²’æœ‰å¯æ¶ˆé™¤çš„ï¼ŒçµæŸå¾ªç’°
            if (rowsToClear.length === 0 && colsToClear.length === 0) {
                break;
            }

            // 4ï¸âƒ£ åŸ·è¡Œæ¶ˆé™¤ï¼ˆå‰µå»ºæ–°æ£‹ç›¤ï¼‰
            const newBoard = [];

            // ğŸ”‘ é—œéµä¿®æ­£ï¼šé€æ ¼æª¢æŸ¥æ˜¯å¦åœ¨è¦æ¶ˆé™¤çš„è¡Œæˆ–åˆ—ä¸­
            for (let r = 0; r < 8; r++) {
                newBoard[r] = [];
                for (let c = 0; c < 8; c++) {
                    // å¦‚æœé€™å€‹æ ¼å­åœ¨è¦æ¶ˆé™¤çš„è¡Œæˆ–åˆ—ä¸­ï¼Œè¨­ç‚º0
                    if (rowsToClear.includes(r) || colsToClear.includes(c)) {
                        newBoard[r][c] = 0;
                    } else {
                        // å¦å‰‡ä¿ç•™åŸå€¼
                        newBoard[r][c] = currentBoard[r][c];
                    }
                }
            }

            currentBoard = newBoard;
        }

        // âœ… åªåœ¨ç•°å¸¸æƒ…æ³è¼¸å‡ºè­¦å‘Šï¼ˆå¯é¸ï¼Œä¹Ÿå¯åˆªé™¤ï¼‰
        if (iteration >= maxIterations) {
            console.warn('âš ï¸ æ¶ˆé™¤å¾ªç’°é”åˆ°ä¸Šé™ï¼Œå¯èƒ½å­˜åœ¨é‚è¼¯å•é¡Œ');
        }

        return currentBoard;
    }

    // è¨ˆç®—æ£‹ç›¤å¯†åº¦
    function getBoardDensity() {
        const filled = boardState.flat().filter(v => v).length;
        return filled / 64;
    }

    // æ¯”è¼ƒå…©å€‹æ£‹ç›¤æ˜¯å¦ç›¸åŒ
    function boardsEqual(board1, board2) {
        for(let r = 0; r < 8; r++) {
            for(let c = 0; c < 8; c++) {
                if(board1[r][c] !== board2[r][c]) return false;
            }
        }
        return true;
    }

    // æ‰“äº‚é™£åˆ—
    function shuffle(array) {
        const arr = [...array];
        for(let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // éš¨æ©Ÿå–å°æ–¹å¡Š
    function getRandomSmallShape() {
        const smallShapes = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area <= 3;
        });
        const shape = smallShapes[Math.floor(Math.random() * smallShapes.length)];
        return cloneShape(shape);
    }

    // éš¨æ©Ÿå–å¤§æ–¹å¡Š
    function getRandomBigShape() {
        const bigShapes = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area >= 5;
        });
        const shape = bigShapes[Math.floor(Math.random() * bigShapes.length)];
        return cloneShape(shape);
    }

    // å®Œæ•´ Woodoku æ–¹å¡Šåº«ï¼ˆå«æ–œå‘æ–¹å¡Šï¼‰
    const allShapes = [
        // === Monomino (1æ ¼) ===
        { s: [[1]], color: '#ffd54f', name: 'å–®æ ¼' },

        // === Domino (2æ ¼) ===
        { s: [[1,1]], color: '#81c784', name: 'æ©«äºŒ' },
        { s: [[1],[1]], color: '#81c784', name: 'ç›´äºŒ' },

        // === æ–œå‘ 2æ ¼ ===
        { s: [[1,0],[0,1]], color: '#ffb74d', name: 'å³æ–œäºŒ' },
        { s: [[0,1],[1,0]], color: '#ffb74d', name: 'å·¦æ–œäºŒ' },

        // === Tromino (3æ ¼) ===
        { s: [[1,1,1]], color: '#64b5f6', name: 'æ©«ä¸‰' },
        { s: [[1],[1],[1]], color: '#64b5f6', name: 'ç›´ä¸‰' },

// Lå‹ 4 å€‹æ–¹å‘
        { s: [[1,1],[1,0]], color: '#4fc3f7', name: 'å·¦ä¸‹L3' },  // â””
        { s: [[1,1],[0,1]], color: '#4fc3f7', name: 'å³ä¸‹L3' },  // â”˜
        { s: [[1,0],[1,1]], color: '#4fc3f7', name: 'å·¦ä¸ŠL3' },  // â”Œ
        { s: [[0,1],[1,1]], color: '#4fc3f7', name: 'å³ä¸ŠL3' },  // â”

        // === æ–œå‘ 3æ ¼ ===
        { s: [[1,0,0],[0,1,0],[0,0,1]], color: '#f06292', name: 'å³æ–œä¸‰' },
        { s: [[0,0,1],[0,1,0],[1,0,0]], color: '#f06292', name: 'å·¦æ–œä¸‰' },

        // === Tetromino (4æ ¼) ===
        { s: [[1,1,1,1]], color: '#42a5f5', name: 'æ©«å››' },
        { s: [[1],[1],[1],[1]], color: '#42a5f5', name: 'ç›´å››' },
        { s: [[1,1],[1,1]], color: '#66bb6a', name: 'ç”°å­—' },

        // === æ–œå‘ 4æ ¼ ===
        { s: [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], color: '#ff6f00', name: 'å³æ–œå››', code: '4dr' },
        { s: [[0,0,0,1],[0,0,1,0],[0,1,0,0],[1,0,0,0]], color: '#ff6f00', name: 'å·¦æ–œå››', code: '4dl' },

// Tå­— 4å€‹æ–¹å‘ âœ…
        { s: [[1,1,1],[0,1,0]], color: '#ba68c8', name: 'Tå­—ä¸Š' },
        { s: [[0,1,0],[1,1,1]], color: '#ba68c8', name: 'Tå­—ä¸‹' },
        { s: [[1,0],[1,1],[1,0]], color: '#ba68c8', name: 'Tå­—å·¦' },
        { s: [[0,1],[1,1],[0,1]], color: '#ba68c8', name: 'Tå­—å³' },

// Lå­— 4å€‹æ–¹å‘ âœ…
        { s: [[1,1,1],[1,0,0]], color: '#ffa726', name: 'Lå­—å·¦ä¸Š' },
        { s: [[1,0,0],[1,1,1]], color: '#ffa726', name: 'Lå­—å·¦ä¸‹' },
        { s: [[1,1],[0,1],[0,1]], color: '#ffa726', name: 'Lå­—å³ä¸Š' },
        { s: [[0,1],[0,1],[1,1]], color: '#ffa726', name: 'Lå­—å³ä¸‹' },

        // éœ€è¦æ–°å¢ Jå­— 4å€‹æ–¹å‘ï¼ˆLçš„é¡åƒï¼‰
        { s: [[1,1,1],[0,0,1]], color: '#ff9800', name: 'Jå­—å³ä¸Š' },
        { s: [[0,0,1],[1,1,1]], color: '#ff9800', name: 'Jå­—å³ä¸‹' },
        { s: [[1,1],[1,0],[1,0]], color: '#ff9800', name: 'Jå­—å·¦ä¸Š' },
        { s: [[1,0],[1,0],[1,1]], color: '#ff9800', name: 'Jå­—å·¦ä¸‹' },

// Zå­— 4å€‹æ–¹å‘ (è£œå……2å€‹) âš ï¸
        { s: [[1,1,0],[0,1,1]], color: '#ef5350', name: 'Zå­—å³' },
        { s: [[0,1,1],[1,1,0]], color: '#ef5350', name: 'Zå­—å·¦' },
        { s: [[0,1],[1,1],[1,0]], color: '#ef5350', name: 'Zå­—ä¸Š' },  // æ–°å¢
        { s: [[1,0],[1,1],[0,1]], color: '#ef5350', name: 'Zå­—ä¸‹' },  // æ–°å¢

        // å‡¸å­—å‹ 4å€‹æ–¹å‘
        { s: [[0,0,1],[1,1,1],[1,0,0]], color: '#4dd0e1', name: 'å‡¸å­—å³ä¸Š' },
        { s: [[1,0,0],[1,1,1],[0,0,1]], color: '#4dd0e1', name: 'å‡¸å­—å·¦ä¸Š' },
        { s: [[1,0],[1,1],[0,1]], color: '#4dd0e1', name: 'å‡¸å­—å³ä¸‹' },
        { s: [[0,1],[1,1],[1,0]], color: '#4dd0e1', name: 'å‡¸å­—å·¦ä¸‹' },

// å‡¹å­—å‹ 4å€‹æ–¹å‘
        { s: [[1,0,1],[1,1,1]], color: '#ffb300', name: 'å‡¹å­—ä¸‹' },
        { s: [[1,1,1],[1,0,1]], color: '#ffb300', name: 'å‡¹å­—ä¸Š' },
        { s: [[1,1],[0,1],[1,1]], color: '#ffb300', name: 'å‡¹å­—å·¦' },
        { s: [[1,1],[1,0],[1,1]], color: '#ffb300', name: 'å‡¹å­—å³' },

// åå­—å‹
        { s: [[0,1,0],[1,1,1],[0,1,0]], color: '#8e24aa', name: 'åå­—' },

// === Pentomino (5æ ¼) ===
        { s: [[1,1,1,1,1]], color: '#ab47bc', name: 'æ©«äº”' },
        { s: [[1],[1],[1],[1],[1]], color: '#ab47bc', name: 'ç›´äº”' },

// å¤§L 4å€‹æ–¹å‘ âœ…
        { s: [[1,1,1],[1,0,0],[1,0,0]], color: '#ec407a', name: 'å¤§Lå·¦ä¸Š' },
        { s: [[1,1,1],[0,0,1],[0,0,1]], color: '#ec407a', name: 'å¤§Lå³ä¸Š' },
        { s: [[1,0,0],[1,0,0],[1,1,1]], color: '#ec407a', name: 'å¤§Lå·¦ä¸‹' },
        { s: [[0,0,1],[0,0,1],[1,1,1]], color: '#ec407a', name: 'å¤§Lå³ä¸‹' },

        // éœ€è¦æ–°å¢ é•·J 4å€‹æ–¹å‘
        { s: [[1,1,1,1],[0,0,0,1]], color: '#9575cd', name: 'é•·Jå³ä¸Š' },
        { s: [[0,1],[0,1],[0,1],[1,1]], color: '#9575cd', name: 'é•·Jå³ä¸‹' },
        { s: [[1,0,0,0],[1,1,1,1]], color: '#9575cd', name: 'é•·Jå·¦ä¸‹' },
        { s: [[1,1],[1,0],[1,0],[1,0]], color: '#9575cd', name: 'é•·Jå·¦ä¸Š' },

// å¤§T 4å€‹æ–¹å‘ (è£œå……2å€‹) âš ï¸
        { s: [[1,1,1],[0,1,0],[0,1,0]], color: '#26c6da', name: 'å¤§Tä¸Š' },
        { s: [[0,1,0],[0,1,0],[1,1,1]], color: '#26c6da', name: 'å¤§Tä¸‹' },
        { s: [[1,0,0],[1,1,1],[1,0,0]], color: '#26c6da', name: 'å¤§Tå·¦' },  // æ–°å¢
        { s: [[0,0,1],[1,1,1],[0,0,1]], color: '#26c6da', name: 'å¤§Tå³' },  // æ–°å¢

// é•·L 4å€‹æ–¹å‘ âœ…
        { s: [[1,1,1,1],[1,0,0,0]], color: '#7e57c2', name: 'é•·Lå·¦ä¸Š' },
        { s: [[1,1,1,1],[0,0,0,1]], color: '#7e57c2', name: 'é•·Lå³ä¸Š' },
        { s: [[1,1],[1,0],[1,0],[1,0]], color: '#5c6bc0', name: 'é•·Lå·¦ä¸‹' },
        { s: [[1,1],[0,1],[0,1],[0,1]], color: '#5c6bc0', name: 'é•·Lå³ä¸‹' },

// èƒ–L 4å€‹æ–¹å‘ (è£œå……2å€‹) âš ï¸
        { s: [[1,1,1],[1,1,0]], color: '#9ccc65', name: 'å¯¬Lå·¦ä¸‹' },
        { s: [[1,1,0],[1,1,1]], color: '#9ccc65', name: 'å¯¬Lå³ä¸‹' },
        { s: [[0,1,1],[1,1,1]], color: '#9ccc65', name: 'å¯¬Lå³ä¸Š' },
        { s: [[1,1,1],[0,1,1]], color: '#9ccc65', name: 'å¯¬Lå·¦ä¸Š' },

        { s: [[1,1],[1,1],[0,1]], color: '#9ccc65', name: 'é«˜Lå·¦ä¸‹' },
        { s: [[1,1],[1,1],[1,0]], color: '#9ccc65', name: 'é«˜Lå³ä¸‹' },
        { s: [[0,1],[1,1],[1,1]], color: '#9ccc65', name: 'é«˜Lå·¦ä¸Š' },
        { s: [[1,0],[1,1],[1,1]], color: '#9ccc65', name: 'é«˜Lå³ä¸Š' },

        // === æ–œå‘ 5æ ¼ï¼ˆå¤§é­”ç‹ç´šï¼‰===
        { s: [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]], color: '#e91e63', name: 'å³æ–œäº”' },
        { s: [[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0]], color: '#e91e63', name: 'å·¦æ–œäº”' },

        // === ç‰¹æ®Šå¤§æ–¹å¡Š ===
        { s: [[1,1,1],[1,1,1]], color: '#ff7043', name: 'èƒ–ç”°3x2' },
        { s: [[1,1],[1,1],[1,1]], color: '#ff7043', name: 'é«˜ç”°2x3' },
        { s: [[1,1,1],[1,1,1],[1,1,1]], color: '#f44336', name: 'ä¹å®®æ ¼' },
    ];





    // ========== éŠæˆ²æ¨¡å¼è¨­å®š ==========
    class GameSettings {
        constructor() {
            this.boardMode = localStorage.getItem('woodoku_board_mode') || 'endgame';
        }

        setBoardMode(mode) {
            this.boardMode = mode;
            localStorage.setItem('woodoku_board_mode', mode);
        }

        getBoardMode() {
            return this.boardMode;
        }
    }

    const gameSettings = new GameSettings();

    // ========== ç”¨æˆ¶è³‡æ–™ç®¡ç† ==========
    class UserProfile {
        constructor() {
            this.loadProfile();
        }

        loadProfile() {
            const saved = localStorage.getItem('woodoku_user_profile');
            if (saved) {
                const profile = JSON.parse(saved);
                this.name = profile.name;
                this.avatar = profile.avatar;
            } else {
                this.generateRandom();
            }
        }

        generateRandom() {
            // éš¨æ©Ÿè‹±æ–‡åå­—
            this.name = this.randomString(8);
            // éš¨æ©Ÿé ­åƒé¡è‰²
            this.avatar = this.randomColor();
            this.save();
        }

        randomString(length) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        randomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        save() {
            localStorage.setItem('woodoku_user_profile', JSON.stringify({
                name: this.name,
                avatar: this.avatar
            }));
        }

        setName(newName) {
            this.name = newName || this.randomString(8);
            this.save();
        }

        setAvatar(file) {
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.avatar = e.target.result;
                    this.save();
                    updateSettingsPanel();
                };
                reader.readAsDataURL(file);
            }
        }

        resetAvatar() {
            this.avatar = this.randomColor();
            this.save();
        }
    }

    // åˆå§‹åŒ–ç”¨æˆ¶è³‡æ–™
    const userProfile = new UserProfile();

    // ========== æœ€é«˜åˆ†è¨˜éŒ„ç³»çµ± ==========
    class HighScoreManager {
        constructor() {
            this.scores = {
                timed: parseInt(localStorage.getItem('highscore_timed')) || 0,
                infinite: parseInt(localStorage.getItem('highscore_infinite')) || 0,
                ai: parseInt(localStorage.getItem('highscore_ai')) || 0
            };
        }

        updateScore(mode, newScore) {
            if (newScore > this.scores[mode]) {
                this.scores[mode] = newScore;
                localStorage.setItem(`highscore_${mode}`, newScore);
                return true; // è¿”å›æ˜¯å¦ç ´ç´€éŒ„
            }
            return false;
        }

        getScore(mode) {
            return this.scores[mode];
        }

        reset(mode) {
            if (mode) {
                this.scores[mode] = 0;
                localStorage.setItem(`highscore_${mode}`, 0);
            } else {
                // é‡ç½®æ‰€æœ‰
                this.scores = { timed: 0, infinite: 0, ai: 0 };
                localStorage.setItem('highscore_timed', 0);
                localStorage.setItem('highscore_infinite', 0);
                localStorage.setItem('highscore_ai', 0);
            }
        }
    }

    const highScoreManager = new HighScoreManager();

    function createSettingsPanel() {
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if (document.getElementById('game-settings-panel')) {
            return;
        }

        const panel = document.createElement('div');
        panel.id = 'game-settings-panel';

        // âœ… åŠ å…¥é€™æ®µ CSS æ¨£å¼
        panel.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 30px 30px 20px 30px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        z-index: 10000;
        display: none;
        min-width: 500px;
        max-width: 90vw;
        max-height: 85vh;
        overflow-y: auto;
        color: white;
        -webkit-overflow-scrolling: touch;
    `;

        panel.innerHTML = `
    <!-- âœ… æ–°å¢:å³ä¸Šè§’é—œé–‰æŒ‰éˆ• -->
    <button id="top-close-btn" style="
        position: absolute;
        top: 15px;
        right: 15px;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255,255,255,0.2);
        border: 2px solid rgba(255,255,255,0.4);
        color: white;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
        transition: all 0.3s;
    " onmouseover="this.style.background='rgba(255,255,255,0.3)'"
       onmouseout="this.style.background='rgba(255,255,255,0.2)'">âœ•</button>

    <div style="text-align: center; margin-bottom: 25px;">
        <h2 style="margin: 0; font-size: 28px; color: white;">âš™ï¸ éŠæˆ²è¨­å®š</h2>
    </div>

    <!-- ç”¨æˆ¶è³‡æ–™å€ -->
    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
        <h3 style="margin: 0 0 15px 0; font-size: 18px; color: #FFD700;">ğŸ‘¤ ç©å®¶è³‡æ–™</h3>

        <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
            <!-- é ­åƒ -->
            <div style="position: relative;">
                <div id="avatar-display" style="
                    width: 80px;
                    height: 80px;
                    border-radius: 50%;
                    background: ${userProfile.avatar.startsWith('#') ? userProfile.avatar : 'transparent'};
                    ${userProfile.avatar.startsWith('data:') ? `background-image: url(${userProfile.avatar}); background-size: cover; background-position: center;` : ''}
                    border: 3px solid white;
                    cursor: pointer;
                "></div>
                <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
            </div>

            <!-- åå­— -->
            <div style="flex: 1;">
                <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #FFD700;">ç©å®¶åç¨±</label>
                <input
                    type="text"
                    id="player-name-input"
                    value="${userProfile.name}"
                    style="
                        width: 100%;
                        padding: 10px;
                        border: 2px solid rgba(255,255,255,0.3);
                        border-radius: 8px;
                        background: rgba(255,255,255,0.2);
                        color: white;
                        font-size: 16px;
                        font-weight: bold;
                    "
                    placeholder="è¼¸å…¥åç¨±"
                >
            </div>
        </div>

        <button id="save-profile-btn" style="
            width: 100%;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        ">ğŸ’¾ ä¿å­˜è³‡æ–™</button>
    </div>

<!-- æ£‹ç›¤åˆå§‹æ¨¡å¼ -->
<div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
    <h3 style="margin: 0 0 15px 0; font-size: 18px; color: #FFD700;">ğŸ® æ£‹ç›¤åˆå§‹æ¨¡å¼</h3>

    <div style="display: grid; gap: 10px;">
        <label class="board-mode-option" data-mode="empty">
            <input type="radio" name="board-mode" value="empty" ${gameSettings.getBoardMode() === 'endgame' ? '' : (gameSettings.getBoardMode() === 'empty' ? 'checked' : '')}>
            <div>
                <div style="font-size: 16px; font-weight: bold;">â¬œ å…¨ç©ºæ¨¡å¼</div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.7);">æ£‹ç›¤å®Œå…¨ç©ºç™½ï¼Œå¾é›¶é–‹å§‹</div>
            </div>
        </label>

        <label class="board-mode-option" data-mode="random">
            <input type="radio" name="board-mode" value="random" ${gameSettings.getBoardMode() === 'random' ? 'checked' : ''}>
            <div>
                <div style="font-size: 16px; font-weight: bold;">ğŸ² éš¨æ©Ÿæ¨¡å¼</div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.7);">æ£‹ç›¤éš¨æ©Ÿç”¢ç”Ÿéƒ¨åˆ†æ–¹å¡Š</div>
            </div>
        </label>

        <label class="board-mode-option" data-mode="endgame">
            <input type="radio" name="board-mode" value="endgame" ${gameSettings.getBoardMode() === 'endgame' ? 'checked' : ''}>
            <div>
                <div style="font-size: 16px; font-weight: bold;">ğŸ”¥ æ®˜å±€æ¨¡å¼</div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.7);">æ£‹ç›¤è¼ƒæ“æ“ ï¼ŒæŒ‘æˆ°æ€§é«˜</div>
            </div>
        </label>
    </div>
</div>

<style>
.board-mode-option {
    display: flex;
    align-items: center;
    padding: 12px;
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
}

.board-mode-option input[type="radio"] {
    margin-right: 10px;
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.board-mode-option input[type="radio"]:checked {
    accent-color: #4CAF50;
}

.board-mode-option:has(input:checked) {
    background: rgba(76,175,80,0.3);
    border-color: #4CAF50;
}
</style>

    <!-- æœ€é«˜åˆ†è¨˜éŒ„ -->
    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
        <h3 style="margin: 0 0 15px 0; font-size: 18px; color: #FFD700;">ğŸ† æœ€é«˜åˆ†ç´€éŒ„</h3>

        <div style="display: grid; gap: 12px;">
            <div style="background: rgba(255,215,0,0.1); padding: 12px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 16px;">â±ï¸ é™æ™‚æ¨¡å¼</span>
                <span style="font-size: 20px; font-weight: bold; color: #FFD700;">${highScoreManager.getScore('timed')}</span>
            </div>

            <div style="background: rgba(255,215,0,0.1); padding: 12px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 16px;">â™¾ï¸ ç„¡é™æ¨¡å¼</span>
                <span style="font-size: 20px; font-weight: bold; color: #FFD700;">${highScoreManager.getScore('infinite')}</span>
            </div>

            <div style="background: rgba(255,215,0,0.1); padding: 12px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 16px;">ğŸ¤– AI ç„¡ç›¡æ¨¡å¼</span>
                <span style="font-size: 20px; font-weight: bold; color: #FFD700;">${highScoreManager.getScore('ai')}</span>
            </div>
        </div>
    </div>

    <!-- é—œé–‰æŒ‰éˆ• -->
    <button id="close-settings-btn" style="
        width: 100%;
        padding: 12px;
        background: rgba(255,255,255,0.2);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
    ">âœ–ï¸ é—œé–‰</button>
`;
        document.body.appendChild(panel);

        // ç¶å®šäº‹ä»¶
        setupSettingsEvents();
    }

    function setupSettingsEvents() {

        // âœ… æ–°å¢:å³ä¸Šè§’é—œé–‰æŒ‰éˆ•
        document.getElementById('top-close-btn')?.addEventListener('click', () => {
            document.getElementById('game-settings-panel').style.display = 'none';
        });

        // åŸæœ‰çš„é—œé–‰æŒ‰éˆ•
        document.getElementById('close-settings-btn')?.addEventListener('click', () => {
            document.getElementById('game-settings-panel').style.display = 'none';
        });

        const panel = document.getElementById('game-settings-panel');

        // é ­åƒä¸Šå‚³
        document.getElementById('avatar-display').addEventListener('click', () => {
            document.getElementById('avatar-upload').click();
        });

        document.getElementById('avatar-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                userProfile.setAvatar(file);
            }
        });

        // ä¿å­˜è³‡æ–™
        document.getElementById('save-profile-btn').addEventListener('click', () => {
            const newName = document.getElementById('player-name-input').value.trim();
            userProfile.setName(newName);
            showNotification('è³‡æ–™å·²ä¿å­˜ï¼', 'success');
        });

        // æ£‹ç›¤æ¨¡å¼é¸æ“‡
        document.querySelectorAll('input[name="board-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                gameSettings.setBoardMode(e.target.value);
                updateSettingsPanel();
            });
        });

        // é—œé–‰é¢æ¿
        document.getElementById('close-settings-btn').addEventListener('click', () => {
            panel.style.display = 'none';
        });
    }

    function updateSettingsPanel() {
        const avatarDisplay = document.getElementById('avatar-display');
        if (avatarDisplay) {
            if (userProfile.avatar.startsWith('#')) {
                avatarDisplay.style.background = userProfile.avatar;
                avatarDisplay.style.backgroundImage = 'none';
            } else {
                avatarDisplay.style.background = 'transparent';
                avatarDisplay.style.backgroundImage = `url(${userProfile.avatar})`;
                avatarDisplay.style.backgroundSize = 'cover';
                avatarDisplay.style.backgroundPosition = 'center';
            }
        }

        const nameInput = document.getElementById('player-name-input');
        if (nameInput) {
            nameInput.value = userProfile.name;
        }

        // æ›´æ–°æœ€é«˜åˆ†é¡¯ç¤º
        const panel = document.getElementById('game-settings-panel');
        if (panel) {
            const scores = panel.querySelectorAll('[style*="font-weight: bold; color: #FFD700"]');
            if (scores.length >= 3) {
                scores[0].textContent = highScoreManager.getScore('timed');
                scores[1].textContent = highScoreManager.getScore('infinite');
                scores[2].textContent = highScoreManager.getScore('ai');
            }
        }
    }

    function showSettingsPanel() {
        createSettingsPanel();
        const panel = document.getElementById('game-settings-panel');
        panel.style.display = 'block';
        updateSettingsPanel();
    }

    function addSettingsButton() {
        // æª¢æŸ¥æ˜¯å¦å·²ç¶“æ·»åŠ é
        if (document.getElementById('settings-btn')) return;

        const undoButton = document.querySelector('button');
        if (!undoButton) {
            setTimeout(addSettingsButton, 500);
            return;
        }

        const buttonContainer = undoButton.parentElement;

        const settingsBtn = document.createElement('button');
        settingsBtn.id = 'settings-btn';
        settingsBtn.textContent = 'âš™ï¸ è¨­å®š';
        settingsBtn.style.cssText = `
        padding: 12px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        margin-left: 10px;
    `;

        settingsBtn.addEventListener('click', showSettingsPanel);
        buttonContainer.appendChild(settingsBtn);
    }

    function updateScoreDisplay() {
        const scoreDiv = document.getElementById('score');
        if (!scoreDiv) return;

        // æª¢æŸ¥æ˜¯å¦å·²ç¶“åˆå§‹åŒ–é
        if (document.getElementById('overall-highscore-value')) {
            // åªæ›´æ–°æœ€é«˜åˆ†æ•¸å€¼
            const highScoreEl = document.getElementById('overall-highscore-value');
            const maxScore = Math.max(
                highScoreManager.getScore('timed'),
                highScoreManager.getScore('infinite'),
                highScoreManager.getScore('ai')
            );
            if (highScoreEl) highScoreEl.textContent = maxScore;
            return;
        }

        // è¨ˆç®—ä¸‰ç¨®æ¨¡å¼ä¸­çš„æœ€é«˜åˆ†
        const maxScore = Math.max(
            highScoreManager.getScore('timed'),
            highScoreManager.getScore('infinite'),
            highScoreManager.getScore('ai')
        );

        // åœ¨åˆ†æ•¸ä¸Šæ–¹æ’å…¥æœ€é«˜åˆ†é¡¯ç¤º
        const highScoreContainer = document.createElement('div');
        highScoreContainer.id = 'overall-highscore-container';
        highScoreContainer.style.cssText = `
        text-align: center;
        margin-bottom: 20px;
    `;

        highScoreContainer.innerHTML = `
        <div style="font-size: 18px; color: white; margin-bottom: 8px;">
    <span style="font-size: 32px;">ğŸ‘‘</span> æœ€é«˜åˆ†ç´€éŒ„
</div>
        <div id="overall-highscore-value" style="font-size: 36px; font-weight: bold; color: #FFD700;">${maxScore}</div>
    `;

        // åœ¨ç•¶å‰åˆ†æ•¸å…ƒç´ ä¹‹å‰æ’å…¥
        scoreDiv.parentElement.insertBefore(highScoreContainer, scoreDiv);
    }

    // ========== æ•´åˆåˆ°ç¾æœ‰ç³»çµ± ==========

    // åœ¨éŠæˆ²çµæŸæ™‚æ›´æ–°æœ€é«˜åˆ†
    function updateHighScoreOnGameEnd(mode, finalScore) {
        const modeMap = {
            'timed': 'timed',
            'infinite': 'infinite',
            'ai': 'ai'
        };

        const scoreMode = modeMap[mode];
        if (!scoreMode) return;

        const isNewRecord = highScoreManager.updateScore(scoreMode, finalScore);

        if (isNewRecord) {
            console.log(`ğŸ‰ æ–°ç´€éŒ„ï¼${mode} æ¨¡å¼: ${finalScore}`);
            // å¯ä»¥åœ¨é€™è£¡åŠ å…¥æ…¶ç¥å‹•ç•«
        }

        updateScoreDisplay();
    }

    function initGameSettings() {
        setTimeout(() => {
            addSettingsButton();
            updateScoreDisplay();
            console.log('âœ… éŠæˆ²è¨­å®šç³»çµ±å·²åˆå§‹åŒ–');
            console.log('ğŸ‘¤ ç•¶å‰ç©å®¶:', userProfile.name);
        }, 1000);
    }

    // å°å‡ºçµ¦å¤–éƒ¨ä½¿ç”¨
    window.gameSettings = {
        userProfile,
        highScoreManager,
        showSettings: showSettingsPanel,
        updateHighScore: updateHighScoreOnGameEnd,
        init: initGameSettings
    };

    // ===== æ–°å¢ï¼šè¨ˆç®—åˆ†æ•¸å‡½æ•¸ =====
    function calculateScore(clearedLines) {
        if (clearedLines === 0) {
            streakCount = 0; // ä¸­æ–·é€£æ“Š
            lastMoveCleared = false;
            return 0;
        }

        // åŸºç¤åˆ†æ•¸ï¼šæ¯æ¢ç·š 8 æ ¼ Ã— 10 åˆ†
        const basePoints = clearedLines * 8 * 10;

        // Combo åŠ åˆ†
        const bonus = comboBonus[Math.min(clearedLines, 9)] || 100;

        // Streak é€£æ“Šå€æ•¸ï¼ˆæ¯é€£çºŒä¸€å›åˆ +5%ï¼‰
        streakCount++;
        const streakMultiplier = 1 + (streakCount - 1) * 0.05;

        lastMoveCleared = true;

        // ç¸½åˆ† = (åŸºç¤åˆ† + ComboåŠ åˆ†) Ã— Streakå€æ•¸
        return Math.floor((basePoints + bonus) * streakMultiplier);
    }

    function getStrategiesByDensity(density) {
        if (density < 0.4) {
            // ä½å¯†åº¦ï¼šç°¡å–®ç­–ç•¥
            return [
                { name: 'æ™ºèƒ½éš¨æ©Ÿ', method: generateSmartRandom, weight: 1.0 }
            ];
        } else if (density < 0.6) {
            // ä¸­ä½å¯†åº¦ï¼šæ··åˆåŸºç¤ç­–ç•¥
            return [
                { name: 'é€†å‘æ§‹é€ ', method: constructChallengingPuzzle, weight: 0.5 },
                { name: 'æ­£å‘æœç´¢', method: searchChallengingPuzzle, weight: 0.3 },
                { name: 'æ··åˆæ¨¡å¼', method: hybridGeneration, weight: 0.2 }
            ];
        } else if (density < 0.8) {
            // ä¸­é«˜å¯†åº¦ï¼šé€²éšç­–ç•¥
            return [
                { name: 'é€†å‘æ§‹é€ ', method: constructChallengingPuzzle, weight: 0.35 },
                { name: 'æ­£å‘æœç´¢', method: searchChallengingPuzzle, weight: 0.25 },
                { name: 'è·¯å¾‘ä¾è³´', method: generatePathDependencyPuzzle, weight: 0.3 },
                { name: 'æ··åˆæ¨¡å¼', method: hybridGeneration, weight: 0.1 }
            ];
        } else {
            // é«˜å¯†åº¦ï¼šæœ€é›£ç­–ç•¥
            return [
                { name: 'æ­£å‘æœç´¢', method: searchChallengingPuzzle, weight: 0.4 },
                { name: 'é€†å‘æ§‹é€ ', method: constructChallengingPuzzle, weight: 0.3 },
                { name: 'æ··åˆ+èª˜é¨™', method: hybridGenerationWithDecoy, weight: 0.2 },
                { name: 'è·¯å¾‘ä¾è³´', method: generatePathDependencyPuzzle, weight: 0.1 }
            ];
        }
    }

    // åŠ æ¬Šéš¨æ©Ÿé¸æ“‡
    function weightedRandom(items) {
        const total = items.reduce((sum, item) => sum + item.weight, 0);
        let random = Math.random() * total;

        for (let item of items) {
            random -= item.weight;
            if (random <= 0) return item;
        }
        return items[0];
    }

    function generateSmartRandom() {
        const maxAttempts = 200; // æé«˜åˆ°200æ¬¡
        const density = getBoardDensity();

        // æ ¹æ“šå¯†åº¦èª¿æ•´æ–¹å¡Šå¤§å°åå¥½
        let sizePreference;
        if(density < 0.3) {
            sizePreference = [1, 5]; // ä½å¯†åº¦: ä»»æ„å¤§å°
        } else if(density < 0.6) {
            sizePreference = [1, 3]; // ä¸­å¯†åº¦: åå°
        } else {
            sizePreference = [1, 2]; // é«˜å¯†åº¦: åªç”¨æœ€å°çš„
        }

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const pieces = [
                getShapeBySize(sizePreference[0], sizePreference[1]),
                getShapeBySize(sizePreference[0], sizePreference[1]),
                getShapeBySize(sizePreference[0], sizePreference[1])
            ];

            const solution = findCompleteSolution(pieces, boardState);
            if (solution) {
                aiSolution = solution;
                aiSolution.difficulty = 'smart-random';
                //console.log(`ğŸ¤– æ™ºèƒ½éš¨æ©ŸæˆåŠŸ(ç¬¬${attempt+1}æ¬¡)`);
                return pieces;
            }
        }

        return null; // å¤±æ•—å¾Œæœƒé€²å…¥çµ‚æ¥µä¿åº•
    }

    // æ–°å¢: æŒ‰å¤§å°ç¯„åœé¸æ–¹å¡Š
    function getShapeBySize(minSize, maxSize) {
        const filtered = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area >= minSize && area <= maxSize;
        });

        return cloneShape(filtered[Math.floor(Math.random() * filtered.length)]);
    }

    function generatePathDependencyPuzzle() {
        const maxAttempts = 100;
        const smallShapes = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area >= 2 && area <= 4; // ä¸­å°å‹æ–¹å¡Š
        });

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            // æ­¥é©Ÿ 1: éš¨æ©Ÿé¸ç¬¬ä¸€å€‹å°æ–¹å¡Š
            const pieceA = cloneShape(smallShapes[Math.floor(Math.random() * smallShapes.length)]);

            // å˜—è©¦æ‰€æœ‰ A çš„æ”¾ç½®ä½ç½®
            for (let r1 = 0; r1 < 8; r1++) {
                for (let c1 = 0; c1 < 8; c1++) {
                    if (!canPlaceOnBoard(pieceA.s, r1, c1, boardState)) continue;

                    const board1 = simulatePlace(pieceA.s, r1, c1, boardState);
                    const cleared1 = simulateLineClear(board1);

                    // A å¿…é ˆæ¶ˆé™¤è‡³å°‘ 1 æ¢ç·š
                    const cleared1Count = getClearedLineCount(board1, cleared1);
                    if (cleared1Count === 0) continue;

                    // æ­¥é©Ÿ 2: éš¨æ©Ÿé¸ç¬¬äºŒå€‹å°æ–¹å¡Š
                    const pieceB = cloneShape(smallShapes[Math.floor(Math.random() * smallShapes.length)]);

                    // å˜—è©¦æ‰€æœ‰ B çš„æ”¾ç½®ä½ç½®
                    for (let r2 = 0; r2 < 8; r2++) {
                        for (let c2 = 0; c2 < 8; c2++) {
                            if (!canPlaceOnBoard(pieceB.s, r2, c2, cleared1)) continue;

                            const board2 = simulatePlace(pieceB.s, r2, c2, cleared1);
                            const cleared2 = simulateLineClear(board2);

                            // B ä¹Ÿè¦æ¶ˆé™¤è‡³å°‘ 1 æ¢ç·š
                            const cleared2Count = getClearedLineCount(board2, cleared2);
                            if (cleared2Count === 0) continue;

                            // æ­¥é©Ÿ 3: æ‰¾ä¸€å€‹å¤§æ–¹å¡Š C
                            const bigShapes = allShapes.filter(s => {
                                const area = s.s.flat().filter(v => v).length;
                                return area >= 5;
                            });

                            for (let bigShape of bigShapes) {
                                const pieceC = cloneShape(bigShape);

                                // ğŸ”‘ é—œéµé©—è­‰ï¼šC åœ¨åŸå§‹æ£‹ç›¤ä¸èƒ½æ”¾
                                if (hasValidPlacement(pieceC.s, boardState)) continue;

                                // ä½†åœ¨ board2 èƒ½æ”¾
                                const allCPositions = findAllValidPositions(pieceC.s, cleared2);
                                if (allCPositions.length === 0) continue;

                                // é¸æ“‡ä¸èˆ‡ Aã€B é‡ç–Šçš„ä½ç½®
                                let cPos = null;
                                for (let pos of allCPositions) {
                                    const overlapsA = checkOverlap(pieceC.s, pos.r, pos.c, pieceA.s, r1, c1);
                                    const overlapsB = checkOverlap(pieceC.s, pos.r, pos.c, pieceB.s, r2, c2);

                                    if (!overlapsA && !overlapsB) {
                                        cPos = pos;
                                        break;
                                    }
                                }

                                if (!cPos) continue;

                                // ğŸ”‘ é©—è­‰è·¯å¾‘ä¾è³´æ€§ï¼šå…¶ä»–é †åºéƒ½ç„¡è§£
                                const isPathDependent = validatePathDependency(
                                    [pieceA, pieceB, pieceC],
                                    [
                                        { r: r1, c: c1 },
                                        { r: r2, c: c2 },
                                        { r: cPos.r, c: cPos.c }
                                    ],
                                    boardState
                                );

                                if (!isPathDependent) continue;

                                // âœ… æ‰¾åˆ°æœ‰æ•ˆçš„è·¯å¾‘ä¾è³´è¬é¡Œ
                                aiSolution = {
                                    pieces: [
                                        { piece: cloneShape(pieceA), name: pieceA.name },
                                        { piece: cloneShape(pieceB), name: pieceB.name },
                                        { piece: cloneShape(pieceC), name: pieceC.name }
                                    ],
                                    steps: [
                                        {
                                            piece: cloneShape(pieceA),
                                            pieceName: pieceA.name,
                                            position: { row: r1, col: c1 },
                                            notation: toNotation(r1, c1),
                                            clearedLines: cleared1Count
                                        },
                                        {
                                            piece: cloneShape(pieceB),
                                            pieceName: pieceB.name,
                                            position: { row: r2, col: c2 },
                                            notation: toNotation(r2, c2),
                                            clearedLines: cleared2Count
                                        },
                                        {
                                            piece: cloneShape(pieceC),
                                            pieceName: pieceC.name,
                                            position: { row: cPos.r, col: cPos.c },
                                            notation: toNotation(cPos.r, cPos.c),
                                            clearedLines: 0
                                        }
                                    ],
                                    foundAt: new Date().toISOString(),
                                    difficulty: 'path-dependent',
                                    pathInfo: {
                                        validOrder: 'Aâ†’Bâ†’C',
                                        invalidOrders: ['Bâ†’Aâ†’C', 'Câ†’Aâ†’B', 'Aâ†’Câ†’B', 'Bâ†’Câ†’A', 'Câ†’Bâ†’A']
                                    }
                                };

                                //console.log(`âœ… è·¯å¾‘ä¾è³´æˆåŠŸ (ç¬¬${attempt+1}æ¬¡) - å”¯ä¸€é †åº: ${pieceA.name}â†’${pieceB.name}â†’${pieceC.name}`);
                                return [pieceA, pieceB, pieceC];
                            }
                        }
                    }
                }
            }
        }

        return null;
    }

    function validatePathDependency(pieces, correctPositions, board) {
        const [pieceA, pieceB, pieceC] = pieces;
        const [posA, posB, posC] = correctPositions;

        // å®šç¾©æ‰€æœ‰å¯èƒ½çš„é †åºï¼ˆé™¤äº†æ­£ç¢ºçš„ Aâ†’Bâ†’Cï¼‰
        const alternativeOrders = [
            { order: [1, 0, 2], name: 'Bâ†’Aâ†’C' }, // Bå…ˆ
            { order: [2, 0, 1], name: 'Câ†’Aâ†’B' }, // Cå…ˆ
            { order: [0, 2, 1], name: 'Aâ†’Câ†’B' }, // Aâ†’Câ†’B
            { order: [1, 2, 0], name: 'Bâ†’Câ†’A' }, // Bâ†’Câ†’A
            { order: [2, 1, 0], name: 'Câ†’Bâ†’A' }  // Câ†’Bâ†’A
        ];

        // æª¢æŸ¥æ‰€æœ‰æ›¿ä»£é †åºæ˜¯å¦éƒ½ç„¡è§£
        for (let { order, name } of alternativeOrders) {
            let testBoard = cloneBoard(board);
            let success = true;

            for (let i of order) {
                const piece = pieces[i];
                const placed = tryPlaceAnywhere(piece.s, testBoard);

                if (!placed) {
                    success = false;
                    break;
                }

                testBoard = placed.board;
            }

            // å¦‚æœä»»ä½•ä¸€å€‹æ›¿ä»£é †åºèƒ½æˆåŠŸï¼Œå‰‡ä¸æ˜¯çœŸæ­£çš„è·¯å¾‘ä¾è³´
            if (success) {
                //console.log(`âš ï¸ é †åº ${name} ä¹Ÿèƒ½è§£æ±ºï¼Œä¸æ˜¯çœŸæ­£çš„è·¯å¾‘ä¾è³´`);
                return false;
            }
        }

        // æ‰€æœ‰æ›¿ä»£é †åºéƒ½å¤±æ•—ï¼Œç¢ºèªæ˜¯è·¯å¾‘ä¾è³´
        return true;
    }

    function hybridGenerationWithDecoy() {
        const maxAttempts = 50;

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            // å…ˆç”¨é€†å‘æ§‹é€ æ‰¾åˆ°æœ‰è§£çš„åŸºç¤çµ„åˆ
            const base = constructChallengingPuzzle();
            if (!base) continue;

            const [pieceA, pieceB, bigPiece] = base;

            // ç¢ºä¿åŸºç¤çµ„åˆæœ‰å®Œæ•´è§£æ³•
            const baseSolution = findCompleteSolution([pieceA, pieceB, bigPiece], boardState);
            if (!baseSolution) continue;

            // åˆ†æå¤§æ–¹å¡Šéœ€è¦æ¶ˆé™¤å“ªäº›è¡Œ/åˆ—
            const targetLines = analyzeRequiredClears(bigPiece, boardState);

            // ğŸ”‘ å°‹æ‰¾èª˜é¨™è€…ï¼ˆçœ‹èµ·ä¾†èƒ½å¹«å¿™æ¶ˆé™¤ç›®æ¨™è¡Œ/åˆ—ï¼‰
            const decoy = findDecoyPiece(
                bigPiece,
                targetLines,
                boardState,
                [pieceA, pieceB],
                baseSolution
            );

            if (!decoy) continue;

            // ğŸ­ æ–°çµ„åˆï¼špieceA + pieceB + bigPiece + decoyï¼ˆ4å€‹æ–¹å¡Šï¼‰
            // ä½†åªçµ¦ç©å®¶3å€‹ï¼špieceAï¼ˆæˆ–Bï¼‰ + decoy + bigPiece

            // æ–¹æ¡ˆ1ï¼šæ›¿æ› pieceB ç‚º decoy
            const decoyCombo1 = [pieceA, decoy, bigPiece];
            const solution1 = findCompleteSolution(decoyCombo1, boardState);

            // æ–¹æ¡ˆ2ï¼šæ›¿æ› pieceA ç‚º decoy
            const decoyCombo2 = [decoy, pieceB, bigPiece];
            const solution2 = findCompleteSolution(decoyCombo2, boardState);

            // ğŸ”‘ é—œéµï¼šè‡³å°‘ä¸€å€‹çµ„åˆæœ‰è§£ï¼Œä½†èª˜é¨™è€…æœƒå¼•å°éŒ¯èª¤è·¯å¾‘
            if (solution1) {
                // é©—è­‰èª˜é¨™æ•ˆæœï¼šå¦‚æœå…ˆæ”¾ decoyï¼Œæ˜¯å¦æœƒå¡æ­»
                const trapEffective = validateDecoyTrap(decoy, pieceA, bigPiece, boardState);

                if (trapEffective) {
                    aiSolution = solution1;
                    aiSolution.difficulty = 'decoy-trap';
                    aiSolution.decoyInfo = {
                        decoyPiece: decoy.name,
                        correctPath: solution1.steps.map(s => s.pieceName).join('â†’'),
                        trapPath: `${decoy.name}å…ˆæ”¾æœƒå¡æ­»`,
                        targetLines: targetLines
                    };

                    //console.log(`âœ… èª˜é¨™é™·é˜±æˆåŠŸ (${attempt+1}æ¬¡) - èª˜é¤Œ: ${decoy.name}`);
                    //console.log(`   æ­£ç¢ºè·¯å¾‘: ${aiSolution.decoyInfo.correctPath}`);
                   // console.log(`   é™·é˜±è·¯å¾‘: ${aiSolution.decoyInfo.trapPath}`);

                    return decoyCombo1;
                }
            }

            if (solution2) {
                const trapEffective = validateDecoyTrap(decoy, pieceB, bigPiece, boardState);

                if (trapEffective) {
                    aiSolution = solution2;
                    aiSolution.difficulty = 'decoy-trap';
                    aiSolution.decoyInfo = {
                        decoyPiece: decoy.name,
                        correctPath: solution2.steps.map(s => s.pieceName).join('â†’'),
                        trapPath: `${decoy.name}å…ˆæ”¾æœƒå¡æ­»`
                    };

                   // console.log(`âœ… èª˜é¨™é™·é˜±æˆåŠŸ (${attempt+1}æ¬¡) - èª˜é¤Œ: ${decoy.name}`);
                    return decoyCombo2;
                }
            }
        }

        // å¦‚æœæ‰¾ä¸åˆ°èª˜é¨™è€…ï¼Œé€€å›åˆ°æ™®é€šæ··åˆæ¨¡å¼
        console.log('âš ï¸ æ‰¾ä¸åˆ°æœ‰æ•ˆèª˜é¨™è€…ï¼Œä½¿ç”¨æ™®é€šæ··åˆæ¨¡å¼');
        return hybridGeneration();
    }

    function validateDecoyTrap(decoy, otherPiece, bigPiece, board) {
        // æª¢æŸ¥ã€Œå…ˆæ”¾èª˜é¨™è€…ã€æ˜¯å¦æœƒå°è‡´ç„¡è§£

        // å˜—è©¦æ‰€æœ‰èª˜é¨™è€…çš„æ”¾ç½®ä½ç½®
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (!canPlaceOnBoard(decoy.s, r, c, board)) continue;

                const board1 = simulatePlace(decoy.s, r, c, board);
                const cleared1 = simulateLineClear(board1);

                // èª˜é¨™è€…å¿…é ˆèƒ½æ¶ˆé™¤è‡³å°‘ 1 æ¢ç·šï¼ˆçœ‹èµ·ä¾†æœ‰ç”¨ï¼‰
                const cleared1Count = getClearedLineCount(board1, cleared1);
                if (cleared1Count === 0) continue;

                // æª¢æŸ¥æ¶ˆé™¤å¾Œæ˜¯å¦è®“ç©å®¶è¦ºå¾—ã€Œå¤§æ–¹å¡Šç¾åœ¨èƒ½æ”¾äº†ã€
                const bigCanPlaceAfterDecoy = hasValidPlacement(bigPiece.s, cleared1);

                if (!bigCanPlaceAfterDecoy) continue; // æ²’æœ‰èª˜é¨™æ•ˆæœ

                // ğŸ­ é—œéµï¼šé›–ç„¶å¤§æ–¹å¡Š"çœ‹ä¼¼"èƒ½æ”¾ï¼Œä½†å¦‚æœå…ˆæ”¾æœƒå°è‡´å¾ŒçºŒç„¡è§£

                // å˜—è©¦å…ˆæ”¾èª˜é¨™è€…ï¼Œå†æ”¾å¤§æ–¹å¡Š
                const allBigPos = findAllValidPositions(bigPiece.s, cleared1);

                for (let bigPos of allBigPos) {
                    const board2 = simulatePlace(bigPiece.s, bigPos.r, bigPos.c, cleared1);
                    const cleared2 = simulateLineClear(board2);

                    // æª¢æŸ¥å‰©é¤˜çš„ otherPiece æ˜¯å¦é‚„èƒ½æ”¾
                    const canPlaceOther = hasValidPlacement(otherPiece.s, cleared2);

                    if (!canPlaceOther) {
                        // âœ… å®Œç¾é™·é˜±ï¼šèª˜é¨™è€…â†’å¤§æ–¹å¡Š æœƒå°è‡´ otherPiece ç„¡è™•å¯æ”¾
                        //console.log(`   ğŸ­ é™·é˜±è·¯å¾‘: ${decoy.name}@${toNotation(r,c)} â†’ ${bigPiece.name}@${toNotation(bigPos.r, bigPos.c)} â†’ ${otherPiece.name} ç„¡æ³•æ”¾ç½®`);
                        return true;
                    }
                }
            }
        }

        return false; // æ²’æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„é™·é˜±è·¯å¾‘
    }

    // ===== æ–¹æ³•2: é€†å‘æ§‹é€ æ³•ï¼ˆæ”¹é€²ç‰ˆï¼‰=====
    function constructChallengingPuzzle() {
        const maxAttempts = 100; // æé«˜å˜—è©¦æ¬¡æ•¸

        for (let i = 0; i < maxAttempts; i++) {
            // éš¨æ©Ÿé¸å¤§æ–¹å¡Š
            const bigPiece = getRandomBigShape();

            // æ‰¾å‡ºæ‰€æœ‰ã€Œå·®1-3æ¢ç·šå°±èƒ½æ”¾ã€çš„ä½ç½®
            const nearMisses = findNearMissPositions(bigPiece, boardState);

            if (nearMisses.length === 0) continue;

            // éš¨æ©Ÿé¸ä¸€å€‹ã€Œå·®ä¸€é»ã€çš„ä½ç½®
            const target = nearMisses[Math.floor(Math.random() * nearMisses.length)];

            // å˜—è©¦æ‰¾2å€‹å°æ–¹å¡Šä¾†æ¸…é™¤æ“‹è·¯çš„ç·š
            const solution = findTwoStepClear(target.blockingLines, boardState, bigPiece);

            if (solution) {
               // console.log(`âœ… é€†å‘æ§‹é€ æˆåŠŸ (${i+1}æ¬¡) - éœ€æ¶ˆé™¤${target.blockingLines.length}æ¢ç·š`);
                return shuffle([solution.pieceA, solution.pieceB, bigPiece]);
            }
        }

        return null;
    }

    // æ‰¾å‡ºã€Œå·®ä¸€é»å°±èƒ½æ”¾ã€çš„æ‰€æœ‰ä½ç½®
    function findNearMissPositions(bigPiece, board) {
        const nearMisses = [];

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const blockingLines = getBlockingLines(bigPiece.s, r, c, board);

                // åªè¢« 1-3 æ¢ç·šæ“‹ä½æ‰ç®—ã€Œå·®ä¸€é»ã€
                if (blockingLines.length >= 1 && blockingLines.length <= 3) {
                    nearMisses.push({
                        r, c,
                        blockingLines: blockingLines,
                        blockCount: blockingLines.length
                    });
                }
            }
        }

        // å„ªå…ˆé¸ã€Œåªè¢«1-2æ¢ç·šæ“‹ä½ã€çš„ä½ç½®
        nearMisses.sort((a, b) => a.blockCount - b.blockCount);

        return nearMisses;
    }

    // æ‰¾å‡ºæ“‹ä½å¤§æ–¹å¡Šçš„æ‰€æœ‰è¡Œ/åˆ—
    function getBlockingLines(shape, r, c, board) {
        const blockingRows = new Set();
        const blockingCols = new Set();

        shape.forEach((row, i) => {
            row.forEach((val, j) => {
                if (!val) return;

                const nr = r + i;
                const nc = c + j;

                // è¶…å‡ºé‚Šç•Œ
                if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) {
                    if (nr >= 0 && nr < 8) blockingRows.add(nr);
                    if (nc >= 0 && nc < 8) blockingCols.add(nc);
                    return;
                }

                // ç¢°åˆ°å·²å¡«å……çš„æ ¼å­
                if (board[nr][nc]) {
                    // æª¢æŸ¥é€™ä¸€è¡Œæ˜¯å¦æ¥è¿‘æ»¿ï¼ˆ>=6æ ¼å¡«å……ï¼‰
                    const rowFilled = board[nr].filter(v => v).length;
                    if (rowFilled >= 5) {
                        blockingRows.add(nr);
                    }

                    // æª¢æŸ¥é€™ä¸€åˆ—æ˜¯å¦æ¥è¿‘æ»¿
                    const colFilled = board.map(row => row[nc]).filter(v => v).length;
                    if (colFilled >= 5) {
                        blockingCols.add(nc);
                    }
                }
            });
        });

        const lines = [];
        blockingRows.forEach(r => lines.push({ type: 'row', index: r }));
        blockingCols.forEach(c => lines.push({ type: 'col', index: c }));

        return lines;
    }

    // æ‰¾å…©å€‹å°æ–¹å¡Šä¾†æ¸…é™¤æ“‹è·¯çš„ç·š
    function findTwoStepClear(blockingLines, board, bigPiece) {
        const smallShapes = allShapes.filter(s => s.s.flat().filter(v => v).length <= 3);

        // ğŸ”§ æé«˜å˜—è©¦æ¬¡æ•¸åˆ° 200
        for (let attempt = 0; attempt < 200; attempt++) {
            const shapeA = cloneShape(smallShapes[Math.floor(Math.random() * smallShapes.length)]);
            const shapeB = cloneShape(smallShapes[Math.floor(Math.random() * smallShapes.length)]);

            // å˜—è©¦æ‰€æœ‰æ”¾ç½®ä½ç½®
            for (let r1 = 0; r1 < 8; r1++) {
                for (let c1 = 0; c1 < 8; c1++) {
                    if (!canPlaceOnBoard(shapeA.s, r1, c1, board)) continue;

                    const board1 = simulatePlace(shapeA.s, r1, c1, board);
                    const cleared1 = simulateLineClear(board1);

                    // A å¿…é ˆæ¶ˆé™¤è‡³å°‘1æ¢ç·š
                    if (boardsEqual(board1, cleared1)) continue;

                    for (let r2 = 0; r2 < 8; r2++) {
                        for (let c2 = 0; c2 < 8; c2++) {
                            if (!canPlaceOnBoard(shapeB.s, r2, c2, cleared1)) continue;

                            const board2 = simulatePlace(shapeB.s, r2, c2, cleared1);
                            const cleared2 = simulateLineClear(board2);

                            // æª¢æŸ¥å¤§æ–¹å¡Šç¾åœ¨èƒ½å¦æ”¾ç½®
                            if (hasValidPlacement(bigPiece.s, cleared2)) {
                                // ğŸ”§ æ‰¾å‡ºæ‰€æœ‰å¯æ”¾ç½®ä½ç½®ï¼ˆä¸åªç¬¬ä¸€å€‹ï¼‰
                                const allBigPositions = findAllValidPositions(bigPiece.s, cleared2);

                                // ğŸ”§ å„ªå…ˆé¸æ“‡ä¸é‡ç–Šçš„ä½ç½®
                                let bigPos = null;
                                for (let pos of allBigPositions) {
                                    const overlapsWithStep1 = checkOverlap(bigPiece.s, pos.r, pos.c, shapeA.s, r1, c1);
                                    const overlapsWithStep2 = checkOverlap(bigPiece.s, pos.r, pos.c, shapeB.s, r2, c2);

                                    if (!overlapsWithStep1 && !overlapsWithStep2) {
                                        bigPos = pos;
                                        break;  // æ‰¾åˆ°ä¸é‡ç–Šçš„ä½ç½®ï¼Œç«‹å³ä½¿ç”¨
                                    }
                                }

                                // å¦‚æœæ‰€æœ‰ä½ç½®éƒ½é‡ç–Šï¼Œè·³éæ­¤è§£æ³•
                                if (!bigPos) {
                                    console.warn('âš ï¸ æ‰€æœ‰å¤§æ–¹å¡Šä½ç½®éƒ½èˆ‡å‰å…©æ­¥é‡ç–Šï¼Œè·³é');
                                    continue;
                                }

                                // è¨ˆç®—æ¶ˆé™¤è¡Œæ•¸
                                const cleared1Count = getClearedLineCount(board1, cleared1);
                                const cleared2Count = getClearedLineCount(board2, cleared2);

                                // è¨˜éŒ„ AI è§£æ³•
                                aiSolution = {
                                    pieces: [
                                        { piece: cloneShape(shapeA), name: shapeA.name },
                                        { piece: cloneShape(shapeB), name: shapeB.name },
                                        { piece: cloneShape(bigPiece), name: bigPiece.name }
                                    ],
                                    steps: [
                                        {
                                            piece: cloneShape(shapeA),
                                            pieceName: shapeA.name,
                                            position: { row: r1, col: c1 },
                                            notation: toNotation(r1, c1),
                                            clearedLines: cleared1Count
                                        },
                                        {
                                            piece: cloneShape(shapeB),
                                            pieceName: shapeB.name,
                                            position: { row: r2, col: c2 },
                                            notation: toNotation(r2, c2),
                                            clearedLines: cleared2Count
                                        },
                                        {
                                            piece: cloneShape(bigPiece),
                                            pieceName: bigPiece.name,
                                            position: { row: bigPos.r, col: bigPos.c },
                                            notation: toNotation(bigPos.r, bigPos.c),
                                            clearedLines: 0
                                        }
                                    ],
                                    foundAt: new Date().toISOString(),
                                    difficulty: 'reverse-constructed'
                                };

                               // console.log('ğŸ¤– é€†å‘æ§‹é€  AI è§£æ³•:', aiSolution.steps.map(s =>
                                //    `${s.pieceName}@${s.notation}`
                              //  ).join(' â†’ '));

                                return { pieceA: shapeA, pieceB: shapeB };
                            }
                        }
                    }
                }
            }
        }

        return null;
    }

    // ğŸ†• æ‰¾å‡ºæ‰€æœ‰å¯æ”¾ç½®ä½ç½®ï¼ˆä¸åªç¬¬ä¸€å€‹ï¼‰
    function findAllValidPositions(shape, board) {
        const positions = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (canPlaceOnBoard(shape, r, c, board)) {
                    positions.push({ r, c });
                }
            }
        }
        return positions;
    }

    // ğŸ†• æª¢æŸ¥å…©å€‹æ–¹å¡Šåœ¨æŒ‡å®šä½ç½®æ˜¯å¦é‡ç–Š
    function checkOverlap(shape1, r1, c1, shape2, r2, c2) {
        const occupied1 = new Set();

        // è¨˜éŒ„æ–¹å¡Š1ä½”æ“šçš„æ‰€æœ‰æ ¼å­
        shape1.forEach((row, i) => {
            row.forEach((val, j) => {
                if (val) {
                    occupied1.add(`${r1 + i},${c1 + j}`);
                }
            });
        });

        // æª¢æŸ¥æ–¹å¡Š2æ˜¯å¦ä½”æ“šç›¸åŒæ ¼å­
        for (let i = 0; i < shape2.length; i++) {
            for (let j = 0; j < shape2[i].length; j++) {
                if (shape2[i][j]) {
                    const key = `${r2 + i},${c2 + j}`;
                    if (occupied1.has(key)) {
                        return true;  // ç™¼ç¾é‡ç–Š
                    }
                }
            }
        }

        return false;  // æ²’æœ‰é‡ç–Š
    }

    // ===== æ–¹æ³•3: æ­£å‘æœç´¢æ³•ï¼ˆä½ åŸæœ¬çš„æ–¹æ³•å„ªåŒ–ç‰ˆï¼‰=====
    function searchChallengingPuzzle() {
        const maxAttempts = 100;

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const bigPiece = findUnplaceableBigShape();
            if (!bigPiece) continue;

            let smallPieces;
            if (attempt < 250) {
                smallPieces = getSmartSmallShapes(bigPiece, boardState);
            } else {
                smallPieces = [getRandomSmallShape(), getRandomSmallShape()];
            }

            if (canCreateSpaceFor(bigPiece, smallPieces, boardState)) {
                //console.log(`âœ… æ­£å‘æœç´¢æˆåŠŸ (${attempt + 1}æ¬¡)`);
                return shuffle([bigPiece, ...smallPieces]);
            }
        }
        return null;
    }

    // ===== æ–¹æ³•4: æ··åˆæ¨¡å¼ =====
    function hybridGeneration() {
        const base = constructChallengingPuzzle();
        if (!base) return null;

        const replaceIndex = Math.floor(Math.random() * 3);
        const alternatives = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area >= 1 && area <= 5;
        });

        for (let i = 0; i < 20; i++) {
            const newPiece = cloneShape(alternatives[Math.floor(Math.random() * alternatives.length)]);
            const testPieces = [...base];
            testPieces[replaceIndex] = newPiece;

            if (canSolveWithAnyOrder(testPieces, boardState)) {
                // æ‰¾å‡ºå®Œæ•´è§£æ³•
                const solution = findCompleteSolution(testPieces, boardState);
                if (solution) {
                    aiSolution = solution;
                    aiSolution.difficulty = 'hybrid';
                    //console.log('ğŸ¤– æ··åˆæ¨¡å¼ AI è§£æ³•:', solution.steps.map(s =>
                   //     `${s.pieceName}@${s.notation}`
                  //  ).join(' â†’ '));
                }

              //  console.log('âœ… æ··åˆæ¨¡å¼ï¼šè®Šç•°æˆåŠŸ');
                return testPieces;
            }
        }

        return base;
    }



    function tryPlaceAnywhere(shape, board) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (canPlaceOnBoard(shape, r, c, board)) {
                    const newBoard = simulatePlace(shape, r, c, board);
                    const cleared = simulateLineClear(newBoard);
                    return { board: cleared, pos: { r, c } };
                }
            }
        }
        return null;
    }

    // ===== å¿«é€Ÿé©—è­‰æ˜¯å¦å¯è§£ =====
    function canSolveWithAnyOrder(pieces, board) {
        const permutations = [
            [0, 1, 2], [0, 2, 1],
            [1, 0, 2], [1, 2, 0],
            [2, 0, 1], [2, 1, 0]
        ];

        for (let perm of permutations) {
            let testBoard = cloneBoard(board);
            let success = true;

            for (let i of perm) {
                const placed = tryPlaceAnywhere(pieces[i].s, testBoard);
                if (!placed) {
                    success = false;
                    break;
                }
                testBoard = placed.board;
            }

            if (success) return true;
        }

        return false;
    }


    function findCompleteSolution(pieces, board) {
        const permutations = [
            [0, 1, 2], [0, 2, 1],
            [1, 0, 2], [1, 2, 0],
            [2, 0, 1], [2, 1, 0]
        ];

        for (let perm of permutations) {
            const result = dfsSearch(pieces, perm, board, 0, []);
            if (result) {
                return {
                    pieces: pieces.map(p => ({ piece: cloneShape(p), name: p.name })),
                    steps: result,
                    foundAt: new Date().toISOString(),
                    difficulty: 'smart-random'
                };
            }
        }

        return null;
    }

    // ğŸ†• æ·±åº¦ä¼˜å…ˆæœç´¢
    function dfsSearch(pieces, perm, board, depth, steps) {
        // æ‰€æœ‰æ–¹å—éƒ½æ”¾å®Œäº†
        if (depth === perm.length) {
            return steps;
        }

        const pieceIdx = perm[depth];
        const piece = pieces[pieceIdx];
        const allPositions = findAllValidPositions(piece.s, board);

        // ğŸ”¥ éå†æ‰€æœ‰ä½ç½®ï¼Œä¸åªæ˜¯ç¬¬ä¸€ä¸ª
        for (let pos of allPositions) {
            const board1 = simulatePlace(piece.s, pos.r, pos.c, board);
            const cleared1 = simulateLineClear(board1);
            const clearedCount = getClearedLineCount(board1, cleared1);

            const newStep = {
                piece: cloneShape(piece),
                pieceName: piece.name,
                position: { row: pos.r, col: pos.c },
                notation: toNotation(pos.r, pos.c),
                clearedLines: clearedCount
            };

            // ğŸ”¥ é€’å½’æœç´¢å‰©ä½™æ–¹å—
            const result = dfsSearch(pieces, perm, cleared1, depth + 1, [...steps, newStep]);

            if (result) {
                return result;  // â† æ‰¾åˆ°è§£æ³•ï¼Œç«‹å³è¿”å›
            }
        }

        return null;  // â† æ‰€æœ‰ä½ç½®éƒ½è¯•è¿‡äº†ï¼Œæ²¡æ‰¾åˆ°
    }


    // ğŸ†• æ‰¾å‡ºèª˜é¨™æ–¹å¡Š
    function findDecoyPiece(bigPiece, targetLines, board, existingPieces, baseSolution) {
        const candidates = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area >= 2 && area <= 4; // ä¸­å°å‹æ–¹å¡Š
        });

        // éš¨æ©Ÿæ‰“äº‚å€™é¸
        shuffle(candidates);

        for (let candidate of candidates.slice(0, 15)) { // åªæª¢æŸ¥å‰15å€‹
            const decoy = cloneShape(candidate);

            // æª¢æŸ¥èª˜é¨™è€…æ˜¯å¦èˆ‡ç¾æœ‰æ–¹å¡Šä¸åŒ
            if (existingPieces.some(p => p.name === decoy.name)) continue;

            // æª¢æŸ¥èª˜é¨™è€…æ˜¯å¦èƒ½æ¶ˆé™¤è‡³å°‘1æ¢ç›®æ¨™è¡Œ/åˆ—
            let canClearTarget = false;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (!canPlaceOnBoard(decoy.s, r, c, board)) continue;

                    const testBoard = simulatePlace(decoy.s, r, c, board);

                    // æª¢æŸ¥æ˜¯å¦æ¶ˆé™¤ç›®æ¨™è¡Œ
                    for (let targetRow of targetLines.rows || []) {
                        if (testBoard[targetRow].every(v => v)) {
                            canClearTarget = true;
                            break;
                        }
                    }

                    // æª¢æŸ¥æ˜¯å¦æ¶ˆé™¤ç›®æ¨™åˆ—
                    for (let targetCol of targetLines.cols || []) {
                        if (testBoard.every(row => row[targetCol])) {
                            canClearTarget = true;
                            break;
                        }
                    }

                    if (canClearTarget) break;
                }
                if (canClearTarget) break;
            }

            if (canClearTarget) {
                return decoy;
            }
        }

        return null;
    }

    function generateChallengingPieces() {
        const density = getBoardDensity();

        // æ ¹æ“šå¯†åº¦é¸æ“‡ç­–ç•¥
        const strategies = getStrategiesByDensity(density);

        // æŒ‰æ¬Šé‡éš¨æ©Ÿé¸æ“‡ç­–ç•¥
        const strategy = weightedRandom(strategies);
        //console.log(`ğŸ² ä½¿ç”¨ç­–ç•¥: ${strategy.name} (å¯†åº¦${(density*100).toFixed(1)}%)`);

        const result = strategy.method();

        // å¦‚æœå¤±æ•—ï¼Œå˜—è©¦å‚™ç”¨ç­–ç•¥
        if (!result) {
            //console.log(`âš ï¸ ${strategy.name}å¤±æ•—ï¼Œå˜—è©¦å‚™ç”¨ç­–ç•¥`);
            for (let s of strategies) {
                if (s === strategy) continue;
                const backup = s.method();
                if (backup) {
                   // console.log(`âœ… å‚™ç”¨ç­–ç•¥æˆåŠŸ: ${s.name}`);
                    return backup;
                }
            }
        }

        return result;
    }

    // æ‰¾ä¸€å€‹æ”¾ä¸ä¸‹çš„å¤§æ–¹å¡Š
    function findUnplaceableBigShape() {
        const bigShapes = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area >= 5; // 5æ ¼ä»¥ä¸Š
        });

        shuffle(bigShapes);

        for(let shape of bigShapes) {
            if(!hasValidPlacement(shape.s, boardState)) {
                return cloneShape(shape);
            }
        }

        return null;
    }

    // æ‰¾åˆ°åŸæœ¬çš„ canCreateSpaceFor å‡½æ•¸ï¼Œæ•´å€‹æ›¿æ›æˆï¼š

    // æ‰¾åˆ°åŸæœ¬çš„ canCreateSpaceFor() å‡½æ•¸ï¼Œæ›¿æ›æˆé€™å€‹å„ªåŒ–ç‰ˆï¼š

    function canCreateSpaceFor(bigPiece, smallPieces, board) {
        const [piece1, piece2] = smallPieces;
        let checkedPositions = 0;
        const maxChecks = 800; // æé«˜æª¢æŸ¥ä¸Šé™ï¼ˆå› ç‚ºç¾åœ¨æœ‰æ™ºèƒ½é¸æ“‡ï¼Œæ›´å®¹æ˜“æˆåŠŸï¼‰

        // ===== å„ªåŒ–ï¼šå„ªå…ˆæª¢æŸ¥ã€Œæ“æ“ å€åŸŸã€=====
        const hotspots = findHotspots(board);

        // å…ˆæª¢æŸ¥ç†±é»å€åŸŸ
        for(let hotspot of hotspots) {
            const result = tryPlaceInArea(piece1, piece2, bigPiece, board, hotspot, maxChecks - checkedPositions);
            checkedPositions += result.checked;

            if(result.success) return true;
            if(checkedPositions > maxChecks) return false;
        }

        // å¦‚æœç†±é»å€åŸŸæ²’æ‰¾åˆ°ï¼Œå†å…¨å±€æœç´¢
        const result = tryPlaceInArea(piece1, piece2, bigPiece, board, {r: 0, c: 0, size: 8}, maxChecks - checkedPositions);
        return result.success;
    }

    // æ‰¾å‡ºã€Œæ“æ“ å€åŸŸã€ï¼ˆå„ªå…ˆåœ¨é€™äº›åœ°æ–¹å˜—è©¦ï¼‰
    function findHotspots(board) {
        const hotspots = [];

        // å°‡æ£‹ç›¤åˆ†æˆ4å€‹å€åŸŸï¼Œæ‰¾å‡ºæœ€æ“æ“ çš„
        const regions = [
            {r: 0, c: 0, size: 4},
            {r: 0, c: 4, size: 4},
            {r: 4, c: 0, size: 4},
            {r: 4, c: 4, size: 4}
        ];

        const scored = regions.map(region => {
            let density = 0;
            for(let r = region.r; r < region.r + region.size; r++) {
                for(let c = region.c; c < region.c + region.size; c++) {
                    if(board[r][c]) density++;
                }
            }
            return { ...region, density };
        });

        // æŒ‰å¯†åº¦æ’åºï¼Œå„ªå…ˆæª¢æŸ¥æœ€æ“æ“ çš„å€åŸŸ
        scored.sort((a, b) => b.density - a.density);

        return scored;
    }

    // åœ¨æŒ‡å®šå€åŸŸå˜—è©¦æ”¾ç½®
    function tryPlaceInArea(piece1, piece2, bigPiece, board, area, maxChecks) {
        let checked = 0;

        const startR1 = Math.max(0, area.r - 1);
        const endR1 = Math.min(8, area.r + area.size + 1);
        const startC1 = Math.max(0, area.c - 1);
        const endC1 = Math.min(8, area.c + area.size + 1);

        for(let r1 = startR1; r1 < endR1; r1++) {
            for(let c1 = startC1; c1 < endC1; c1++) {
                if(checked++ > maxChecks) return { success: false, checked };
                if(!canPlaceOnBoard(piece1.s, r1, c1, board)) continue;

                const board1 = simulatePlace(piece1.s, r1, c1, board);
                const cleared1 = simulateLineClear(board1);

                const cleared1Count = getClearedLineCount(board1, cleared1);
                if(cleared1Count === 0) continue;

                for(let r2 = 0; r2 < 8; r2++) {
                    for(let c2 = 0; c2 < 8; c2++) {
                        if(checked++ > maxChecks) return { success: false, checked };
                        if(!canPlaceOnBoard(piece2.s, r2, c2, cleared1)) continue;

                        const board2 = simulatePlace(piece2.s, r2, c2, cleared1);
                        const cleared2 = simulateLineClear(board2);

                        // ğŸ”§ æ‰¾å‡ºæ‰€æœ‰å¯æ”¾ç½®ä½ç½®ï¼ˆä¸åªç¬¬ä¸€å€‹ï¼‰
                        const allBigPositions = findAllValidPositions(bigPiece.s, cleared2);

                        // ğŸ”§ å„ªå…ˆé¸æ“‡ä¸é‡ç–Šçš„ä½ç½®
                        let bigPos = null;
                        for (let pos of allBigPositions) {
                            const overlapsWithStep1 = checkOverlap(bigPiece.s, pos.r, pos.c, piece1.s, r1, c1);
                            const overlapsWithStep2 = checkOverlap(bigPiece.s, pos.r, pos.c, piece2.s, r2, c2);

                            if (!overlapsWithStep1 && !overlapsWithStep2) {
                                bigPos = pos;
                                break;  // æ‰¾åˆ°ä¸é‡ç–Šçš„ä½ç½®ï¼Œç«‹å³ä½¿ç”¨
                            }
                        }

                        // å¦‚æœæ‰€æœ‰ä½ç½®éƒ½é‡ç–Šï¼Œè·³éæ­¤è§£æ³•
                        if (!bigPos) {
                            continue;
                        }

                        // è¨˜éŒ„ AI è§£æ³•
                        const cleared2Count = getClearedLineCount(board2, cleared2);
                        aiSolution = {
                            pieces: [
                                { piece: cloneShape(piece1), name: piece1.name },
                                { piece: cloneShape(piece2), name: piece2.name },
                                { piece: cloneShape(bigPiece), name: bigPiece.name }
                            ],
                            steps: [
                                {
                                    piece: cloneShape(piece1),
                                    pieceName: piece1.name,
                                    position: { row: r1, col: c1 },
                                    notation: toNotation(r1, c1),
                                    clearedLines: cleared1Count
                                },
                                {
                                    piece: cloneShape(piece2),
                                    pieceName: piece2.name,
                                    position: { row: r2, col: c2 },
                                    notation: toNotation(r2, c2),
                                    clearedLines: cleared2Count
                                },
                                {
                                    piece: cloneShape(bigPiece),
                                    pieceName: bigPiece.name,
                                    position: { row: bigPos.r, col: bigPos.c },
                                    notation: toNotation(bigPos.r, bigPos.c),
                                    clearedLines: 0
                                }
                            ],
                            foundAt: new Date().toISOString(),
                            difficulty: 'hard'
                        };

                        //console.log('ğŸ¤– æ­£å‘æœç´¢ AI è§£æ³•å·²è¨˜éŒ„:', aiSolution.steps.map(s =>
                           // `${s.pieceName}@${s.notation}`
                       // ).join(' â†’ '));

                        return { success: true, checked };
                    }
                }
            }
        }

        return { success: false, checked };
    }



    // æ–°å¢ï¼šè¨ˆç®—æ¶ˆé™¤è¡Œæ•¸
    function getClearedLineCount(boardBefore, boardAfter) {
        let count = 0;

        // æª¢æŸ¥è¡Œ
        for(let r = 0; r < 8; r++) {
            const wasFull = boardBefore[r].every(v => v);
            const nowEmpty = boardAfter[r].every(v => !v);
            if(wasFull && nowEmpty) count++;
        }

        // æª¢æŸ¥åˆ—
        for(let c = 0; c < 8; c++) {
            const wasFull = boardBefore.every(row => row[c]);
            const nowEmpty = boardAfter.every(row => !row[c]);
            if(wasFull && nowEmpty) count++;
        }

        return count;
    }



    // ===== å¿«é€Ÿä¿åº•ç”Ÿæˆç³»çµ± =====
    function generateSimplePieces() {
        const maxAttempts = 50;

        for(let attempt = 0; attempt < maxAttempts; attempt++) {
            const pieces = [
                cloneShape(allShapes[Math.floor(Math.random() * allShapes.length)]),
                cloneShape(allShapes[Math.floor(Math.random() * allShapes.length)]),
                cloneShape(allShapes[Math.floor(Math.random() * allShapes.length)])
            ];

            const solution = findCompleteSolution(pieces, boardState);
            if (solution) {
                aiSolution = solution;
                aiSolution.difficulty = 'simple';
                return pieces;
            }
        }

        // ===== å¿«é€Ÿä¿åº•:ä¸‰æ­¥ç”Ÿæˆæ³• =====
        return getFastGuaranteedPieces();
    }

    // æ–°å¢:å¿«é€Ÿä¸‰æ­¥ç”Ÿæˆæ³•
    function getFastGuaranteedPieces() {
       // console.log('ğŸš€ å•Ÿå‹•å¿«é€Ÿä¿åº•ç”Ÿæˆ...');

        // Step 1: ç”Ÿæˆä¸€å€‹èƒ½æ¶ˆé™¤è¡Œ/åˆ—çš„æ–¹å¡Š
        const piece1Result = generateLineClearingPiece(boardState);
        if (!piece1Result) {
            return getEmergencyPieces(); // ç·Šæ€¥å‚™æ¡ˆ
        }

        const piece1 = piece1Result.piece;
        const boardAfterPiece1 = piece1Result.boardAfter;
        const step1 = piece1Result.step;

        // Step 2: åœ¨æ¶ˆé™¤å¾Œçš„ç©ºé–“æ”¾ä¸€å€‹å¤§æ–¹å¡Š(æˆ–ä»»æ„å¯æ”¾æ–¹å¡Š)
        const piece2Result = generateFittingPiece(boardAfterPiece1, true);
        const piece2 = piece2Result.piece;
        const boardAfterPiece2 = piece2Result.boardAfter;
        const step2 = piece2Result.step;

        // Step 3: æ ¹æ“šå‰©é¤˜ç©ºé–“ç”Ÿæˆæœ€å¾Œä¸€å€‹æ–¹å¡Š
        const piece3Result = generateFittingPiece(boardAfterPiece2, false);
        const piece3 = piece3Result.piece;
        const step3 = piece3Result.step;

        // è¨˜éŒ„è§£æ³•
        aiSolution = {
            pieces: [piece1, piece2, piece3].map(p => ({ piece: cloneShape(p), name: p.name })),
            steps: [step1, step2, step3],
            foundAt: new Date().toISOString(),
            difficulty: 'fast-guaranteed'
        };

        //console.log('âœ… å¿«é€Ÿä¿åº•å®Œæˆ:', [piece1.name, piece2.name, piece3.name]);
        return [piece1, piece2, piece3];
    }

    // ç”Ÿæˆèƒ½æ¶ˆé™¤è¡Œ/åˆ—çš„æ–¹å¡Š
    function generateLineClearingPiece(board) {
        // æ‰¾å‡ºæœ€æ¥è¿‘å®Œæ•´çš„è¡Œ/åˆ—
        const almostFullLines = findAlmostFullLines(board);

        if (almostFullLines.rows.length === 0 && almostFullLines.cols.length === 0) {
            // å¦‚æœæ²’æœ‰æ¥è¿‘æ»¿çš„è¡Œåˆ—,éš¨ä¾¿æ‰¾ä¸€å€‹èƒ½æ”¾çš„å°æ–¹å¡Š
            return generateAnyPlaceablePiece(board);
        }

        // å˜—è©¦æ‰¾ä¸€å€‹æ–¹å¡Šä¾†å®Œæˆé€™æ¢ç·š
        const smallShapes = allShapes.filter(s => s.s.flat().filter(v => v).length <= 4);

        for (let shape of smallShapes) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (!canPlaceOnBoard(shape.s, r, c, board)) continue;

                    const testBoard = simulatePlace(shape.s, r, c, board);
                    const cleared = countClearedLines(testBoard);

                    if (cleared > 0) {
                        const finalBoard = applyLineClear(testBoard);
                        return {
                            piece: cloneShape(shape),
                            boardAfter: finalBoard,
                            step: {
                                piece: cloneShape(shape),
                                pieceName: shape.name,
                                position: { row: r, col: c },
                                notation: toNotation(r, c),
                                clearedLines: cleared
                            }
                        };
                    }
                }
            }
        }

        // å¦‚æœæ‰¾ä¸åˆ°èƒ½æ¶ˆé™¤çš„,å°±æ‰¾ä»»æ„èƒ½æ”¾çš„
        return generateAnyPlaceablePiece(board);
    }

    // æ‰¾å‡ºæ¥è¿‘æ»¿çš„è¡Œåˆ—
    function findAlmostFullLines(board) {
        const result = { rows: [], cols: [] };

        // æª¢æŸ¥è¡Œ(è‡³å°‘6æ ¼æ»¿)
        for (let r = 0; r < 8; r++) {
            const filled = board[r].filter(v => v).length;
            if (filled >= 6) {
                result.rows.push({ index: r, filled: filled });
            }
        }

        // æª¢æŸ¥åˆ—(è‡³å°‘6æ ¼æ»¿)
        for (let c = 0; c < 8; c++) {
            const filled = board.filter(row => row[c]).length;
            if (filled >= 6) {
                result.cols.push({ index: c, filled: filled });
            }
        }

        // æŒ‰æ¥è¿‘ç¨‹åº¦æ’åº
        result.rows.sort((a, b) => b.filled - a.filled);
        result.cols.sort((a, b) => b.filled - a.filled);

        return result;
    }

    // è¨ˆç®—æœƒæ¶ˆé™¤å¹¾æ¢ç·š
    function countClearedLines(board) {
        let count = 0;

        // æª¢æŸ¥è¡Œ
        for (let r = 0; r < 8; r++) {
            if (board[r].every(v => v)) count++;
        }

        // æª¢æŸ¥åˆ—
        for (let c = 0; c < 8; c++) {
            if (board.every(row => row[c])) count++;
        }

        return count;
    }

    // æ‡‰ç”¨æ¶ˆé™¤(æ¸…ç©ºæ»¿è¡Œæ»¿åˆ—)
    function applyLineClear(board) {
        const newBoard = cloneBoard(board);

        // æ¸…ç©ºæ»¿è¡Œ
        for (let r = 0; r < 8; r++) {
            if (newBoard[r].every(v => v)) {
                newBoard[r] = Array(8).fill(0);
            }
        }

        // æ¸…ç©ºæ»¿åˆ—
        for (let c = 0; c < 8; c++) {
            if (newBoard.every(row => row[c])) {
                newBoard.forEach(row => row[c] = 0);
            }
        }

        return newBoard;
    }

    // ç”Ÿæˆé©åˆç•¶å‰æ£‹ç›¤çš„æ–¹å¡Š
    function generateFittingPiece(board, preferLarge) {
        const emptyCount = board.flat().filter(v => !v).length;

        // æ ¹æ“šç©ºé–“å¤§å°é¸æ“‡å€™é¸æ–¹å¡Š
        let candidates;
        if (preferLarge && emptyCount >= 9) {
            candidates = allShapes.filter(s => s.s.flat().filter(v => v).length >= 4);
        } else if (emptyCount >= 4) {
            candidates = allShapes.filter(s => {
                const size = s.s.flat().filter(v => v).length;
                return size >= 2 && size <= 4;
            });
        } else {
            candidates = allShapes.filter(s => s.s.flat().filter(v => v).length <= 2);
        }

        // éš¨æ©Ÿå˜—è©¦å€™é¸æ–¹å¡Š
        const shuffled = candidates.sort(() => Math.random() - 0.5);

        for (let shape of shuffled) {
            const placement = tryPlaceAnywhere(shape.s, board);
            if (placement) {
                return {
                    piece: cloneShape(shape),
                    boardAfter: placement.board,
                    step: {
                        piece: cloneShape(shape),
                        pieceName: shape.name,
                        position: placement.pos,
                        notation: toNotation(placement.pos.r, placement.pos.c),
                        clearedLines: 0
                    }
                };
            }
        }

        // å¦‚æœéƒ½æ”¾ä¸ä¸‹,ç”¨æœ€å°çš„æ–¹å¡Š
        return generateAnyPlaceablePiece(board);
    }

    // ç”Ÿæˆä»»æ„èƒ½æ”¾çš„æ–¹å¡Š(æœ€å¾Œæ‰‹æ®µ)
    function generateAnyPlaceablePiece(board) {
        const tinyShapes = allShapes.filter(s => s.s.flat().filter(v => v).length <= 2);

        for (let shape of tinyShapes) {
            const placement = tryPlaceAnywhere(shape.s, board);
            if (placement) {
                return {
                    piece: cloneShape(shape),
                    boardAfter: placement.board,
                    step: {
                        piece: cloneShape(shape),
                        pieceName: shape.name,
                        position: placement.pos,
                        notation: toNotation(placement.pos.r, placement.pos.c),
                        clearedLines: 0
                    }
                };
            }
        }

        return null;
    }

    // ç·Šæ€¥å‚™æ¡ˆ:æ‰¾ä»»æ„èƒ½æ”¾çš„3å€‹æ–¹å¡Š
    function getEmergencyPieces() {
       // console.warn('âš ï¸ ä½¿ç”¨ç·Šæ€¥å‚™æ¡ˆ');

        const pieces = [];
        let testBoard = cloneBoard(boardState);
        const steps = [];

        for (let i = 0; i < 3; i++) {
            const result = generateAnyPlaceablePiece(testBoard);
            if (!result) {
                showNotification('æ£‹ç›¤å·²æ»¿ï¼ŒéŠæˆ²çµæŸï¼', 'error', 0);
                return null;
            }

            pieces.push(result.piece);
            testBoard = result.boardAfter;
            steps.push(result.step);
        }

        aiSolution = {
            pieces: pieces.map(p => ({ piece: cloneShape(p), name: p.name })),
            steps: steps,
            foundAt: new Date().toISOString(),
            difficulty: 'emergency'
        };

        return pieces;
    }



    // åœ¨ getRandomBigShape() å‡½æ•¸å¾Œé¢åŠ å…¥ï¼š

    // ===== æ™ºèƒ½å°æ–¹å¡Šé¸æ“‡ç³»çµ± =====

    // åˆ†æéœ€è¦æ¶ˆé™¤å“ªäº›è¡Œ/åˆ—æ‰èƒ½æ”¾ä¸‹å¤§æ–¹å¡Š
    function analyzeRequiredClears(bigPiece, board) {
        const lines = { rows: [], cols: [] };

        // æ‰¾å‡ºã€Œå¦‚æœæ¶ˆé™¤é€™è¡Œï¼Œå¤§æ–¹å¡Šå°±èƒ½æ”¾ã€çš„è¡Œ
        for(let r = 0; r < 8; r++) {
            const testBoard = cloneBoard(board);
            testBoard[r] = Array(8).fill(0); // æ¸…ç©ºé€™ä¸€è¡Œ

            if(hasValidPlacement(bigPiece.s, testBoard)) {
                lines.rows.push(r);
            }
        }

        // æ‰¾å‡ºã€Œå¦‚æœæ¶ˆé™¤é€™åˆ—ï¼Œå¤§æ–¹å¡Šå°±èƒ½æ”¾ã€çš„åˆ—
        for(let c = 0; c < 8; c++) {
            const testBoard = cloneBoard(board);
            testBoard.forEach(row => row[c] = 0); // æ¸…ç©ºé€™ä¸€åˆ—

            if(hasValidPlacement(bigPiece.s, testBoard)) {
                lines.cols.push(c);
            }
        }

        return lines;
    }

    // è¨ˆç®—æ–¹å¡Šçš„ã€Œæ¶ˆé™¤æ½›åŠ›ã€åˆ†æ•¸
    function calculateClearPotential(shapeObj, targetLines, board) {
        let score = 0;

        // æ¨¡æ“¬æ”¾ç½®åœ¨æ‰€æœ‰ä½ç½®ï¼Œè¨ˆç®—èƒ½è§¸ç™¼å¤šå°‘ç›®æ¨™è¡Œ/åˆ—çš„æ¶ˆé™¤
        for(let r = 0; r < 8; r++) {
            for(let c = 0; c < 8; c++) {
                if(!canPlaceOnBoard(shapeObj.s, r, c, board)) continue;

                const testBoard = simulatePlace(shapeObj.s, r, c, board);

                // æª¢æŸ¥æœƒæ¶ˆé™¤å“ªäº›ç›®æ¨™è¡Œ
                for(let targetRow of targetLines.rows) {
                    if(testBoard[targetRow].every(v => v)) {
                        score += 10; // èƒ½æ¶ˆé™¤ç›®æ¨™è¡Œï¼Œé«˜åˆ†ï¼
                    }
                }

                // æª¢æŸ¥æœƒæ¶ˆé™¤å“ªäº›ç›®æ¨™åˆ—
                for(let targetCol of targetLines.cols) {
                    if(testBoard.every(row => row[targetCol])) {
                        score += 10; // èƒ½æ¶ˆé™¤ç›®æ¨™åˆ—ï¼Œé«˜åˆ†ï¼
                    }
                }

                // é¡å¤–çå‹µï¼šèƒ½æ¶ˆé™¤ä»»ä½•è¡Œ/åˆ—éƒ½åŠ åˆ†
                for(let checkR = 0; checkR < 8; checkR++) {
                    if(testBoard[checkR].every(v => v)) score += 2;
                }
                for(let checkC = 0; checkC < 8; checkC++) {
                    if(testBoard.every(row => row[checkC])) score += 2;
                }
            }
        }

        return score;
    }

    // æ™ºèƒ½é¸æ“‡å°æ–¹å¡Š
    function getSmartSmallShapes(bigPiece, board) {
        const targetLines = analyzeRequiredClears(bigPiece, board);
        const totalLines = targetLines.rows.length + targetLines.cols.length;

        // å¿«é€Ÿå¤±æ•—
        if(totalLines > 5 || totalLines === 0) {
            return [getRandomSmallShape(), getRandomSmallShape()];
        }

        const smallShapes = allShapes.filter(s => {
            const area = s.s.flat().filter(v => v).length;
            return area <= 3;
        });

        const scored = smallShapes.map(shape => ({
            shape: shape,
            score: calculateClearPotential(shape, targetLines, board)
        }));

        scored.sort((a, b) => b.score - a.score);
        const topCandidates = scored.slice(0, Math.max(6, Math.floor(scored.length * 0.3)));

        if(topCandidates.length === 0 || topCandidates[0].score === 0) {
            return [getRandomSmallShape(), getRandomSmallShape()];
        }

        const piece1 = cloneShape(topCandidates[0].shape);
        const piece2Index = Math.floor(Math.random() * Math.min(5, topCandidates.length));
        const piece2 = cloneShape(topCandidates[piece2Index].shape);

        return [piece1, piece2];
    }




    // ===== æª¢æŸ¥éŠæˆ²çµæŸ =====
    function isGameOver() {
        const pieces = getCurrentPieces();
        const gameOver = pieces.every(piece => !hasValidPlacement(piece.s, boardState));

        // âœ… å¦‚æœåœ¨ç„¡ç›¡æ¨¡å¼ä¸”éŠæˆ²çµæŸï¼Œè§¸ç™¼ç„¡ç›¡æ¨¡å¼çµæŸ
        if (gameOver && endlessModeActive) {
            // ä½¿ç”¨ setTimeout é¿å…é˜»å¡ç•¶å‰æµç¨‹
            setTimeout(() => {
                endEndlessMode(true); // true è¡¨ç¤ºå› éŠæˆ²å¤±æ•—è€ŒçµæŸ
            }, 100);
        }

        return gameOver;
    }

    function init() {
        const boardMode = gameSettings.getBoardMode();

        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';

                let shouldFill = false;

                if (boardMode === 'random') {
                    // éš¨æ©Ÿæ¨¡å¼ - ç´„20%å¯†åº¦
                    shouldFill = Math.random() < 0.2 && (r>3 || c>3);
                } else if (boardMode === 'endgame') {
                    // æ®˜å±€æ¨¡å¼ - å…ˆéš¨æ©Ÿå¡«å…… 65%
                    shouldFill = Math.random() < 0.65;
                }
                // boardMode === 'empty' æ™‚ä¸å¡«å……ä»»ä½•æ–¹å¡Š

                if(shouldFill) {
                    boardState[r][c] = 1;
                    cell.classList.add('filled');
                    cell.style.backgroundColor = allShapes[Math.floor(Math.random()*allShapes.length)].color;
                }

                boardElement.appendChild(cell);
            }
        }

        // æ®˜å±€æ¨¡å¼ï¼šå…ˆæ¶ˆé™¤æ»¿è¡Œæ»¿åˆ—ï¼Œç„¶å¾Œç”Ÿæˆå›°é›£æ–¹å¡Š
        if (boardMode === 'endgame') {
            // æ¶ˆé™¤æ‰€æœ‰æ»¿è¡Œæ»¿åˆ—
            clearLinesOnInit();

            // ä½¿ç”¨å›°é›£æ–¹å¡Šç”Ÿæˆç­–ç•¥
            renderChallengingPieces();
        } else {
            // å…¶ä»–æ¨¡å¼ä½¿ç”¨æ­£å¸¸æ–¹å¡Šç”Ÿæˆ
            renderNewPieces();
        }
    }

    // åˆå§‹åŒ–æ™‚æ¶ˆé™¤æ»¿è¡Œæ»¿åˆ—
    function clearLinesOnInit() {
        const cells = boardElement.children;
        let cleared = false;

        do {
            cleared = false;
            const linesToClear = [];

            // æª¢æŸ¥æ»¿è¡Œ
            for(let r=0; r<8; r++) {
                let rowFull = true;
                for(let c=0; c<8; c++) {
                    if(boardState[r][c] === 0) {
                        rowFull = false;
                        break;
                    }
                }
                if(rowFull) {
                    linesToClear.push({type: 'row', index: r});
                    cleared = true;
                }
            }

            // æª¢æŸ¥æ»¿åˆ—
            for(let c=0; c<8; c++) {
                let colFull = true;
                for(let r=0; r<8; r++) {
                    if(boardState[r][c] === 0) {
                        colFull = false;
                        break;
                    }
                }
                if(colFull) {
                    linesToClear.push({type: 'col', index: c});
                    cleared = true;
                }
            }

            // æ¸…é™¤æ»¿è¡Œæ»¿åˆ—
            linesToClear.forEach(line => {
                if(line.type === 'row') {
                    for(let c=0; c<8; c++) {
                        boardState[line.index][c] = 0;
                        const cellIdx = line.index * 8 + c;
                        cells[cellIdx].classList.remove('filled');
                        cells[cellIdx].style.backgroundColor = '';
                    }
                } else {
                    for(let r=0; r<8; r++) {
                        boardState[r][line.index] = 0;
                        const cellIdx = r * 8 + line.index;
                        cells[cellIdx].classList.remove('filled');
                        cells[cellIdx].style.backgroundColor = '';
                    }
                }
            });

        } while(cleared); // æŒçºŒæ¶ˆé™¤ç›´åˆ°æ²’æœ‰æ»¿è¡Œæ»¿åˆ—
    }

    // æ®˜å±€æ¨¡å¼å°ˆç”¨ï¼šç”Ÿæˆå›°é›£æ–¹å¡Š
    function renderChallengingPieces() {
        // æ¸…ç©ºä¸Šä¸€è¼ªçš„ AI è§£æ³•
        if (typeof aiSolution !== 'undefined') {
            aiSolution = null;
        }

        // æ¸…ç©ºæœ¬å›åˆçš„ç”¨æˆ¶æ”¾ç½®è¨˜éŒ„
        window.currentRoundPlacements = [];

        // ä¿å­˜ç•¶å‰æ£‹ç›¤ç‹€æ…‹
        if (typeof boardState !== 'undefined' && boardState) {
            window.initialBoardState = boardState.map(row => [...row]);
            console.log('ğŸ’¾ å·²ä¿å­˜åˆå§‹æ£‹ç›¤ç‹€æ…‹ï¼ˆæ®˜å±€æ¨¡å¼ï¼‰');
        } else {
            window.initialBoardState = Array(8).fill(0).map(() => Array(8).fill(0));
        }

        // ä½¿ç”¨å›°é›£æ–¹å¡Šç”Ÿæˆç­–ç•¥
        let pieces = null;
        if (typeof generateChallengingPieces === 'function') {
            pieces = generateChallengingPieces();
        }

        if (!pieces && typeof generateSimplePieces === 'function') {
            console.log('âš ï¸ generateChallengingPieces å¤±æ•—ï¼Œä½¿ç”¨ä¿åº•æ–¹æ¡ˆ');
            pieces = generateSimplePieces();
        }

        if (!pieces) {
            // æœ€çµ‚ä¿åº•ï¼šéš¨æ©Ÿç”Ÿæˆ3å€‹æ–¹å¡Š
            pieces = [];
            for(let i=0; i<3; i++) {
                const shape = allShapes[Math.floor(Math.random() * allShapes.length)];
                pieces.push({
                    s: shape.shape,
                    color: shape.color
                });
            }
        }

        // ä¿å­˜æœ¬å›åˆçš„æ–¹å¡Šçµ„åˆ
        window.currentRoundPieces = pieces.map(p => ({
            shape: JSON.parse(JSON.stringify(p.s)),
            color: p.color
        }));
        console.log('ğŸ’¾ å·²ä¿å­˜æœ¬å›åˆæ–¹å¡Šï¼ˆæ®˜å±€æ¨¡å¼ï¼‰:', window.currentRoundPieces);

        // æ¸²æŸ“æ–¹å¡Š
        if (typeof piecesArea !== 'undefined') {
            piecesArea.innerHTML = '';
            pieces.forEach((shapeObj, i) => {
                const container = document.createElement('div');
                container.className = 'piece-container';
                container.dataset.shape = JSON.stringify(shapeObj.s);

                const width = shapeObj.s[0].length * 45;
                const height = shapeObj.s.length * 45;
                container.style.width = width + 'px';
                container.style.height = height + 'px';

                shapeObj.s.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if(cell) {
                            const div = document.createElement('div');
                            div.className = 'p-cell filled';
                            div.style.backgroundColor = shapeObj.color;
                            div.style.left = (c * 45) + 'px';
                            div.style.top = (r * 45) + 'px';
                            container.appendChild(div);
                        }
                    });
                });

                // è¨­ç½®æ‹–æ›³äº‹ä»¶
                if (typeof setupPieceDragging === 'function') {
                    setupPieceDragging(container, shapeObj);
                }

                piecesArea.appendChild(container);
            });
        }
    }

    function renderNewPieces() {
        // æ¸…ç©ºä¸Šä¸€è¼ªçš„ AI è§£æ³•
        aiSolution = null;

        // âœ… æ¸…ç©ºæœ¬å›åˆçš„ç”¨æˆ·æ”¾ç½®è®°å½•
        window.currentRoundPlacements = [];

        // âœ…âœ… ä¿å­˜ç•¶å‰æ£‹ç›¤ç‹€æ…‹
        if (typeof boardState !== 'undefined' && boardState) {
            window.initialBoardState = boardState.map(row => [...row]);
            console.log('ğŸ’¾ å·²ä¿å­˜åˆå§‹æ£‹ç›¤ç‹€æ…‹');
        } else {
            console.warn('âš ï¸ æ‰¾ä¸åˆ° boardState');
            window.initialBoardState = Array(8).fill(0).map(() => Array(8).fill(0));
        }

        const density = getBoardDensity();
        let pieces = null;

        console.log(`ğŸ“Š ç•¶å‰æ£‹ç›¤å¯†åº¦: ${(density * 100).toFixed(1)}%`);

        // ===== ä½¿ç”¨æ–°çš„ç­–ç•¥é¸æ“‡ç³»çµ± =====
        pieces = generateChallengingPieces();

        if (!pieces) {
            console.log('âš ï¸ æ‰€æœ‰ç­–ç•¥å¤±æ•—ï¼Œä½¿ç”¨ä¿åº•æ–¹æ¡ˆ');
            pieces = generateSimplePieces();
        }

        // âœ…âœ… ä¿å­˜æœ¬å›åˆçš„æ–¹å¡Šçµ„åˆ
        window.currentRoundPieces = pieces.map(p => ({
            shape: JSON.parse(JSON.stringify(p.s)),
            color: p.color
        }));
        console.log('ğŸ’¾ å·²ä¿å­˜æœ¬å›åˆæ–¹å¡Š:', window.currentRoundPieces);

        // ===== æ¸²æŸ“æ–¹å¡Šï¼ˆæ–°ç‰ˆæŒ‡é‡äº‹ä»¶ï¼‰=====
        piecesArea.innerHTML = '';
        pieces.forEach((shapeObj, i) => {
            const container = document.createElement('div');
            container.className = 'piece-container';
            // âŒ ç§»é™¤ container.draggable = true;

            // âœ… æŠŠå½¢ç‹€è³‡æ–™å­˜é€² dataset
            container.dataset.shape = JSON.stringify(shapeObj.s);

            const width = shapeObj.s[0].length * 45;
            const height = shapeObj.s.length * 45;
            container.style.width = width + 'px';
            container.style.height = height + 'px';

            shapeObj.s.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if(cell) {
                        const div = document.createElement('div');
                        div.className = 'p-cell filled';
                        div.style.backgroundColor = shapeObj.color;
                        div.style.left = (c * 45) + 'px';
                        div.style.top = (r * 45) + 'px';
                        // âŒ ç§»é™¤ div.onmousedown
                        container.appendChild(div);
                    }
                });
            });

            // âœ… ä½¿ç”¨æ–°çš„æŒ‡é‡äº‹ä»¶ç³»çµ±
            setupPieceDragging(container, shapeObj);

            piecesArea.appendChild(container);
        });
    }

    function setupPieceDragging(container, shapeObj) {
        let clone = null;
        let savedOffsetX = 0;
        let savedOffsetY = 0;

        container.addEventListener('pointerdown', (e) => {
            // âœ… æ–°å¢:é˜»æ­¢é è¨­è¡Œç‚ºå’Œäº‹ä»¶å†’æ³¡
            e.preventDefault();
            e.stopPropagation();

            // âœ… åªåœ¨è§¸æ§è¨­å‚™ä¸Šç¦æ­¢æ»¾å‹•
            const isTouchDevice = e.pointerType === 'touch' || 'ontouchstart' in window;
            if (isTouchDevice) {
                document.body.style.overflow = 'hidden';
                document.body.style.touchAction = 'none';
            }

            if (isDragging) return;

            isDragging = true;
            draggedPiece = container;
            currentShape = shapeObj;

            const startPos = {
                x: e.touches ? e.touches[0].clientX : e.clientX,
                y: e.touches ? e.touches[0].clientY : e.clientY
            };

            const containerRect = container.getBoundingClientRect();

// è¨ˆç®—æ‰‹æŒ‡åœ¨åŸå§‹å®¹å™¨å…§çš„åç§»
            savedOffsetX = startPos.x - containerRect.left;
            savedOffsetY = startPos.y - containerRect.top;

// âœ… ä½¿ç”¨è¼ƒå°çš„é‚Šç¢ºä¿æ ¼å­æ˜¯æ­£æ–¹å½¢
            const actualCellSize = Math.min(
                containerRect.width / shapeObj.s[0].length,
                containerRect.height / shapeObj.s.length
            );

// é‡æ–°å»ºç«‹ cloneï¼ˆä¸ä½¿ç”¨ piece-container é¡åˆ¥ä»¥é¿å… CSS scale å¹²æ“¾ï¼‰
            clone = document.createElement('div');
            clone.style.position = 'fixed';
            clone.style.pointerEvents = 'none';
            clone.style.zIndex = '1000';
            clone.style.opacity = '0.9';
            clone.style.margin = '0';
            clone.style.padding = '0';
            clone.style.transform = 'none';
// âœ… ä½¿ç”¨æ–¹å¡Šé™£åˆ—çš„å¯¦éš›å¤§å°
            clone.style.width = (shapeObj.s[0].length * actualCellSize) + 'px';
            clone.style.height = (shapeObj.s.length * actualCellSize) + 'px';

            // é‡æ–°ç¹ªè£½æ ¼å­
            shapeObj.s.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'p-cell filled';
                        cellDiv.style.backgroundColor = shapeObj.color;
                        cellDiv.style.position = 'absolute';
                        cellDiv.style.width = actualCellSize + 'px';
                        cellDiv.style.height = actualCellSize + 'px';
                        cellDiv.style.left = (c * actualCellSize) + 'px';
                        cellDiv.style.top = (r * actualCellSize) + 'px';
                        cellDiv.style.borderRadius = '3px';
                        cellDiv.style.boxShadow = 'inset 2px 2px 0 rgba(255,255,255,0.4), inset -2px -2px 0 rgba(0,0,0,0.2)';
                        clone.appendChild(cellDiv);
                    }
                });
            });

            document.body.appendChild(clone);

            // å®šä½å‡½æ•¸
            const positionClone = (fingerX, fingerY) => {
                clone.style.left = (fingerX - savedOffsetX) + 'px';
                clone.style.top = (fingerY - savedOffsetY) + 'px';
            };

            // åˆå§‹å®šä½
            positionClone(startPos.x, startPos.y);

            container.style.opacity = '0.3';

            // âœ… ç”¨æ¯”ä¾‹è¨ˆç®— dragOffset
            dragOffset.c = (savedOffsetX / containerRect.width) * shapeObj.s[0].length;
            dragOffset.r = (savedOffsetY / containerRect.height) * shapeObj.s.length;

            const moveHandler = (e) => {
                if (!clone) return;

                const currentPos = {
                    x: e.touches ? e.touches[0].clientX : e.clientX,
                    y: e.touches ? e.touches[0].clientY : e.clientY
                };

                positionClone(currentPos.x, currentPos.y);
                updateGhostPreview({ clientX: currentPos.x, clientY: currentPos.y });
            };

            const upHandler = (e) => {
                window.removeEventListener('pointermove', moveHandler);
                window.removeEventListener('pointerup', upHandler);
                window.removeEventListener('touchmove', moveHandler);
                window.removeEventListener('touchend', upHandler);

                // âœ… æ¢å¾©æ»¾å‹•
                const isTouchDevice = e.pointerType === 'touch' || 'ontouchstart' in window;
                if (isTouchDevice) {
                    document.body.style.overflow = '';
                    document.body.style.touchAction = '';
                }

                if (clone) {
                    clone.remove();
                    clone = null;
                }

                const finalPos = e.changedTouches ?
                    { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY } :
                    { x: e.clientX, y: e.clientY };

                const placed = tryPlacePiece({ clientX: finalPos.x, clientY: finalPos.y });

                if (placed) {
                    draggedPiece.remove();
                    setTimeout(() => {
                        if (piecesArea.children.length === 0) {
                            renderNewPieces();
                        } else if (isGameOver()) {
                            showGameOverPanel();
                        }
                    }, 100);
                } else {
                    draggedPiece.style.opacity = '1';
                }

                clearGhost();
                draggedPiece = null;
                isDragging = false;
            };

            window.addEventListener('pointermove', moveHandler, { passive: false });
            window.addEventListener('pointerup', upHandler);
            window.addEventListener('touchmove', moveHandler, { passive: false });
            window.addEventListener('touchend', upHandler);
        });
    }


    function updateGhostPreview(e) {
        const boardRect = boardElement.getBoundingClientRect();
        const cellSize = 47;

        const mouseX = e.clientX - boardRect.left;
        const mouseY = e.clientY - boardRect.top;

        const baseC = Math.floor(mouseX / cellSize - dragOffset.c + 0.5);
        const baseR = Math.floor(mouseY / cellSize - dragOffset.r + 0.5);

        clearGhost();

        // âœ… å˜—è©¦å‘¨åœä½ç½®æ‰¾åˆ°æœ€è¿‘çš„å¯æ”¾ç½®é»
        const tryPositions = [
            [baseR, baseC],
            [baseR - 1, baseC],
            [baseR + 1, baseC],
            [baseR, baseC - 1],
            [baseR, baseC + 1]
        ];

        for (const [r, c] of tryPositions) {
            if (r >= -1 && r <= 8 && c >= -1 && c <= 8) {
                if (canPlace(currentShape.s, r, c)) {
                    showGhost(currentShape.s, r, c);
                    return; // æ‰¾åˆ°å°±åœæ­¢
                }
            }
        }
    }

    function tryPlacePiece(e) {
        const boardRect = boardElement.getBoundingClientRect();
        const cellSize = 47;

        const mouseX = e.clientX - boardRect.left;
        const mouseY = e.clientY - boardRect.top;

        // åŸå§‹è¨ˆç®—ä½ç½®
        const baseC = Math.floor(mouseX / cellSize - dragOffset.c + 0.5);
        const baseR = Math.floor(mouseY / cellSize - dragOffset.r + 0.5);

        // âœ… å˜—è©¦å‘¨åœ9å€‹ä½ç½® (ä¸­å¿ƒ + ä¸Šä¸‹å·¦å³ + å››å€‹å°è§’)
        const tryPositions = [
            [baseR, baseC],           // ä¸­å¿ƒ
            [baseR - 1, baseC],       // ä¸Š
            [baseR + 1, baseC],       // ä¸‹
            [baseR, baseC - 1],       // å·¦
            [baseR, baseC + 1],       // å³
            [baseR - 1, baseC - 1],   // å·¦ä¸Š
            [baseR - 1, baseC + 1],   // å³ä¸Š
            [baseR + 1, baseC - 1],   // å·¦ä¸‹
            [baseR + 1, baseC + 1]    // å³ä¸‹
        ];

        // æŒ‰ç…§å„ªå…ˆç´šå˜—è©¦æ”¾ç½®
        for (const [r, c] of tryPositions) {
            if (canPlace(currentShape.s, r, c)) {
                const currentPieces = getCurrentPieces();
                place(currentShape, r, c, currentPieces);

                // è¨˜éŒ„æ”¾ç½®
                if (!window.currentRoundPlacements) {
                    window.currentRoundPlacements = [];
                }
                window.currentRoundPlacements.push({
                    shape: JSON.parse(JSON.stringify(currentShape.s)),
                    r: r,
                    c: c
                });

                const beforeClear = getBoardFullLines();
                checkAndClear();
                const afterClear = getBoardFullLines();

                if (beforeClear === afterClear) {
                    streakCount = 0;
                }

                return true;
            }
        }

        return false;
    }

    // ===== 3. ä¿®æ”¹ showGameOverPanelï¼Œä½¿ç”¨æ‰€æœ‰æ”¾ç½®è®°å½• =====
    function showGameOverPanel() {
        const currentScore = parseInt(document.getElementById('score').innerText);

        // âœ… ç²å–æœ¬å›åˆæ‰€æœ‰æ”¾ç½®ä½ç½®
        const userPlacements = window.currentRoundPlacements || [];

        console.log('==================== æ­»å±€åˆ†æé–‹å§‹ ====================');
        console.log('ğŸ“Š ç©å®¶æ”¾ç½®è¨˜éŒ„æ•¸é‡:', userPlacements.length);
        console.log('ğŸ“Š ç©å®¶æ”¾ç½®è©³æƒ…:', userPlacements);
        console.log('ğŸ“Š åˆå§‹æ£‹ç›¤ç‹€æ…‹:', window.initialBoardState);
        console.log('ğŸ“Š æœ¬å›åˆæ–¹å¡Š:', window.currentRoundPieces);

        // âœ…âœ… ä½¿ç”¨æ–°å‡½æ•¸åˆ†æåˆå§‹ç‹€æ…‹çš„æ­£ç¢ºè§£æ³•
        const correctSolution = performInitialStateAIAnalysis(
            window.initialBoardState,
            window.currentRoundPieces
        );

        console.log('ğŸ“Š AI è§£æ³•çµæœ:', correctSolution);
        console.log('==================================================');

        // åˆ›å»ºé®ç½©å±‚
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
    `;

        // åˆ›å»ºé¢æ¿
        const panel = document.createElement('div');
        panel.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 1200px;
        max-height: 85vh;
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        z-index: 10001;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    `;

        // æ ‡é¢˜åŒº
        const header = document.createElement('div');
        header.style.cssText = `
        padding: 24px;
        background: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
        color: white;
        text-align: center;
    `;
        header.innerHTML = `
        <h2 style="margin: 0 0 8px 0; font-size: 28px;">ğŸ® éŠæˆ²çµæŸ</h2>
        <p style="margin: 0; font-size: 20px; font-weight: bold;">æœ¬æ¬¡æœ€é«˜åˆ†æ•¸ï¼š${currentScore}</p>
    `;

        // å†…å®¹åŒº
        const content = document.createElement('div');
        content.style.cssText = `
        padding: 24px;
        overflow-y: auto;
        flex: 1;
    `;

        if (!correctSolution || correctSolution.length === 0) {
            // ç„¡è§£æƒ…æ³
            content.innerHTML = `
        <div style="text-align: center; padding: 40px; font-size: 18px; color: #666;">
            <p style="margin-bottom: 16px; font-size: 22px;">ğŸ˜” æœ¬è¼ªç‚ºå¿…æ­»å±€</p>
            <p style="color: #999;">é€™çµ„æ–¹å¡Šèˆ‡æ£‹ç›¤ç‹€æ…‹ç„¡è«–å¦‚ä½•æ“ºæ”¾éƒ½ç„¡æ³•ç¹¼çºŒéŠæˆ²</p>
        </div>
    `;
        } else {
            // æœ‰è§£æƒ…å†µ - æ˜¾ç¤ºæ­£ç¡®è§£æ³•å’Œé”™è¯¯ä½ç½®
            const errorExplanation = analyzeUserError(userPlacements, correctSolution);

            const explanationDiv = document.createElement('div');
            explanationDiv.style.cssText = `
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 16px;
            margin-bottom: 20px;
            border-radius: 8px;
        `;
            explanationDiv.innerHTML = `
            <h3 style="margin: 0 0 12px 0; color: #e65100; font-size: 18px;">âŒ éŒ¯èª¤åˆ†æ</h3>
            <p style="margin: 0; font-size: 16px; line-height: 1.6; color: #333;">${errorExplanation}</p>
        `;

            content.appendChild(explanationDiv);

            // æ˜¾ç¤ºæ­£ç¡®è§£æ³•
            const solutionTitle = document.createElement('h3');
            solutionTitle.style.cssText = `
            margin: 0 0 16px 0;
            font-size: 20px;
            color: #333;
            text-align: center;
        `;
            solutionTitle.textContent = 'âœ… æ­£ç¢ºæ“ºæ”¾æ–¹å¼';

            const stepsContainer = document.createElement('div');
            stepsContainer.style.cssText = `
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        `;

            correctSolution.forEach((step, index) => {
                const stepDiv = createGameOverStepVisualization(step, index, correctSolution, userPlacements);
                stepsContainer.appendChild(stepDiv);
            });

            content.appendChild(solutionTitle);
            content.appendChild(stepsContainer);
        }

        // æŒ‰é’®åŒº
        const footer = document.createElement('div');
        footer.style.cssText = `
        padding: 20px 24px;
        background: #f5f5f5;
        display: flex;
        justify-content: center;
        gap: 16px;
    `;

        // âœ… é‡ä¾†æ­¤å›åˆæŒ‰éˆ•
        const retryBtn = document.createElement('button');
        retryBtn.textContent = 'ğŸ”„ é‡ä¾†æ­¤å›åˆ';
        retryBtn.style.cssText = `
    padding: 12px 32px;
    background: linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(66, 165, 245, 0.4);
`;
        retryBtn.onclick = () => {
            panel.remove();
            overlay.remove();
            retryCurrentRound();
        };

// å®Œå…¨é‡æ–°é–‹å§‹æŒ‰éˆ•
        const restartBtn = document.createElement('button');
        restartBtn.textContent = 'ğŸ†• é‡æ–°é–‹å§‹';
        restartBtn.style.cssText = `
    padding: 12px 32px;
    background: linear-gradient(135deg, #66bb6a 0%, #43a047 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(102, 187, 106, 0.4);
`;
        restartBtn.onclick = () => {
            panel.remove();
            overlay.remove();
            location.reload();
        };

        footer.appendChild(retryBtn);      // é‡ä¾†æ­¤å›åˆ
        footer.appendChild(restartBtn);    // å®Œå…¨é‡æ–°é–‹å§‹

        panel.appendChild(header);
        panel.appendChild(content);
        panel.appendChild(footer);

        document.body.appendChild(overlay);
        document.body.appendChild(panel);
    }

    // ===== 4. ä¿®æ”¹é”™è¯¯åˆ†æå‡½æ•°ï¼Œåˆ†ææ‰€æœ‰æ”¾ç½®ä½ç½® =====
    function analyzeUserError(userPlacements, correctSolution) {
        if (!userPlacements || userPlacements.length === 0) {
            return 'ç”±æ–¼æ–¹å¡Šæ“ºæ”¾ä½ç½®ä¸ç•¶ï¼Œå°è‡´å‰©é¤˜æ–¹å¡Šç„¡æ³•æ‰¾åˆ°åˆé©çš„ä½ç½®ï¼Œé€ æˆæ­»å±€ã€‚';
        }

        // æ‰¾å‡ºç¬¬ä¸€ä¸ªé”™è¯¯çš„æ”¾ç½®
        for (let i = 0; i < userPlacements.length && i < correctSolution.length; i++) {
            const userPlace = userPlacements[i];
            const correctPlace = correctSolution[i];

            // æ£€æŸ¥å½¢çŠ¶æ˜¯å¦ç›¸åŒ
            const sameShape = JSON.stringify(userPlace.shape) === JSON.stringify(correctPlace.shape);

            if (sameShape) {
                // å½¢çŠ¶ç›¸åŒï¼Œæ£€æŸ¥ä½ç½®æ˜¯å¦ç›¸åŒ
                if (userPlace.r !== correctPlace.r || userPlace.c !== correctPlace.c) {
                    const wrongShapeName = matchShapeName(userPlace.shape);
                    const wrongPos = `ç¬¬ ${userPlace.r + 1} è¡Œï¼Œç¬¬ ${userPlace.c + 1} åˆ—`;
                    const correctPos = `ç¬¬ ${correctPlace.r + 1} è¡Œï¼Œç¬¬ ${correctPlace.c + 1} åˆ—`;

                    return `ç”±æ–¼æ‚¨åœ¨æ­¥é©Ÿ ${i + 1} å°‡ <strong>${wrongShapeName}</strong> æ–¹å¡Šæ”¾åœ¨ <strong>${wrongPos}</strong>ï¼Œè€Œéæ­£ç¢ºä½ç½® <strong>${correctPos}</strong>ï¼Œå°è‡´ç„¡æ³•åŠæ™‚æ¶ˆé™¤ç©ºé–“çµ¦å¾ŒçºŒæ–¹å¡Šæ”¾ç½®ï¼Œé€ æˆæ­»å±€ã€‚`;
                }
            } else {
                // å½¢çŠ¶ä¸åŒï¼Œè¯´æ˜é¡ºåºé”™äº†
                const userShapeName = matchShapeName(userPlace.shape);
                const correctShapeName = matchShapeName(correctPlace.shape);

                return `ç”±æ–¼æ‚¨åœ¨æ­¥é©Ÿ ${i + 1} æ”¾ç½®äº† <strong>${userShapeName}</strong> æ–¹å¡Šï¼Œä½†æ­£ç¢ºåšæ³•æ‡‰è©²å…ˆæ”¾ç½® <strong>${correctShapeName}</strong> æ–¹å¡Šï¼Œå°è‡´å¾ŒçºŒæ–¹å¡Šç„¡æ³•æ­£ç¢ºæ”¾ç½®ï¼Œé€ æˆæ­»å±€ã€‚`;
            }
        }

        // å¦‚æœéƒ½åŒ¹é…ï¼Œå¯èƒ½æ˜¯æœ€åä¸€ä¸ªæ–¹å—çš„é—®é¢˜
        const lastUserPlace = userPlacements[userPlacements.length - 1];
        const wrongShapeName = matchShapeName(lastUserPlace.shape);
        const wrongPos = `ç¬¬ ${lastUserPlace.r + 1} è¡Œï¼Œç¬¬ ${lastUserPlace.c + 1} åˆ—`;

        return `ç”±æ–¼æ‚¨å°‡ <strong>${wrongShapeName}</strong> æ–¹å¡Šæ”¾åœ¨ <strong>${wrongPos}</strong> ä½ç½®ä¸ç•¶ï¼Œä½”ç”¨äº†é—œéµç©ºé–“ï¼Œå°è‡´å‰©é¤˜æ–¹å¡Šç„¡æ³•æ”¾ç½®ï¼Œé€ æˆæ­»å±€ã€‚`;
    }


    function retryCurrentRound() {
        // âœ… æŒçºŒæ‚”æ­¥ï¼Œç›´åˆ°æ¢å¾©åˆ°æœ‰3å€‹æ–¹å¡Šçš„ç‹€æ…‹
        while (moveHistory.length > 0) {
            const lastMove = moveHistory[moveHistory.length - 1];

            // æª¢æŸ¥é€™ä¸€æ­¥ä¹‹å‰æ˜¯å¦æœ‰3å€‹æ–¹å¡Š
            if (lastMove.piecesBefore && lastMove.piecesBefore.length === 3) {
                // æ‰¾åˆ°äº†ï¼åŸ·è¡Œæœ€å¾Œä¸€æ¬¡æ‚”æ­¥
                undoMove();
                console.log('âœ… å·²æ¢å¾©åˆ°æœ¬å›åˆé–‹å§‹ï¼ˆ3å€‹æ–¹å¡Šï¼‰');
                break;
            } else {
                // é‚„æ²’æ‰¾åˆ°ï¼Œç¹¼çºŒå¾€å›æ‚”
                undoMove();
            }
        }

        // å¦‚æœ moveHistory å·²ç¶“ç©ºäº†ä½†é‚„æ²’æ‰¾åˆ°3å€‹æ–¹å¡Šçš„ç‹€æ…‹
        if (moveHistory.length === 0) {
            console.warn('âš ï¸ ç„¡æ³•æ‰¾åˆ°æœ¬å›åˆé–‹å§‹ç‹€æ…‹');
            // é‡æ–°ç”Ÿæˆæ–¹å¡Šï¼ˆä¿åº•æ–¹æ¡ˆï¼‰
            if (window.currentRoundPieces && window.currentRoundPieces.length > 0) {
                renderSavedPieces();
            } else {
                renderNewPieces();
            }
        }

        // åˆ†æ•¸æ­¸é›¶ï¼ˆå› ç‚ºè¦é‡ä¾†æ­¤å›åˆï¼‰
        score = 0;
        document.getElementById('score').innerText = score;

        // âœ… å¦‚æœåœ¨ç„¡ç›¡æ¨¡å¼ï¼Œé€€å‡ºç„¡ç›¡æ¨¡å¼
        if (endlessModeActive) {
            endlessModeActive = false;
            endlessModeScore = 0;
            if (endlessModeTimer) {
                clearInterval(endlessModeTimer);
                endlessModeTimer = null;
            }
            const endlessUI = document.getElementById('endlessModeUI');
            if (endlessUI) {
                endlessUI.style.display = 'none';
            }
        }

        // âœ… æ¸…ç©ºé€£æ“Šè¨ˆæ•¸
        streakCount = 0;
        lastMoveCleared = false;

        console.log('ğŸ”„ é‡ä¾†æ­¤å›åˆå®Œæˆ');
    }

    // è¼”åŠ©å‡½æ•¸ï¼šæ¸²æŸ“å·²ä¿å­˜çš„æ–¹å¡Š
    function renderSavedPieces() {
        piecesArea.innerHTML = '';
        window.currentRoundPieces.forEach((pieceData, index) => {
            const container = document.createElement('div');
            container.className = 'piece-container';
            container.dataset.index = index;

            const shapeObj = {
                s: JSON.parse(JSON.stringify(pieceData.shape)),
                color: pieceData.color
            };

            const width = shapeObj.s[0].length * 45;
            const height = shapeObj.s.length * 45;
            container.style.width = width + 'px';
            container.style.height = height + 'px';

            shapeObj.s.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if(cell) {
                        const div = document.createElement('div');
                        div.className = 'p-cell filled';
                        div.style.backgroundColor = shapeObj.color;
                        div.style.left = (c * 45) + 'px';
                        div.style.top = (r * 45) + 'px';
                        container.appendChild(div);
                    }
                });
            });

            setupPieceDragging(container, shapeObj);
            piecesArea.appendChild(container);
        });
    }

    // ===== 5. ä¿®æ”¹æ£‹ç›˜å¯è§†åŒ–å‡½æ•°ï¼Œæ ‡è®°æ‰€æœ‰é”™è¯¯ä½ç½® =====
    function createGameOverBoardVisualization(currentStep, stepIndex, allSteps, userPlacements) {
        const boardDiv = document.createElement('div');
        boardDiv.style.cssText = `
        display: grid;
        grid-template-columns: repeat(8, 35px);
        grid-template-rows: repeat(8, 35px);
        gap: 2px;
        background: #ddd;
        padding: 4px;
        border-radius: 8px;
    `;

        const board = Array(8).fill(0).map(() => Array(8).fill(0));
        const boardColors = Array(8).fill(0).map(() => Array(8).fill(null));
        const errorCells = new Set(); // è¨˜éŒ„ç”¨æˆ¶éŒ¯èª¤æ”¾ç½®çš„æ ¼å­

        // âœ… 1. å…ˆåŠ è¼‰åˆå§‹æ£‹ç›¤ç‹€æ…‹ï¼ˆå…¨éƒ¨é»ƒè‰²ï¼‰
        if (window.initialBoardState) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (window.initialBoardState[r][c]) {
                        board[r][c] = 0.5; // 0.5 ä»£è¡¨åˆå§‹æ–¹å¡Š
                        boardColors[r][c] = '#ffd54f'; // é»ƒè‰²
                    }
                }
            }
        }

        // âœ… 2. æ¨™è¨˜ã€Œåˆ°ç•¶å‰æ­¥é©Ÿç‚ºæ­¢ã€æ‰€æœ‰çš„éŒ¯èª¤ä½ç½®ï¼ˆç´¯ç©é¡¯ç¤ºï¼‰
        if (userPlacements && userPlacements.length > 0) {
            // åªéæ­·åˆ°ã€Œç”¨æˆ¶å¯¦éš›æ”¾ç½®çš„æ­¥é©Ÿæ•¸ã€
            const maxStep = Math.min(stepIndex, userPlacements.length - 1);

            for (let i = 0; i <= maxStep; i++) {
                const userPlace = userPlacements[i];

                // â† åŠ ä¸Šé€™å€‹æª¢æŸ¥ï¼
                if (!userPlace) continue;

                const correctPlace = i < allSteps.length ? allSteps[i] : null;

                // æª¢æŸ¥æ˜¯å¦æ”¾éŒ¯ä½ç½®
                let isWrong = false;
                if (correctPlace) {
                    const sameShape = JSON.stringify(userPlace.shape) === JSON.stringify(correctPlace.shape);
                    if (!sameShape || userPlace.r !== correctPlace.r || userPlace.c !== correctPlace.c) {
                        isWrong = true;
                    }
                } else {
                    isWrong = true;
                }

                // å¦‚æœæ”¾éŒ¯äº†ï¼Œæ¨™è¨˜é€™äº›æ ¼å­
                if (isWrong) {
                    for (let r = 0; r < userPlace.shape.length; r++) {
                        for (let c = 0; c < userPlace.shape[0].length; c++) {
                            if (userPlace.shape[r][c]) {
                                const br = userPlace.r + r;
                                const bc = userPlace.c + c;
                                if (br >= 0 && br < 8 && bc >= 0 && bc < 8) {
                                    errorCells.add(`${br},${bc}`);
                                }
                            }
                        }
                    }
                }
            }
        }

        // âœ… 3. å®šç¾©æ¯å€‹æ­¥é©Ÿçš„å›ºå®šé¡è‰²ï¼ˆç¶ ã€ç´«ã€è—ï¼‰
        const stepColors = ['#66bb6a', '#ab47bc', '#42a5f5']; // ç¶ ã€ç´«ã€è—

        // âœ… 4. åŠ è¼‰æ­£ç¢ºè§£æ³•çš„æ­¥é©Ÿæ–¹å¡Š
        for (let i = 0; i <= stepIndex; i++) {
            const step = allSteps[i];
            const stepColor = stepColors[i % 3];

            // æ”¾ç½®æ–¹å¡Š
            for (let r = 0; r < step.shape.length; r++) {
                for (let c = 0; c < step.shape[0].length; c++) {
                    if (step.shape[r][c]) {
                        const br = step.r + r;
                        const bc = step.c + c;
                        board[br][bc] = 1; // 1 ä»£è¡¨æ­£ç¢ºè§£æ³•æ–¹å¡Š
                        boardColors[br][bc] = stepColor;
                    }
                }
            }

            // å¦‚æœä¸æ˜¯ç•¶å‰æ­¥é©Ÿï¼Œè¦æ¨¡æ“¬æ¶ˆé™¤
            if (i < stepIndex) {
                // æ¶ˆé™¤æ»¿è¡Œ
                for (let r = 0; r < 8; r++) {
                    if (board[r].every(cell => cell !== 0)) {
                        board[r].fill(0);
                        boardColors[r].fill(null);
                    }
                }

                // æ¶ˆé™¤æ»¿åˆ—
                for (let c = 0; c < 8; c++) {
                    let isFull = true;
                    for (let r = 0; r < 8; r++) {
                        if (board[r][c] === 0) {
                            isFull = false;
                            break;
                        }
                    }
                    if (isFull) {
                        for (let r = 0; r < 8; r++) {
                            board[r][c] = 0;
                            boardColors[r][c] = null;
                        }
                    }
                }
            }
        }

        // âœ… 5. æª¢æŸ¥ç•¶å‰æ­¥é©Ÿå¯æ¶ˆé™¤çš„è¡Œå’Œåˆ—ï¼ˆåªæ¨™è¨˜æ­£ç¢ºè§£æ³•èƒ½æ¶ˆé™¤çš„ï¼‰
        const clearableLines = new Set();
        for (let r = 0; r < 8; r++) {
            if (board[r].every(cell => cell !== 0)) {
                clearableLines.add(`row-${r}`);
            }
        }
        for (let c = 0; c < 8; c++) {
            let isFull = true;
            for (let r = 0; r < 8; r++) {
                if (board[r][c] === 0) {
                    isFull = false;
                    break;
                }
            }
            if (isFull) {
                clearableLines.add(`col-${c}`);
            }
        }

        // âœ… 6. ç¹ªè£½æ£‹ç›¤
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const cell = document.createElement('div');
                cell.style.cssText = `
                width: 35px;
                height: 35px;
                border-radius: 4px;
                position: relative;
            `;

                const isRowClearable = clearableLines.has(`row-${r}`);
                const isColClearable = clearableLines.has(`col-${c}`);
                const isError = errorCells.has(`${r},${c}`);

                if (board[r][c] === 1) {
                    // æ­£ç¢ºè§£æ³•æ–¹å¡Šï¼ˆç¶ /ç´«/è—ï¼‰
                    cell.style.background = boardColors[r][c];

                    // å¦‚æœæ˜¯å¯æ¶ˆé™¤çš„è¡Œåˆ—ï¼ŒåŠ é»‘æ¡†
                    if (isRowClearable || isColClearable) {
                        cell.style.boxShadow = 'inset 0 0 0 3px #000000';
                    }
                } else if (board[r][c] === 0.5) {
                    // åˆå§‹æ£‹ç›¤æ–¹å¡Šï¼ˆé»ƒè‰²ï¼‰
                    cell.style.background = '#ffd54f';
                    cell.style.opacity = '0.8';

                    // å¦‚æœæ˜¯å¯æ¶ˆé™¤çš„è¡Œåˆ—ï¼ŒåŠ é»‘æ¡†
                    if (isRowClearable || isColClearable) {
                        cell.style.boxShadow = 'inset 0 0 0 3px #000000';
                    }
                } else {
                    // ç©ºæ ¼
                    cell.style.background = '#e8eaf6';
                }

                // âœ… å¦‚æœæ˜¯éŒ¯èª¤ä½ç½®ï¼ŒåŠ ç´…æ¡†ï¼ˆè¦†è“‹é»‘æ¡†ï¼‰
                if (isError) {
                    cell.style.boxShadow = 'inset 0 0 0 3px #ef5350';
                    // å¦‚æœç©ºæ ¼è¢«æ¨™è¨˜ç‚ºéŒ¯èª¤ï¼Œæ”¹èƒŒæ™¯è‰²
                    if (board[r][c] === 0) {
                        cell.style.background = '#ffebee';
                    }
                }

                boardDiv.appendChild(cell);
            }
        }

        return boardDiv;
    }

    // ===== 6. å‰µå»ºæ­¥é©Ÿè¦–è¦ºåŒ–ï¼ˆåŒ…å«æ£‹ç›¤ï¼‰ =====
    function createGameOverStepVisualization(step, stepIndex, allSteps, userPlacements) {
        const stepDiv = document.createElement('div');
        stepDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 16px;
        background: #f5f5f5;
        border-radius: 12px;
        min-width: 300px;
    `;

        // æ­¥é©Ÿæ¨™é¡Œ
        const stepTitle = document.createElement('div');
        stepTitle.style.cssText = `
        font-size: 16px;
        font-weight: bold;
        color: #333;
        margin-bottom: 8px;
    `;
        const shapeName = matchShapeName(step.shape);
        stepTitle.textContent = `æ­¥é©Ÿ ${stepIndex + 1}: ${shapeName}`;

        // ä½ç½®è³‡è¨Š
        const positionInfo = document.createElement('div');
        positionInfo.style.cssText = `
        font-size: 14px;
        color: #666;
        margin-bottom: 8px;
    `;
        positionInfo.textContent = `ä½ç½®: ç¬¬ ${step.r + 1} è¡Œï¼Œç¬¬ ${step.c + 1} åˆ—`;

        // æª¢æŸ¥æ˜¯å¦æ˜¯éŒ¯èª¤æ­¥é©Ÿ
        let isWrongStep = false;
        if (userPlacements && userPlacements[stepIndex]) {
            const userPlace = userPlacements[stepIndex];
            const sameShape = JSON.stringify(userPlace.shape) === JSON.stringify(step.shape);
            if (!sameShape || userPlace.r !== step.r || userPlace.c !== step.c) {
                isWrongStep = true;
            }
        }

        // å¦‚æœæ˜¯éŒ¯èª¤æ­¥é©Ÿï¼Œæ·»åŠ è­¦å‘Šæ¨™è¨˜
        if (isWrongStep) {
            const errorLabel = document.createElement('div');
            errorLabel.style.cssText = `
            background: #ef5350;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 4px;
        `;
            errorLabel.textContent = 'âŒ æ‚¨åœ¨æ­¤æ­¥é©Ÿå‡ºéŒ¯';
            stepDiv.appendChild(errorLabel);
        }

        stepDiv.appendChild(stepTitle);
        stepDiv.appendChild(positionInfo);

        // âœ… èª¿ç”¨æ£‹ç›¤è¦–è¦ºåŒ–å‡½æ•¸
        const boardVis = createGameOverBoardVisualization(step, stepIndex, allSteps, userPlacements);
        stepDiv.appendChild(boardVis);

        // æ–¹å¡Šé è¦½
        const piecePreview = document.createElement('div');
        piecePreview.style.cssText = `
        display: grid;
        grid-template-columns: repeat(${step.shape[0].length}, 20px);
        grid-template-rows: repeat(${step.shape.length}, 20px);
        gap: 2px;
        margin-top: 8px;
    `;

        step.shape.forEach(row => {
            row.forEach(cell => {
                const cellDiv = document.createElement('div');
                cellDiv.style.cssText = `
                width: 20px;
                height: 20px;
                border-radius: 3px;
                background: ${cell ? '#66bb6a' : 'transparent'};
            `;
                piecePreview.appendChild(cellDiv);
            });
        });

        stepDiv.appendChild(piecePreview);

        return stepDiv;
    }

    // ===== æ–°å‡½æ•¸ï¼šä½¿ç”¨åˆå§‹ç‹€æ…‹åˆ†ææ­£ç¢ºè§£æ³• =====
    function performInitialStateAIAnalysis(initialBoardState, savedPieces) {
        console.log('=== åˆå§‹ç‹€æ…‹ AI åˆ†æé–‹å§‹ ===');
        console.log('ğŸ“Š ä½¿ç”¨å›åˆé–‹å§‹æ™‚çš„æ£‹ç›¤:', initialBoardState);
        console.log('ğŸ“Š ä½¿ç”¨å›åˆé–‹å§‹æ™‚çš„æ–¹å¡Š:', savedPieces);

        if (!initialBoardState || !savedPieces || savedPieces.length === 0) {
            console.error("âŒ ç¼ºå°‘åˆå§‹ç‹€æ…‹è³‡æ–™ï¼");
            return null;
        }

        // è½‰æ› savedPieces æ ¼å¼ä»¥ç¬¦åˆåˆ†æéœ€æ±‚
        const currentPieces = savedPieces.map((p, idx) => ({
            id: 'initial-piece-' + idx,
            shape: p.shape,
            color: p.color
        }));

        console.log('âœ… è½‰æ›å¾Œçš„æ–¹å¡Š:', currentPieces);

        // ===== è¼”åŠ©å‡½æ•¸ =====
        function canPlaceOnBoard(shape, row, col, board) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const br = row + r;
                        const bc = col + c;
                        if (br >= 8 || bc >= 8 || board[br][bc] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function simulatePlace(shape, row, col, board) {
            const newBoard = board.map(r => [...r]);
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        newBoard[row + r][col + c] = 1;
                    }
                }
            }
            return newBoard;
        }

        // ===== æ­£ç¢ºçš„å®Œæ•´æ¶ˆé™¤é‚è¼¯ =====
        function simulateLineClear(board) {
            let currentBoard = cloneBoard(board);
            let iteration = 0;
            const maxIterations = 20;

            while (iteration < maxIterations) {
                iteration++;

                const rowsToClear = [];
                const colsToClear = [];

                for (let r = 0; r < 8; r++) {
                    if (currentBoard[r].every(v => v)) {
                        rowsToClear.push(r);
                    }
                }

                for (let c = 0; c < 8; c++) {
                    if (currentBoard.every(row => row[c])) {
                        colsToClear.push(c);
                    }
                }

                if (rowsToClear.length === 0 && colsToClear.length === 0) {
                    break;
                }

                const newBoard = [];

                for (let r = 0; r < 8; r++) {
                    newBoard[r] = [];
                    for (let c = 0; c < 8; c++) {
                        if (rowsToClear.includes(r) || colsToClear.includes(c)) {
                            newBoard[r][c] = 0;
                        } else {
                            newBoard[r][c] = currentBoard[r][c];
                        }
                    }
                }

                currentBoard = newBoard;
            }

            if (iteration >= maxIterations) {
                console.warn('âš ï¸ æ¶ˆé™¤å¾ªç’°é”åˆ°ä¸Šé™ï¼Œå¯èƒ½å­˜åœ¨é‚è¼¯å•é¡Œ');
            }

            return currentBoard;
        }

        // æ’åˆ—çµ„åˆ
        const permutations = (arr) => {
            if (arr.length <= 1) return [arr];
            let res = [];
            for (let i = 0; i < arr.length; i++) {
                let rest = permutations(arr.slice(0, i).concat(arr.slice(i + 1)));
                rest.forEach(r => res.push([arr[i], ...r]));
            }
            return res;
        };

        // DFS æœå°‹
        function solve(board, pieces, steps = []) {
            if (pieces.length === 0) return steps;

            const p = pieces[0];
            const rows = p.shape.length;
            const cols = p.shape[0].length;

            for (let r = 0; r <= 8 - rows; r++) {
                for (let c = 0; c <= 8 - cols; c++) {
                    if (canPlaceOnBoard(p.shape, r, c, board)) {
                        let nextBoard = simulatePlace(p.shape, r, c, board);
                        nextBoard = simulateLineClear(nextBoard);

                        const result = solve(nextBoard, pieces.slice(1), [
                            ...steps,
                            {
                                r: r,
                                c: c,
                                shape: p.shape,
                                color: p.color,
                                piece: {s: p.shape},
                                position: {row: r, col: c},
                                pieceName: `æ–¹å¡Š${steps.length + 1}`,
                                notation: `(${r},${c})`
                            }
                        ]);
                        if (result) return result;
                    }
                }
            }
            return null;
        }

        // é–‹å§‹åˆ†æ - åªç”¨çª®èˆ‰æ³•
        console.log('ğŸ” é–‹å§‹çª®èˆ‰ï¼Œå…±', permutations(currentPieces).length, 'ç¨®æ’åˆ—');
        let finalSteps = null;
        const allOrders = permutations(currentPieces);

        for (let i = 0; i < allOrders.length; i++) {
            console.log(`å˜—è©¦ç¬¬ ${i+1}/${allOrders.length} ç¨®æ’åˆ—`);
            finalSteps = solve(initialBoardState, allOrders[i]);
            if (finalSteps) {
                console.log('âœ… æ‰¾åˆ°å®Œç¾è§£æ³•!');
                break;
            }
        }

        // âœ… å¦‚æœæ²’æ‰¾åˆ°è§£æ³•ï¼Œç›´æ¥è¿”å› nullï¼ˆè¡¨ç¤ºç„¡è§£ï¼‰
        if (!finalSteps || finalSteps.length === 0) {
            console.log('âŒ çª®èˆ‰æ‰€æœ‰æ’åˆ—å¾Œç„¡è§£');
            finalSteps = null;
        }

        console.log('=== åˆå§‹ç‹€æ…‹ AI åˆ†æå®Œæˆ ===');
        console.log('æœ€çµ‚è§£æ³•:', finalSteps);

        return finalSteps;
    }


    // è¼”åŠ©å‡½æ•¸ï¼šè¨ˆç®—ç•¶å‰æœ‰å¤šå°‘è¡Œåˆ—æ˜¯æ»¿çš„
    function getBoardFullLines() {
        let count = 0;
        for(let i=0; i<8; i++) {
            if(boardState[i].every(v => v)) count++;
            if(boardState.map(row => row[i]).every(v => v)) count++;
        }
        return count;
    }

    // æ‰¾åˆ°åŸæœ¬çš„ canPlace å‡½æ•¸ï¼Œæ”¹æˆï¼š

    function canPlace(shape, r, c) {
        return canPlaceOnBoard(shape, r, c, boardState);
    }

    function showGhost(shape, r, c) {
        shape.forEach((row, i) => row.forEach((val, j) => {
            if(val) boardElement.children[(r+i)*8+(c+j)].classList.add('ghost');
        }));
    }

    function clearGhost() {
        Array.from(boardElement.children).forEach(el => el.classList.remove('ghost'));
    }

    function place(shapeObj, r, c, currentPieces) {
        // è¨˜éŒ„æ”¾ç½®å‰çš„ç‹€æ…‹ï¼ˆåŒ…å«å¾…é¸æ–¹å¡Šï¼‰
        recordMove(shapeObj.name, r, c, shapeObj.s, 0, currentPieces);

        shapeObj.s.forEach((row, i) => row.forEach((val, j) => {
            if(val) {
                boardState[r+i][c+j] = 1;
                const cell = boardElement.children[(r+i)*8+(c+j)];
                cell.classList.add('filled');
                cell.style.backgroundColor = shapeObj.color;
            }
        }));
    }

    function checkAndClear() {
        let rs = [], cs = [];
        for(let i=0; i<8; i++) {
            if(boardState[i].every(v => v)) rs.push(i);
            if(boardState.map(row => row[i]).every(v => v)) cs.push(i);
        }

        const clearedCount = rs.length + cs.length;

        rs.forEach(r => {
            boardState[r] = Array(8).fill(0);
            for(let c=0; c<8; c++) resetCell(r, c);
        });
        cs.forEach(c => {
            for(let r=0; r<8; r++) {
                boardState[r][c] = 0;
                resetCell(r, c);
            }
        });

        // ä½¿ç”¨æ–°çš„è¨ˆåˆ†ç³»çµ±
        const earnedPoints = calculateScore(clearedCount);
        const currentScore = parseInt(document.getElementById('score').innerText);
        document.getElementById('score').innerText = currentScore + earnedPoints;

        // é¡¯ç¤ºç²å¾—çš„åˆ†æ•¸ï¼ˆå¯é¸ï¼Œå¯ä»¥ä¸åŠ ï¼‰
        if (earnedPoints > 0 && clearedCount > 0) {
            showScorePopup(earnedPoints, clearedCount);
        }

        // æ›´æ–°æœ€å¾Œä¸€ç­†è¨˜éŒ„çš„æ¶ˆé™¤è¡Œæ•¸å’Œå¾—åˆ†
        if (moveHistory.length > 0) {
            moveHistory[moveHistory.length - 1].clearedLines = clearedCount;
            moveHistory[moveHistory.length - 1].earnedPoints = earnedPoints;
        }
    }

    // ===== å¯é¸ï¼šé¡¯ç¤ºç²å¾—åˆ†æ•¸çš„å½ˆå‡ºæ•ˆæœ =====
    function showScorePopup(points, lines) {
        const popup = document.createElement('div');
        const comboText = lines > 1 ? ` COMBO x${lines}!` : '';
        const streakText = streakCount > 1 ? ` ğŸ”¥${streakCount} STREAK` : '';
        popup.textContent = `+${points}${comboText}${streakText}`;
        popup.style.cssText = `
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 36px;
        font-weight: bold;
        color: #FFD700;
        text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        pointer-events: none;
        z-index: 9999;
        animation: scorePopup 1.2s ease-out forwards;
    `;
        document.body.appendChild(popup);

        setTimeout(() => popup.remove(), 1200);
    }

    // === æ­·å²è¨˜éŒ„ç³»çµ± ===
    let moveHistory = []; // å„²å­˜æ¯ä¸€æ­¥çš„æ“ä½œè¨˜éŒ„

    // è¨˜éŒ„æ¯ä¸€æ­¥æ“ä½œï¼ˆåŒ…å«ç•¶å‰çš„ä¸‰å€‹å¾…é¸æ–¹å¡Šï¼‰
    function recordMove(shapeName, row, col, shapeData, clearedLines, currentPieces) {
        const boardSnapshot = boardState.map(row => [...row]); // æ·±æ‹·è²æ£‹ç›¤ç‹€æ…‹

        // è¨˜éŒ„ç•¶å‰æ£‹ç›¤ä¸Šæ¯å€‹æ ¼å­çš„é¡è‰²
        const colorSnapshot = [];
        Array.from(boardElement.children).forEach((cell, idx) => {
            colorSnapshot[idx] = cell.style.backgroundColor || null;
        });

        moveHistory.push({
            shapeName,
            row,
            col,
            shapeData,
            clearedLines,
            boardBefore: boardSnapshot,
            colorBefore: colorSnapshot,
            piecesBefore: currentPieces, // ä¿å­˜ç•¶æ™‚çš„ä¸‰å€‹æ–¹å¡Š
            score: parseInt(document.getElementById('score').innerText)
        });
    }

    // ç²å–ç•¶å‰å¾…é¸æ–¹å¡Šçš„è³‡æ–™
    function getCurrentPieces() {
        const pieces = [];
        Array.from(piecesArea.children).forEach(container => {
            // å¾å®¹å™¨ä¸­æå–æ–¹å¡Šè³‡è¨Š
            const cells = Array.from(container.children).filter(el => el.className.includes('p-cell'));
            const width = parseInt(container.style.width) / 45;
            const height = parseInt(container.style.height) / 45;

            const shape = [];
            for (let r = 0; r < height; r++) {
                shape[r] = [];
                for (let c = 0; c < width; c++) {
                    const cell = cells.find(el =>
                        parseInt(el.style.top) === r * 45 &&
                        parseInt(el.style.left) === c * 45
                    );
                    shape[r][c] = cell ? 1 : 0;
                }
            }

            const color = cells[0]?.style.backgroundColor || '#81c784';

            // æ ¹æ“šå½¢ç‹€æ‰¾åˆ°å°æ‡‰çš„æ–¹å¡Šåç¨±
            const shapeObj = allShapes.find(s =>
                JSON.stringify(s.s) === JSON.stringify(shape)
            );

            pieces.push({
                s: shape,
                color: color,
                name: shapeObj ? shapeObj.name : 'æœªçŸ¥æ–¹å¡Š'
            });
        });
        return pieces;
    }

    // æ¢å¾©å¾…é¸æ–¹å¡Š
    function restorePieces(pieces) {
        piecesArea.innerHTML = '';

        pieces.forEach((shapeObj, i) => {
            const container = document.createElement('div');
            container.className = 'piece-container';
            // âŒ ç§»é™¤ container.draggable = true;

            container.dataset.shape = JSON.stringify(shapeObj.s);

            // è¨ˆç®—æ–¹å¡Šçš„å¯¦éš›å°ºå¯¸
            const width = shapeObj.s[0].length * 45;
            const height = shapeObj.s.length * 45;
            container.style.width = width + 'px';
            container.style.height = height + 'px';

            shapeObj.s.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if(cell) {
                        const div = document.createElement('div');
                        div.className = 'p-cell filled';
                        div.style.backgroundColor = shapeObj.color;
                        div.style.left = (c * 45) + 'px';
                        div.style.top = (r * 45) + 'px';
                        // âŒ ç§»é™¤ div.onmousedown
                        container.appendChild(div);
                    }
                });
            });

            // âœ… ä½¿ç”¨æ–°çš„æ‹–æ›³ç³»çµ±
            setupPieceDragging(container, shapeObj);

            piecesArea.appendChild(container);
        });
    }

    // æ‚”æ­¥åŠŸèƒ½
    function undoMove() {
        if (moveHistory.length === 0) {
            showNotification('æ²’æœ‰å¯ä»¥æ‚”æ­¥çš„æ“ä½œï¼', 'warning');
            return;
        }

        const lastMove = moveHistory.pop();

        // æ¢å¾©æ£‹ç›¤ç‹€æ…‹
        boardState = lastMove.boardBefore.map(row => [...row]);

        // âœ… åŒæ™‚æ›´æ–° initialBoardStateï¼ˆé‡è¦ï¼ï¼‰
        window.initialBoardState = boardState.map(row => [...row]);
        console.log('ğŸ’¾ æ‚”æ­¥å¾Œå·²æ›´æ–°åˆå§‹æ£‹ç›¤ç‹€æ…‹');

        // é‡æ–°æ¸²æŸ“æ£‹ç›¤ï¼ˆåŒ…å«é¡è‰²ï¼‰
        Array.from(boardElement.children).forEach((cell, idx) => {
            const r = Math.floor(idx / 8);
            const c = idx % 8;
            if (boardState[r][c]) {
                cell.classList.add('filled');
                cell.style.backgroundColor = lastMove.colorBefore[idx] || '#81c784';
            } else {
                cell.classList.remove('filled');
                cell.style.backgroundColor = '';
            }
        });

        // æ¢å¾©åˆ†æ•¸
        document.getElementById('score').innerText = lastMove.score;

        // æ¢å¾©å¾…é¸æ–¹å¡Š
        restorePieces(lastMove.piecesBefore);

        // âœ… æ›´æ–°æ–¹å¡Šè³‡æ–™
        window.currentRoundPieces = lastMove.piecesBefore.map(p => ({
            shape: JSON.parse(JSON.stringify(p.s)),
            color: p.color
        }));

        // âœ… æ¸…ç©ºæœ¬å›åˆçš„æ”¾ç½®è¨˜éŒ„ï¼ˆå› ç‚ºæ‚”æ­¥äº†ï¼‰
        window.currentRoundPlacements = [];
    }

    // åº§æ¨™è½‰æ›å‡½æ•¸
    function toNotation(row, col) {
        const colLetter = String.fromCharCode(65 + col); // 0=A, 1=B...
        const rowNumber = row + 1; // 0=1, 1=2...
        return `${colLetter}${rowNumber}`;
    }

    // é¡¯ç¤ºæ£‹è­œ
    function showNotationDialog() {
        // ç§»é™¤èˆŠçš„å°è©±æ¡†
        const oldDialog = document.getElementById('notation-dialog');
        if (oldDialog) {
            oldDialog.remove();
            const oldOverlay = document.getElementById('notation-overlay'); // â† åŠ é€™è¡Œ
            if (oldOverlay) oldOverlay.remove(); // â† åŠ é€™è¡Œ
            return null;
        }

        const dialog = document.createElement('div');
        dialog.id = 'notation-dialog';
        dialog.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 1000;
    max-width: 500px;
    max-height: 70vh;
    overflow-y: auto;
`;

        let notationText = '<h2 style="margin-top: 0; color: #333;">ğŸ“ æ”¾ç½®è¨˜éŒ„</h2>';

        if (moveHistory.length === 0) {
            notationText += '<p style="color: #666;">ç›®å‰é‚„æ²’æœ‰ä»»ä½•æ“ä½œè¨˜éŒ„</p>';
        } else {
            notationText += '<ol style="line-height: 1.8; color: #333;">';
            moveHistory.forEach((move, idx) => {
                const coord = toNotation(move.row, move.col);
                const scoreInfo = move.clearedLines > 0 ? ` (+${move.clearedLines * 100}åˆ†)` : '';
                notationText += `<li><strong>${move.shapeName}</strong> @ ${coord}${scoreInfo}</li>`;
            });
            notationText += '</ol>';
        }

        // æ·»åŠ èƒŒæ™¯é®ç½©
        const overlay = document.createElement('div');
        overlay.id = 'notation-overlay'; // â† åŠ  ID
        overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 999;
`;
        overlay.onclick = () => {
            dialog.remove();
            overlay.remove();
        };

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'é—œé–‰';
        closeBtn.style.cssText = `
    margin-top: 20px;
    padding: 10px 20px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
`;
        closeBtn.onclick = () => {
            dialog.remove();
            overlay.remove(); // â† åŠ é€™è¡Œï¼
        };

        dialog.innerHTML = notationText;
        dialog.appendChild(closeBtn);

        document.body.appendChild(overlay);
        document.body.appendChild(dialog);

        return dialog;
    }

    function closeNotationDialog() {
        const dialog = document.getElementById('notation-dialog');
        const overlay = document.getElementById('notation-overlay');

        if (dialog) {
            dialog.remove();
        }
        if (overlay) {
            overlay.remove();
        }
    }

    // å‰µå»ºæ‚”æ­¥æŒ‰éˆ•
    function addUndoButton() {
        const scoreDiv = document.getElementById('score');
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
    `;

        const undoButton = document.createElement('button');
        undoButton.textContent = 'â†¶ æ‚”æ­¥';
        undoButton.style.cssText = `
        padding: 12px 20px;
        background-color: #ff9800;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
    `;

        undoButton.addEventListener('click', undoMove);

        buttonContainer.appendChild(undoButton);
        scoreDiv.parentNode.insertBefore(buttonContainer, scoreDiv.nextSibling);

        return undoButton;
    }

    // å‰µå»ºè¨˜è­œæŒ‰éˆ•
    function addNotationButton() {
        const undoButton = document.querySelector('button');
        const buttonContainer = undoButton.parentElement;

        const notationButton = document.createElement('button');
        notationButton.textContent = 'ğŸ“ æ”¾ç½®è¨˜éŒ„';
        notationButton.style.cssText = `
        padding: 12px 20px;
        background-color: #2196F3;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
    `;

        let notationInstance = null;

        notationButton.addEventListener('click', function() {
            if (!notationInstance) {
                notationInstance = showNotationDialog();
                if (notationInstance) {
                    notationButton.textContent = 'ğŸ“ é—œé–‰è¨˜è­œ';
                    notationButton.style.backgroundColor = '#dc3545';
                }

                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList') {
                            mutation.removedNodes.forEach(function(node) {
                                if (node && node.id === 'notation-dialog') {
                                    notationInstance = null;
                                    notationButton.textContent = 'ğŸ“ æ”¾ç½®è¨˜éŒ„';
                                    notationButton.style.backgroundColor = '#2196F3';
                                    observer.disconnect();
                                }
                            });
                        }
                    });
                });
                observer.observe(document.body, { childList: true });
            } else {
                closeNotationDialog();
            }
        });

        buttonContainer.appendChild(notationButton);

        return {
            button: notationButton,
            getCurrentInstance: () => notationInstance
        };
    }


    // ========== å…¨åŸŸ AI è®Šæ•¸ ==========
    let aiModeActive = false;
    let aiInterval = null;

    let aiOperationFlag = false;  // ğŸ†• AI æ“ä½œæ¨™è¨˜






    function performSilentAIAnalysis() {
        console.log('=== éœé»˜ AI åˆ†æé–‹å§‹ ===');

        // 1. æ‰¾åˆ°æ–¹å¡Šå®¹å™¨ï¼ˆèˆ‡ addAIAnalysisButton å®Œå…¨ç›¸åŒï¼‰
        let piecesArea = document.getElementById('pieces-area') ||
            document.querySelector('.pieces-area') ||
            document.querySelector('[class*="piece"]')?.parentElement;

        if (!piecesArea) {
            console.error("æ‰¾ä¸åˆ°æ–¹å¡Šå€åŸŸï¼");
            return null;
        }

        // 2. æŠ“å–å¯ç”¨æ–¹å¡Šï¼ˆèˆ‡ addAIAnalysisButton å®Œå…¨ç›¸åŒï¼‰
        const currentPieces = [];

        for (let child of piecesArea.children) {
            const isVisible = child.style.visibility !== 'hidden' &&
                child.style.display !== 'none' &&
                child.offsetParent !== null;

            if (!isVisible) continue;

            let shape = null;

            // å¾ dataset.shape å–å¾—
            if (child.dataset?.shape) {
                try {
                    const parsed = JSON.parse(child.dataset.shape);
                    shape = parsed.s || parsed.shape || parsed;
                } catch (e) {
                    console.warn('JSON è§£æå¤±æ•—:', e);
                }
            }

            // å¾è¦–è¦ºåæ¨å½¢ç‹€
            if (!shape) {
                const cells = child.querySelectorAll('.piece-cell, [class*="cell"]');
                if (cells.length > 0) {
                    const positions = Array.from(cells).map(cell => {
                        const rect = cell.getBoundingClientRect();
                        return {x: rect.left, y: rect.top, cell};
                    });

                    const minX = Math.min(...positions.map(p => p.x));
                    const minY = Math.min(...positions.map(p => p.y));
                    const cellSize = positions[0]?.cell.offsetWidth || 45;

                    const coords = positions.map(p => ({
                        r: Math.round((p.y - minY) / cellSize),
                        c: Math.round((p.x - minX) / cellSize)
                    }));

                    const maxR = Math.max(...coords.map(p => p.r));
                    const maxC = Math.max(...coords.map(p => p.c));
                    shape = Array(maxR + 1).fill(0).map(() => Array(maxC + 1).fill(0));
                    coords.forEach(({r, c}) => shape[r][c] = 1);
                }
            }

            if (shape && shape.length > 0) {
                currentPieces.push({
                    id: child.id || 'piece-' + currentPieces.length,
                    shape: shape,
                    element: child
                });
                console.log('æ‰¾åˆ°æ–¹å¡Š:', shape);
            }
        }

        console.log('ç¸½å…±æ‰¾åˆ°', currentPieces.length, 'å€‹æ–¹å¡Š');

        if (currentPieces.length === 0) {
            console.error("ç›®å‰æ²’æœ‰å¯åˆ†æçš„æ–¹å¡Šï¼");
            return null;
        }

        // 3. è¼”åŠ©å‡½æ•¸ï¼ˆèˆ‡ addAIAnalysisButton å®Œå…¨ç›¸åŒï¼‰
        function canPlaceOnBoard(shape, row, col, board) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const br = row + r;
                        const bc = col + c;
                        if (br >= 8 || bc >= 8 || board[br][bc] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function simulatePlace(shape, row, col, board) {
            const newBoard = board.map(r => [...r]);
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        newBoard[row + r][col + c] = 1;
                    }
                }
            }
            return newBoard;
        }

        function simulateLineClear(board) {
            const newBoard = board.map(r => [...r]);

            const rowsToClear = [];
            const colsToClear = [];

            // âœ… æ”¹æˆè·Ÿ checkAndClear ä¸€æ¨£çš„æª¢æŸ¥æ–¹å¼
            for (let r = 0; r < 8; r++) {
                if (newBoard[r].every(v => v)) {  // â† æ”¹é€™è£¡
                    rowsToClear.push(r);
                }
            }

            for (let c = 0; c < 8; c++) {
                // âœ… ä¹Ÿæ”¹æˆè·Ÿ checkAndClear ä¸€æ¨£
                if (newBoard.map(row => row[c]).every(v => v)) {  // â† æ”¹é€™è£¡
                    colsToClear.push(c);
                }
            }

            // æ¸…é™¤é‚è¼¯ä¿æŒä¸è®Š
            rowsToClear.forEach(r => {
                newBoard[r].fill(0);
            });

            colsToClear.forEach(c => {
                for (let r = 0; r < 8; r++) {
                    newBoard[r][c] = 0;
                }
            });

            return newBoard;
        }

        // 4. æ’åˆ—çµ„åˆï¼ˆèˆ‡ addAIAnalysisButton å®Œå…¨ç›¸åŒï¼‰
        const permutations = (arr) => {
            if (arr.length <= 1) return [arr];
            let res = [];
            for (let i = 0; i < arr.length; i++) {
                let rest = permutations(arr.slice(0, i).concat(arr.slice(i + 1)));
                rest.forEach(r => res.push([arr[i], ...r]));
            }
            return res;
        };

        // 5. DFS æœå°‹ï¼ˆèˆ‡ addAIAnalysisButton å®Œå…¨ç›¸åŒï¼‰
        function solve(board, pieces, steps = []) {
            if (pieces.length === 0) return steps;

            const p = pieces[0];
            const rows = p.shape.length;
            const cols = p.shape[0].length;

            for (let r = 0; r <= 8 - rows; r++) {
                for (let c = 0; c <= 8 - cols; c++) {
                    if (canPlaceOnBoard(p.shape, r, c, board)) {
                        let nextBoard = simulatePlace(p.shape, r, c, board);
                        nextBoard = simulateLineClear(nextBoard);

                        const result = solve(nextBoard, pieces.slice(1), [
                            ...steps,
                            {
                                r: r,
                                c: c,
                                shape: p.shape,
                                piece: {s: p.shape},  // åŠ å…¥ piece.s æ ¼å¼
                                position: {row: r, col: c},
                                pieceName: `æ–¹å¡Š${steps.length + 1}`,
                                notation: `(${r},${c})`
                            }
                        ]);
                        if (result) return result;
                    }
                }
            }
            return null;
        }

        // 6. é–‹å§‹åˆ†æï¼ˆèˆ‡ addAIAnalysisButton å®Œå…¨ç›¸åŒï¼‰
        console.log('é–‹å§‹çª®èˆ‰,å…±', permutations(currentPieces).length, 'ç¨®æ’åˆ—');
        let finalSteps = null;
        const allOrders = permutations(currentPieces);

        for (let i = 0; i < allOrders.length; i++) {
            console.log(`å˜—è©¦ç¬¬ ${i+1}/${allOrders.length} ç¨®æ’åˆ—`);
            finalSteps = solve(boardState, allOrders[i]);
            if (finalSteps) {
                console.log('âœ… æ‰¾åˆ°è§£æ³•!');
                break;
            }
        }

        if (!finalSteps || finalSteps.length === 0) {
            console.log('âŒ ç„¡æ³•æ”¾ä¸‹æ‰€æœ‰æ–¹å¡Š');
            // æ”¹ç‚ºè¿”å›éƒ¨åˆ†è§£ï¼ˆè²ªå¿ƒç­–ç•¥ï¼‰
            return findGreedySolution(boardState, currentPieces);
        }

        return finalSteps;

// æ–°å¢è²ªå¿ƒç­–ç•¥å‡½æ•¸
        function findGreedySolution(board, pieces) {
            const greedySteps = [];
            let currentBoard = board.map(r => [...r]);

            for (let piece of pieces) {
                let placed = false;
                const rows = piece.shape.length;
                const cols = piece.shape[0].length;

                // å˜—è©¦æ”¾ç½®æ­¤æ–¹å¡Š
                for (let r = 0; r <= 8 - rows && !placed; r++) {
                    for (let c = 0; c <= 8 - cols && !placed; c++) {
                        if (canPlaceOnBoard(piece.shape, r, c, currentBoard)) {
                            currentBoard = simulatePlace(piece.shape, r, c, currentBoard);
                            currentBoard = simulateLineClear(currentBoard);
                            greedySteps.push({
                                r: r,
                                c: c,
                                shape: piece.shape,
                                piece: {s: piece.shape},
                                position: {row: r, col: c},
                                pieceName: `æ–¹å¡Š${greedySteps.length + 1}`,
                                notation: `(${r},${c})`
                            });
                            placed = true;
                        }
                    }
                }

                if (!placed) {
                    console.log(`âš ï¸ æ–¹å¡Šç„¡æ³•æ”¾ç½®ï¼Œè·³é:`, piece.shape);
                }
            }

            return greedySteps.length > 0 ? greedySteps : null;
        }


    }

    // ========== é¡¯ç¤ºç„¡è§£é¢æ¿ ==========

    function showNoSolutionPanel() {
        const oldPanel = document.getElementById('no-solution-panel');
        if (oldPanel) oldPanel.remove();

        const panel = document.createElement('div');
        panel.id = 'no-solution-panel';
        panel.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        z-index: 10000;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
    `;

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'ç¢ºå®š';
        closeBtn.style.cssText = `
        padding: 12px 24px;
        background: white;
        color: #c92a2a;
        border: none;
        border-radius: 8px;
        font-weight: bold;
        font-size: 14px;
        cursor: pointer;
        transition: 0.2s;
        margin-top: 20px;
    `;
        closeBtn.onclick = () => panel.remove();

        panel.innerHTML = `
        <h2 style="margin: 0 0 20px 0; font-size: 24px;">âŒ ç„¡è§£</h2>
        <p style="margin: 0 0 20px 0; font-size: 16px;">ç•¶å‰æ–¹å¡Šç„¡æ³•æ‰¾åˆ°æœ‰æ•ˆæ”¾ç½®æ–¹æ¡ˆ</p>
    `;
        panel.appendChild(closeBtn);

        document.body.appendChild(panel);
    }



    function addEndlessModeButton() {
        const buttonContainer = document.querySelector('button').parentElement;

        const endlessBtn = document.createElement('button');
        endlessBtn.id = 'endless-mode-btn';
        endlessBtn.textContent = 'â™¾ï¸ ç„¡ç›¡æ¨¡å¼';
        endlessBtn.style.cssText = `
        padding: 12px 20px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(245, 87, 108, 0.4);
    `;

        endlessBtn.onclick = showEndlessModeDialog;
        buttonContainer.appendChild(endlessBtn);
    }

    function showEndlessModeDialog() {
        if (endlessModeActive) {
            showConfirmDialog('ç¢ºå®šè¦çµæŸç•¶å‰ç„¡ç›¡æ¨¡å¼å—ï¼Ÿ', () => {
                endEndlessMode();
            });
            return;
        }

        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.7);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

        const dialog = document.createElement('div');
        dialog.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        max-width: 500px;
        color: white;
    `;

        dialog.innerHTML = `
    <h2 style="margin-top: 0; text-align: center;">â™¾ï¸ é¸æ“‡ç„¡ç›¡æ¨¡å¼</h2>
    <p style="text-align: center; margin-bottom: 30px; opacity: 0.9;">
        âš ï¸ å•Ÿå‹•å¾Œå°‡ç¦ç”¨ AI åˆ†æã€AI æŒ‡å°ã€ç·¨è¼¯å±€é¢ç­‰åŠŸèƒ½
    </p>

    <div style="display: flex; flex-direction: column; gap: 15px;">
        <button id="timed-endless-btn" style="
            width: 100%;
            padding: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: transform 0.2s;
        ">
            â±ï¸ é™æ™‚æ¨¡å¼ (10 åˆ†é˜)<br>
            <span style="font-size: 14px; opacity: 0.8;">ğŸ‘‘ æœ€é«˜åˆ†: ${typeof highScoreManager !== 'undefined' ? highScoreManager.getScore('timed') : endlessModeHighScores.timed}</span>
        </button>

        <button id="infinite-endless-btn" style="
            width: 100%;
            padding: 20px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: transform 0.2s;
        ">
            â™¾ï¸ ç„¡é™æ¨¡å¼<br>
           <span style="font-size: 14px; opacity: 0.8;">ğŸ‘‘ æœ€é«˜åˆ†: ${typeof highScoreManager !== 'undefined' ? highScoreManager.getScore('infinite') : endlessModeHighScores.infinite}</span>
        </button>

       <button id="ai-endless-btn" style="
    width: 100%;
    padding: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: transform 0.2s;
">
    ğŸ¤– AI ç„¡ç›¡æ¨¡å¼<br>
    <span style="font-size: 14px; opacity: 0.8;">ğŸ‘‘ æœ€é«˜åˆ†: ${highScoreManager.getScore('ai')}</span>
</button>

        <button id="cancel-endless-btn" style="
            width: 100%;
            padding: 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        ">
            âœ• å–æ¶ˆ
        </button>
    </div>
`;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        document.getElementById('timed-endless-btn').onclick = () => {
            startEndlessMode('timed');
            overlay.remove();
        };

        document.getElementById('infinite-endless-btn').onclick = () => {
            startEndlessMode('infinite');
            overlay.remove();
        };

// ğŸ†• æ·»åŠ  AI ç„¡ç›¡æ¨¡å¼æŒ‰éˆ•äº‹ä»¶
        document.getElementById('ai-endless-btn').onclick = () => {
            startEndlessMode('ai');
            overlay.remove();
        };

        document.getElementById('cancel-endless-btn').onclick = () => {
            overlay.remove();
        };

        overlay.onclick = (e) => {
            if (e.target === overlay) overlay.remove();
        };
    }

    function startEndlessMode(type) {
        endlessModeActive = true;
        window.endlessModeActive = true;  // ğŸ”¥ åŠ ä¸Šé€™ä¸€è¡Œï¼
        endlessModeType = type;
        window.endlessModeType = type;  // ğŸ”¥ åŠ ä¸Šé€™ä¸€è¡Œï¼
        endlessModeStartTime = Date.now();
        endlessModeScore = parseInt(document.getElementById('score').textContent) || 0;

        document.getElementById('score').textContent = '0';

        // âœ… ä½¿ç”¨å…¨å±€äº‹ä»¶æ””æˆªå™¨
        setupEndlessModeInterceptor();

        const endlessBtn = document.getElementById('endless-mode-btn');
        endlessBtn.textContent = 'â¹ï¸ çµæŸç„¡ç›¡';
        endlessBtn.style.background = 'linear-gradient(135deg, #f44336 0%, #e91e63 100%)';

        if (type === 'timed') {
            endlessModeTimeRemaining = 600;
            createTimerWidget();
            startTimerCountdown();
            showNotification('é™æ™‚æ¨¡å¼å·²å•Ÿå‹•ï¼\nä½ æœ‰ 10 åˆ†é˜æ™‚é–“ï¼', 'success', 4000);
        } else if (type === 'ai') {
            // ğŸ†• å•Ÿå‹• AI ç„¡ç›¡æ¨¡å¼
            startAIEndlessMode();
            showNotification('AI ç„¡ç›¡æ¨¡å¼å·²å•Ÿå‹•ï¼\nAI å°‡è‡ªå‹•é‹è¡Œç›´åˆ°éŠæˆ²çµæŸ', 'success', 4000);
        } else {
            showNotification('ç„¡é™æ¨¡å¼å·²å•Ÿå‹•ï¼\nç›¡æƒ…æŒ‘æˆ°å§ï¼', 'success', 4000);
        }
    }

    function endEndlessMode(gameOver = false) {
        // ğŸ†• åœæ­¢ AI ç„¡ç›¡æ¨¡å¼
        if (endlessModeType === 'ai') {
            stopAIEndlessMode();
        }

        const finalScore = parseInt(document.getElementById('score').textContent) || 0;
        const type = endlessModeType;

        // ğŸ†• ä½¿ç”¨ highScoreManager æ›´æ–°æœ€é«˜åˆ†
        const isNewRecord = highScoreManager.updateScore(type, finalScore);

// ğŸ†• åŒæ­¥æ›´æ–° endlessModeHighScoresï¼ˆå‘ä¸‹å…¼å®¹ï¼‰
        if (typeof endlessModeHighScores !== 'undefined') {
            endlessModeHighScores[type] = highScoreManager.getScore(type);
        }

        if (endlessModeTimer) {
            clearInterval(endlessModeTimer);
            endlessModeTimer = null;
        }

        const timerWidget = document.getElementById('endless-timer-widget');
        if (timerWidget) timerWidget.remove();

        // âœ… ç§»é™¤å…¨å±€äº‹ä»¶æ””æˆªå™¨
        removeEndlessModeInterceptor();

        const endlessBtn = document.getElementById('endless-mode-btn');
        endlessBtn.textContent = 'â™¾ï¸ ç„¡ç›¡æ¨¡å¼';
        endlessBtn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';

        showEndlessModeResult(finalScore, type, gameOver);

        endlessModeActive = false;
        window.endlessModeActive = false;  // ğŸ”¥ åŠ ä¸Šé€™ä¸€è¡Œï¼

        endlessModeType = null;
        window.endlessModeType = null;  // ğŸ”¥ åŠ ä¸Šé€™ä¸€è¡Œï¼
    }

    // ===== ç¬¬ä¸€æ­¥ï¼šåœ¨ä½ çš„ç¨‹å¼ç¢¼æœ€ä¸Šæ–¹ï¼ŒæŠŠè®Šæ•¸æš´éœ²åˆ° window =====
    window.endlessModeActive = false;
    window.endlessModeType = null;
    window.isDraggingInEndlessMode = false;
    window.blockedPieceElement = null;

    // ===== ç¬¬äºŒæ­¥ï¼šä¿®æ”¹ä½ çš„æ””æˆªå™¨ï¼ˆå®Œå…¨é‡å¯«ï¼‰=====
    function setupEndlessModeInterceptor() {
        console.log('âœ… å•Ÿå‹•ç„¡ç›¡æ¨¡å¼æ””æˆªå™¨');
        window.isDraggingInEndlessMode = false;
        window.blockedPieceElement = null;

        // ğŸ”¥ é—œéµï¼šç”¨ pointerdown æ””æˆªï¼ˆé€™æ˜¯æœ€æ—©çš„äº‹ä»¶ï¼‰
        document.addEventListener('pointerdown', endlessModePointerDownInterceptor, true);
        document.addEventListener('pointermove', endlessModePointerMoveInterceptor, true);
        document.addEventListener('pointerup', endlessModePointerUpInterceptor, true);

        // ä¹Ÿæ””æˆªèˆŠçš„äº‹ä»¶ï¼ˆé˜²æ­¢æœ‰äº›ç¨‹å¼ç¢¼ç”¨èˆŠ APIï¼‰
        document.addEventListener('mousedown', endlessModeMouseDownInterceptor, true);
        document.addEventListener('touchstart', endlessModeTouchStartInterceptor, true);
        document.addEventListener('click', endlessModeClickInterceptor, true);

        console.log('âœ… æ””æˆªå™¨å·²å®‰è£');
    }

    function removeEndlessModeInterceptor() {
        console.log('âœ… ç§»é™¤ç„¡ç›¡æ¨¡å¼æ””æˆªå™¨');
        window.isDraggingInEndlessMode = false;
        window.blockedPieceElement = null;

        document.removeEventListener('pointerdown', endlessModePointerDownInterceptor, true);
        document.removeEventListener('pointermove', endlessModePointerMoveInterceptor, true);
        document.removeEventListener('pointerup', endlessModePointerUpInterceptor, true);
        document.removeEventListener('mousedown', endlessModeMouseDownInterceptor, true);
        document.removeEventListener('touchstart', endlessModeTouchStartInterceptor, true);
        document.removeEventListener('click', endlessModeClickInterceptor, true);
    }

    // ğŸ”¥ æ ¸å¿ƒæ””æˆªå‡½å¼ï¼špointerdownï¼ˆæœ€æ—©è§¸ç™¼ï¼‰
    function endlessModePointerDownInterceptor(e) {
        if (!window.endlessModeActive || window.endlessModeType !== 'ai') return;

        const pieceContainer = e.target.closest('.piece-container');

        if (pieceContainer) {
            console.log('ğŸš« [pointerdown] æ””æˆªæ–¹å¡Šæ‹–æ‹½');

            window.isDraggingInEndlessMode = true;
            window.blockedPieceElement = pieceContainer;

            // ç«‹å³é˜»æ­¢æ‰€æœ‰å¾ŒçºŒè¡Œç‚º
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();

            showAIEndlessModeWarning();
            return false;
        }
    }

    // pointermove æ””æˆª
    function endlessModePointerMoveInterceptor(e) {
        if (!window.endlessModeActive || window.endlessModeType !== 'ai') return;

        if (window.isDraggingInEndlessMode) {
            console.log('ğŸš« [pointermove] é˜»æ­¢æ‹–æ‹½ç§»å‹•');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }
    }

    // pointerup æ””æˆª
    function endlessModePointerUpInterceptor(e) {
        if (!window.endlessModeActive || window.endlessModeType !== 'ai') return;

        if (window.isDraggingInEndlessMode) {
            console.log('ğŸš« [pointerup] çµæŸæ””æˆª');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();

            window.isDraggingInEndlessMode = false;
            window.blockedPieceElement = null;
            return false;
        }
    }

    // mousedown æ””æˆªï¼ˆå‚™ç”¨ï¼‰
    function endlessModeMouseDownInterceptor(e) {
        if (!window.endlessModeActive || window.endlessModeType !== 'ai') return;

        const pieceContainer = e.target.closest('.piece-container');

        if (pieceContainer) {
            console.log('ğŸš« [mousedown] æ””æˆªæ–¹å¡Šæ‹–æ‹½');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            showAIEndlessModeWarning();
            return false;
        }
    }

    // touchstart æ””æˆªï¼ˆå‚™ç”¨ï¼‰
    function endlessModeTouchStartInterceptor(e) {
        if (!window.endlessModeActive || window.endlessModeType !== 'ai') return;

        const pieceContainer = e.target.closest('.piece-container');

        if (pieceContainer) {
            console.log('ğŸš« [touchstart] æ””æˆªæ–¹å¡Šæ‹–æ‹½');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            showAIEndlessModeWarning();
            return false;
        }
    }

    function endlessModeClickInterceptor(e) {
        if (!window.endlessModeActive) return;

        // AI ç„¡ç›¡æ¨¡å¼ï¼šæ””æˆªæ–¹å¡Šå’Œæ£‹ç›¤
        if (window.endlessModeType === 'ai') {
            const isPieceElement = e.target.classList.contains('piece-container') ||
                e.target.classList.contains('p-cell') ||
                e.target.closest('.piece-container');

            const isBoardElement = e.target.classList.contains('cell') ||
                e.target.closest('#board');

            if (isPieceElement || isBoardElement) {
                console.log('ğŸš« [click] AI ç„¡ç›¡æ¨¡å¼æ””æˆª');
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                showAIEndlessModeWarning();
                return false;  // ğŸ”¥ ç¢ºä¿æœ‰ return false
            }
        }

        // æ‰€æœ‰ç„¡ç›¡æ¨¡å¼ï¼šæ””æˆª AI ç›¸é—œæŒ‰éˆ•
        const btn = e.target.closest('button');
        if (!btn) return;

        const text = btn.textContent;
        const isAIButton = text.includes('ğŸ¤– AIæ¨¡å¼') ||
            text.includes('åœæ­¢AI') ||
            text.includes('ğŸ¤– AI åˆ†æ') ||
            text.includes('ğŸ¯ AI æŒ‡å°') ||
            text.includes('ğŸ“¸ æˆªåœ–è­˜åˆ¥') ||
            text.includes('âœï¸ ç·¨è¼¯å±€é¢') ||
            text.includes('â†¶ æ‚”æ­¥');

        if (isAIButton) {
            console.log('ğŸš« æ””æˆªæŒ‰éˆ•:', text);
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            showEndlessModeWarning();
            return false;  // ğŸ”¥ åŠ ä¸Šé€™ä¸€è¡Œï¼
        }
    }

    function showEndlessModeWarning() {
        if (document.getElementById('endless-mode-warning')) {
            return;
        }

        const overlay = document.createElement('div');
        overlay.id = 'endless-mode-warning';
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.7);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

        const dialog = document.createElement('div');
        dialog.style.cssText = `
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        max-width: 450px;
        color: white;
        text-align: center;
    `;

        dialog.innerHTML = `
        <div style="font-size: 64px; margin-bottom: 20px;">âš ï¸</div>
        <h2 style="margin: 0 0 15px 0; font-size: 28px;">ç„¡ç›¡æ¨¡å¼é€²è¡Œä¸­</h2>
        <p style="font-size: 18px; line-height: 1.6; margin-bottom: 30px; opacity: 0.95;">
            ç›®å‰è™•æ–¼ç„¡ç›¡æ¨¡å¼ï¼Œç„¡æ³•é€²è¡Œä»¥ä¸‹æ“ä½œï¼š
        </p>
        <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; margin-bottom: 30px; text-align: left;">
            <div style="margin-bottom: 10px;">âŒ æ›´å‹•å±€é¢ï¼ˆç·¨è¼¯/æ‚”æ­¥ï¼‰</div>
            <div style="margin-bottom: 10px;">âŒ AI åˆ†æèˆ‡æç¤º</div>
            <div>âŒ æˆªåœ–è­˜åˆ¥åŠŸèƒ½</div>
        </div>
        <p style="font-size: 16px; opacity: 0.9; margin-bottom: 30px;">
            è«‹å…ˆçµæŸç„¡ç›¡æ¨¡å¼æ‰èƒ½ä½¿ç”¨é€™äº›åŠŸèƒ½
        </p>
        <button onclick="this.parentElement.parentElement.remove()" style="
            padding: 15px 40px;
            background: white;
            color: #ff6b6b;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            æˆ‘çŸ¥é“äº†
        </button>
    `;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        };

        const escHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    }

    function showEndlessModeResult(score, type, gameOver) {
        // ğŸ†• å¾ highScoreManager ç²å–æœ€é«˜åˆ†
        const highScore = highScoreManager.getScore(type);
        const isNewRecord = score > highScore;

        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); z-index: 2000;
        display: flex; align-items: center; justify-content: center;
    `;

        const panel = document.createElement('div');
        panel.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        max-width: 500px;
        color: white;
        text-align: center;
    `;

        panel.innerHTML = `
        <h1 style="margin: 0; font-size: 48px;">${gameOver ? 'ğŸ’€' : 'ğŸ‰'}</h1>
        <h2 style="margin: 10px 0;">${gameOver ? 'éŠæˆ²çµæŸ' : 'ç„¡ç›¡æ¨¡å¼çµæŸ'}</h2>
        <p style="font-size: 18px; opacity: 0.9;">æ¨¡å¼ï¼š${type === 'timed' ? 'â±ï¸ é™æ™‚ 10 åˆ†é˜' : 'â™¾ï¸ ç„¡é™æ¨¡å¼'}</p>

        <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; margin: 20px 0;">
            <div style="font-size: 16px; opacity: 0.8;">æœ€çµ‚åˆ†æ•¸</div>
            <div style="font-size: 64px; font-weight: bold; margin: 10px 0;">${score}</div>
            ${isNewRecord ? '<div style="font-size: 24px; color: #FFD700;">ğŸ† æ–°ç´€éŒ„ï¼</div>' : ''}
        </div>

    <div style="font-size: 14px; opacity: 0.8; margin-bottom: 20px;">
    æ­·å²æœ€é«˜åˆ†ï¼š${highScoreManager.getScore(type)}
</div>

        <button onclick="this.parentElement.parentElement.remove()" style="
            padding: 15px 40px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
        ">ç¢ºå®š</button>
    `;

        overlay.appendChild(panel);
        document.body.appendChild(overlay);
    }

    function showAIEndlessModeWarning() {
        if (document.getElementById('ai-endless-mode-warning')) {
            return;
        }

        const overlay = document.createElement('div');
        overlay.id = 'ai-endless-mode-warning';
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.7);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

        const dialog = document.createElement('div');
        dialog.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        max-width: 450px;
        color: white;
        text-align: center;
    `;

        dialog.innerHTML = `
        <div style="font-size: 64px; margin-bottom: 20px;">ğŸ¤–</div>
        <h2 style="margin: 0 0 15px 0; font-size: 28px;">AI ç„¡ç›¡æ¨¡å¼é€²è¡Œä¸­</h2>
        <p style="font-size: 18px; line-height: 1.6; margin-bottom: 30px; opacity: 0.95;">
            ç›®å‰è™•æ–¼ AI ç„¡ç›¡æ¨¡å¼ï¼Œç”± AI å…¨è‡ªå‹•æ“æ§
        </p>
        <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; margin-bottom: 30px;">
            <div style="font-size: 20px; font-weight: bold; color: #FFD700;">è«‹å…ˆçµæŸ AI ç„¡ç›¡æ¨¡å¼</div>
            <div style="font-size: 16px; margin-top: 10px; opacity: 0.9;">æ‰èƒ½æ‰‹å‹•æ“æ§æ–¹å¡Š</div>
        </div>
        <button onclick="this.parentElement.parentElement.remove()" style="
            padding: 15px 40px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            æˆ‘çŸ¥é“äº†
        </button>
    `;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        };

        const escHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    }

    function createTimerWidget() {
        const widget = document.createElement('div');
        widget.id = 'endless-timer-widget';
        widget.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        color: white;
        font-size: 24px;
        font-weight: bold;
        z-index: 999;
        cursor: move;
        user-select: none;
    `;

        widget.innerHTML = `
        <div style="font-size: 14px; opacity: 0.8; margin-bottom: 5px;">å‰©é¤˜æ™‚é–“</div>
        <div id="timer-display">10:00</div>
    `;

        makeDraggable(widget);
        document.body.appendChild(widget);
    }

    function makeDraggable(element) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        element.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
            element.style.right = 'auto';
        }

        function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }

    function startTimerCountdown() {
        endlessModeTimer = setInterval(() => {
            endlessModeTimeRemaining--;

            const minutes = Math.floor(endlessModeTimeRemaining / 60);
            const seconds = endlessModeTimeRemaining % 60;
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                timerDisplay.textContent = display;

                if (endlessModeTimeRemaining <= 10) {
                    timerDisplay.style.color = endlessModeTimeRemaining % 2 === 0 ? '#ff0000' : '#ffffff';
                }
            }

            if (endlessModeTimeRemaining <= 0) {
                endEndlessMode(false);
            }
        }, 1000);
    }

    // ========== AI ç„¡ç›¡æ¨¡å¼æ ¸å¿ƒä»£ç¢¼ ==========
    let aiEndlessModeInterval = null;
    let aiEndlessModeScore = 0;
    let aiEndlessUsedPieceIndices = new Set();

    function startAIEndlessMode() {
        console.log('ğŸ¤– AI ç„¡ç›¡æ¨¡å¼å•Ÿå‹•ï¼');

        // ğŸ”¥ é—œéµï¼šè¨­å®šå…¨åŸŸè®Šæ•¸
        window.endlessModeActive = true;
        window.endlessModeType = 'ai';
        window.isDraggingInEndlessMode = false;

        // ğŸ”¥ å•Ÿå‹•æ””æˆªå™¨
        setupEndlessModeInterceptor();

        aiEndlessModeScore = 0;
        document.getElementById('score').textContent = '0';
        aiEndlessUsedPieceIndices = new Set();

        // ç«‹å³åŸ·è¡Œç¬¬ä¸€æ­¥
        executeAIEndlessMove();

        // æ¯ 50ms åŸ·è¡Œä¸€æ­¥
        aiEndlessModeInterval = setInterval(() => {
            if (!window.endlessModeActive || window.endlessModeType !== 'ai') {
                stopAIEndlessMode();
                return;
            }
            executeAIEndlessMove();
        }, 50);

        console.log('âœ… AI ç„¡ç›¡æ¨¡å¼å·²å®Œå…¨å•Ÿå‹•', {
            active: window.endlessModeActive,
            type: window.endlessModeType
        });
    }

    function stopAIEndlessMode() {
        if (aiEndlessModeInterval) {
            clearInterval(aiEndlessModeInterval);
            aiEndlessModeInterval = null;
        }

        // ğŸ”¥ é—œéµï¼šæ¸…é™¤å…¨åŸŸè®Šæ•¸
        window.endlessModeActive = false;
        window.endlessModeType = null;
        window.isDraggingInEndlessMode = false;

        // ğŸ”¥ ç§»é™¤æ””æˆªå™¨
        removeEndlessModeInterceptor();

        // ğŸ†• ä¿å­˜ AI æœ€é«˜åˆ†
        if (aiEndlessModeScore > 0) {
            highScoreManager.updateScore('ai', aiEndlessModeScore);
        }

        console.log('ğŸ¤– AI ç„¡ç›¡æ¨¡å¼åœæ­¢ï¼Œæœ€çµ‚åˆ†æ•¸:', aiEndlessModeScore);
    }

    function executeAIEndlessMove() {
        const currentPieces = getCurrentPieces();
        if (currentPieces.length === 0) {
            console.log('â³ ç­‰å¾…æ–°æ–¹å¡Šç”Ÿæˆ...');
            return;
        }

        // å¦‚æœæ˜¯æ–°å›åˆï¼ˆ3å€‹æ–¹å¡Šï¼‰ï¼Œé‡ç½®è¿½è¹¤
        if (currentPieces.length === 3 && aiEndlessUsedPieceIndices.size > 0) {
            aiEndlessUsedPieceIndices.clear();
            console.log('ğŸ”„ æ–°å›åˆé–‹å§‹ï¼ˆ3å€‹æ–¹å¡Šï¼‰ï¼Œé‡ç½®ç´¢å¼•è¿½è¹¤');
        }

        // æª¢æŸ¥æ˜¯å¦æœ‰ AI è§£æ³•
        if (!aiSolution || !aiSolution.steps || aiSolution.steps.length === 0) {
            console.log('âš ï¸ æ²’æœ‰ AI è§£æ³•ï¼Œå˜—è©¦è‡ªå‹•åˆ†æ...');

            // æª¢æŸ¥æ˜¯å¦çœŸçš„å®Œå…¨ç„¡è§£
            const canPlaceAny = currentPieces.some(piece => {
                if (!piece) return false;
                const shape = piece.shape || piece.s;
                if (!shape || !Array.isArray(shape) || shape.length === 0) return false;

                const rows = shape.length;
                const cols = shape[0].length;

                for (let r = 0; r <= 8 - rows; r++) {
                    for (let c = 0; c <= 8 - cols; c++) {
                        let canPlace = true;
                        for (let sr = 0; sr < rows; sr++) {
                            for (let sc = 0; sc < cols; sc++) {
                                if (shape[sr][sc]) {
                                    const br = r + sr;
                                    const bc = c + sc;
                                    if (br >= 8 || bc >= 8 || br < 0 || bc < 0 || boardState[br][bc] !== 0) {
                                        canPlace = false;
                                        break;
                                    }
                                }
                            }
                            if (!canPlace) break;
                        }
                        if (canPlace) return true;
                    }
                }
                return false;
            });

            if (!canPlaceAny) {
                console.warn('âŒ ç¢ºèªå®Œå…¨ç„¡è§£ï¼ŒAI ç„¡ç›¡æ¨¡å¼çµæŸ');

                // ğŸ†• å…ˆä¿å­˜ AI æœ€é«˜åˆ†å†çµæŸ
                if (aiEndlessModeScore > 0) {
                    const isNewRecord = highScoreManager.updateScore('ai', aiEndlessModeScore);
                    if (isNewRecord) {
                        console.log('ğŸ† æ–°ç´€éŒ„ï¼AI æœ€é«˜åˆ†:', aiEndlessModeScore);
                    } else {
                        console.log('ğŸ’¾ å·²ä¿å­˜ AI åˆ†æ•¸:', aiEndlessModeScore);
                    }
                }

                endEndlessMode(true); // éŠæˆ²çµæŸ
                return;
            }

            // èª¿ç”¨éœé»˜ AI åˆ†æ
            const result = performSilentAIAnalysis();
            if (!result || result.length === 0) {
                console.warn('âš ï¸ éœé»˜åˆ†æå¤±æ•—');
                return;
            }

            aiSolution = { steps: result };
            aiEndlessUsedPieceIndices.clear();
            console.log('âœ… è‡ªå‹•åˆ†ææˆåŠŸï¼Œæ‰¾åˆ°', result.length, 'æ­¥è§£æ³•');
        }

        // å–å‡º AI è§£æ³•çš„ä¸‹ä¸€æ­¥
        const nextStep = aiSolution.steps[0];
        const pieceIndex = findMatchingAIEndlessPieceIndex(nextStep.piece, currentPieces);

        if (pieceIndex === -1) {
            console.warn('âš ï¸ æ‰¾ä¸åˆ°åŒ¹é…çš„æ–¹å¡Šï¼Œé‡æ–°åˆ†æ');
            aiSolution = null;
            aiEndlessUsedPieceIndices.clear();
            return;
        }

        // é©—è­‰ä½ç½®æ˜¯å¦åˆæ³•
        const pos = nextStep.position;
        const shape = nextStep.piece.s || nextStep.shape;
        let isValidMove = true;

        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
                if (shape[r][c]) {
                    const br = pos.row + r;
                    const bc = pos.col + c;
                    if (br >= 8 || bc >= 8 || br < 0 || bc < 0 || boardState[br][bc] !== 0) {
                        isValidMove = false;
                        break;
                    }
                }
            }
            if (!isValidMove) break;
        }

        if (!isValidMove) {
            console.error('ğŸ’¥ AI å˜—è©¦éæ³•ç§»å‹•ï¼Œé‡æ–°åˆ†æ');
            aiSolution = null;
            aiEndlessUsedPieceIndices.clear();
            return;
        }

        // åŸ·è¡Œæ”¾ç½®
        const shapeObj = currentPieces[pieceIndex];
        console.log(`ğŸ¤– AI æ”¾ç½®: ${nextStep.pieceName} @ ${nextStep.notation}`);

        place(shapeObj, pos.row, pos.col, currentPieces);
        const beforeClear = getBoardFullLines();
        checkAndClear();
        const afterClear = getBoardFullLines();

        // è¨ˆç®—å¾—åˆ†
        const clearedLines = Math.abs(afterClear - beforeClear);
        const points = calculateScore(clearedLines);
        aiEndlessModeScore += points;

        // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
        const scoreElement = document.getElementById('score');
        if (scoreElement) {
            scoreElement.textContent = aiEndlessModeScore;
        }

        console.log(`ğŸ“Š AI æœ¬æ¬¡å¾—åˆ†: +${points}, ç´¯è¨ˆåˆ†æ•¸: ${aiEndlessModeScore}`);

        if (beforeClear === afterClear) {
            streakCount = 0;
        }

        // ç§»é™¤å·²ä½¿ç”¨çš„æ–¹å¡Šå®¹å™¨
        const containers = Array.from(piecesArea.children);
        if (containers[pieceIndex]) {
            containers[pieceIndex].remove();
        }

        // åˆªé™¤å®¹å™¨å¾Œç«‹åˆ»æ¸…ç©ºç´¢å¼•è¿½è¹¤
        aiEndlessUsedPieceIndices.clear();

        // ç§»é™¤å·²åŸ·è¡Œçš„æ­¥é©Ÿ
        aiSolution.steps.shift();

        if (aiSolution.steps.length === 0) {
            aiSolution = null;
        }

        // ç«‹å³ç”Ÿæˆæ–°æ–¹å¡Š
        if (piecesArea.children.length === 0) {
            aiEndlessUsedPieceIndices.clear();
            renderNewPieces();


        }
    }

    function findMatchingAIEndlessPieceIndex(targetShape, currentPieces) {
        for (let i = 0; i < currentPieces.length; i++) {
            if (aiEndlessUsedPieceIndices.has(i)) {
                console.log(`â­ï¸ è·³éå·²ä½¿ç”¨çš„æ–¹å¡Šç´¢å¼• ${i}`);
                continue;
            }

            if (shapesMatch(targetShape.s, currentPieces[i].s)) {
                aiEndlessUsedPieceIndices.add(i);
                console.log(`âœ… ä½¿ç”¨æ–¹å¡Šç´¢å¼• ${i}`);
                return i;
            }
        }
        return -1;
    }

    function shapesMatch(shape1, shape2) {
        if (shape1.length !== shape2.length) return false;
        if (shape1[0].length !== shape2[0].length) return false;

        for (let r = 0; r < shape1.length; r++) {
            for (let c = 0; c < shape1[r].length; c++) {
                if (shape1[r][c] !== shape2[r][c]) return false;
            }
        }
        return true;
    }


    const SHAPE_CODES = {
        // === 1æ ¼ ===
        'å–®æ ¼': '1',

        // === 2æ ¼ ===
        'æ©«äºŒ': '2h',
        'ç›´äºŒ': '2v',
        'å³æ–œäºŒ': '2dr',
        'å·¦æ–œäºŒ': '2dl',

        // === 3æ ¼ ===
        'æ©«ä¸‰': '3h',
        'ç›´ä¸‰': '3v',
        'å·¦ä¸‹L3': '3Lld',
        'å³ä¸‹L3': '3Lrd',
        'å·¦ä¸ŠL3': '3Llu',
        'å³ä¸ŠL3': '3Lru',
        'å³æ–œä¸‰': '3dr',
        'å·¦æ–œä¸‰': '3dl',

        // === 4æ ¼ ===
        'æ©«å››': '4h',
        'ç›´å››': '4v',
        'ç”°å­—': '4s',
        'Tå­—ä¸Š': '4Tu',
        'Tå­—ä¸‹': '4Td',
        'Tå­—å·¦': '4Tl',
        'Tå­—å³': '4Tr',
        'Lå­—å·¦ä¸Š': '4Llu',
        'Lå­—å·¦ä¸‹': '4Lld',
        'Lå­—å³ä¸Š': '4Lru',
        'Lå­—å³ä¸‹': '4Lrd',
        // ğŸ†• Jå­—ï¼ˆLçš„é¡åƒï¼‰
        'Jå­—å³ä¸Š': '4Jru',
        'Jå­—å³ä¸‹': '4Jrd',
        'Jå­—å·¦ä¸Š': '4Jlu',
        'Jå­—å·¦ä¸‹': '4Jld',
        'Zå­—å³': '4Zr',
        'Zå­—å·¦': '4Zl',
        'Zå­—ä¸Š': '4Zu',  // ğŸ†•
        'Zå­—ä¸‹': '4Zd',  // ğŸ†•
        'å‡¸å­—å³ä¸Š': '4Cru',
        'å‡¸å­—å·¦ä¸Š': '4Clu',
        'å‡¸å­—å³ä¸‹': '4Crd',
        'å‡¸å­—å·¦ä¸‹': '4Cld',
        'å‡¹å­—ä¸‹': '4Vd',
        'å‡¹å­—ä¸Š': '4Vu',
        'å‡¹å­—å·¦': '4Vl',
        'å‡¹å­—å³': '4Vr',
        'å³æ–œå››': '4dr',  // ğŸ†•
        'å·¦æ–œå››': '4dl',  // ğŸ†•
        'åå­—': '4+',

        // === 5æ ¼ ===
        'æ©«äº”': '5h',
        'ç›´äº”': '5v',
        'å¤§Lå·¦ä¸Š': '5Llu',
        'å¤§Lå³ä¸Š': '5Lru',
        'å¤§Lå·¦ä¸‹': '5Lld',
        'å¤§Lå³ä¸‹': '5Lrd',
        // ğŸ†• é•·Jï¼ˆå¤§Lçš„é¡åƒï¼‰
        'é•·Jå³ä¸Š': '5Jru',
        'é•·Jå³ä¸‹': '5Jrd',
        'é•·Jå·¦ä¸‹': '5Jld',
        'é•·Jå·¦ä¸Š': '5Jlu',
        'å¤§Tä¸Š': '5Tu',
        'å¤§Tä¸‹': '5Td',
        'å¤§Tå·¦': '5Tl',  // ğŸ†•
        'å¤§Tå³': '5Tr',  // ğŸ†•
        'é•·Lå·¦ä¸Š': '5LLlu',
        'é•·Lå³ä¸Š': '5LLru',
        'é•·Lå·¦ä¸‹': '5LLld',
        'é•·Lå³ä¸‹': '5LLrd',
        'å¯¬Lå·¦ä¸‹': '5WLld',
        'å¯¬Lå³ä¸‹': '5WLrd',
        'å¯¬Lå³ä¸Š': '5WLru',
        'å¯¬Lå·¦ä¸Š': '5WLlu',  // ğŸ†•
        'é«˜Lå·¦ä¸‹': '5HLld',
        'é«˜Lå³ä¸‹': '5HLrd',
        'é«˜Lå·¦ä¸Š': '5HLlu',
        'é«˜Lå³ä¸Š': '5HLru',
        'å³æ–œäº”': '5dr',
        'å·¦æ–œäº”': '5dl',

        // === ç‰¹æ®Š ===
        'èƒ–ç”°3x2': '6r',
        'é«˜ç”°2x3': '6c',
        'ä¹å®®æ ¼': '9',
    };

    // åå‘å°ç…§è¡¨ï¼ˆä»£è™Ÿ -> æ–¹å¡Šåç¨±ï¼‰
    const CODE_TO_SHAPE = Object.fromEntries(
        Object.entries(SHAPE_CODES).map(([name, code]) => [code, name])
    );

    function encodeBFEN(boardState, pieces) {
        let bfen = '';

        // ç·¨ç¢¼æ£‹ç›¤ï¼ˆå¾ä¸Šåˆ°ä¸‹ï¼Œå¾å·¦åˆ°å³ï¼‰
        for (let r = 0; r < 8; r++) {
            let currentState = boardState[r][0];
            let count = 1;
            let rowParts = [];

            for (let c = 1; c < 8; c++) {
                if (boardState[r][c] === currentState) {
                    count++;
                } else {
                    rowParts.push(currentState + '' + count);
                    currentState = boardState[r][c];
                    count = 1;
                }
            }
            rowParts.push(currentState + '' + count);

            bfen += rowParts.join(',');
            if (r < 7) bfen += '/';
        }

        // ç·¨ç¢¼é é¸æ–¹å¡Š
        const validPieces = pieces.filter(p => p !== null && p.name);
        if (validPieces.length > 0) {
            bfen += ' ';
            validPieces.forEach((piece, idx) => {
                const code = SHAPE_CODES[piece.name];
                if (code) {
                    bfen += code;
                    if (idx < validPieces.length - 1) bfen += ',';
                }
            });
        }

        return bfen;
    }

    function decodeBFEN(bfen) {
        try {
            const [boardPart, piecesPart] = bfen.trim().split(' ');
            const rows = boardPart.split('/');

            const boardState = Array(8).fill().map(() => Array(8).fill(0));
            const boardColors = Array(8).fill().map(() => Array(8).fill(null));

            for (let r = 0; r < 8 && r < rows.length; r++) {
                const parts = rows[r].split(',');
                let col = 0;

                for (let part of parts) {
                    if (part.length < 2) {
                        throw new Error(`ç¬¬${r+1}è¡Œæ ¼å¼éŒ¯èª¤ï¼š'${part}' æ ¼å¼ä¸æ­£ç¢º`);
                    }

                    const state = parseInt(part[0]);
                    const count = parseInt(part.substring(1));

                    if (state !== 0 && state !== 1) {
                        throw new Error(`ç¬¬${r+1}è¡ŒéŒ¯èª¤ï¼šç‹€æ…‹å¿…é ˆæ˜¯0æˆ–1ï¼Œå¾—åˆ°${state}`);
                    }

                    if (isNaN(count) || count < 1) {
                        throw new Error(`ç¬¬${r+1}è¡ŒéŒ¯èª¤ï¼šæ•¸é‡å¿…é ˆå¤§æ–¼0ï¼Œå¾—åˆ°${count}`);
                    }

                    for (let j = 0; j < count && col < 8; j++) {
                        boardState[r][col] = state;
                        if (state === 1) {
                            boardColors[r][col] = '#ffd54f';
                        }
                        col++;
                    }
                }

                if (col !== 8) {
                    throw new Error(`ç¬¬${r+1}è¡ŒéŒ¯èª¤ï¼šæ‡‰æœ‰8æ ¼ï¼Œå¯¦éš›${col}æ ¼`);
                }
            }

            // è§£æé é¸æ–¹å¡Š
            const pieces = [null, null, null];
            if (piecesPart) {
                const pieceCodes = piecesPart.split(',');
                for (let i = 0; i < pieceCodes.length && i < 3; i++) {
                    const code = pieceCodes[i].trim();
                    const shapeName = CODE_TO_SHAPE[code];
                    if (shapeName) {
                        const shape = allShapes.find(s => s.name === shapeName);
                        if (shape) {
                            pieces[i] = cloneShape(shape);
                        }
                    }
                }
            }

            return { boardState, boardColors, pieces };
        } catch (error) {
            throw new Error('BFEN æ ¼å¼éŒ¯èª¤ï¼š' + error.message);
        }
    }

    function addOCRButton() {
        // 1. åŸºç¤ UI å»ºç«‹
        const undoButton = document.querySelector('button');
        if (!undoButton) return;
        const buttonContainer = undoButton.parentElement;

        const ocrButton = document.createElement('button');
        ocrButton.textContent = 'ğŸ“¸ æˆªåœ–è­˜åˆ¥';
        ocrButton.style.cssText = `
        padding: 12px 20px; background-color: #FF5722; color: white;
        border: none; border-radius: 5px; cursor: pointer;
        font-size: 14px; font-weight: bold; margin-left: 10px;
    `;

        ocrButton.onclick = openOCRDialog;
        buttonContainer.appendChild(ocrButton);

        function openOCRDialog() {
            const overlay = document.createElement('div');
            overlay.id = 'ocr-overlay';
            overlay.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); z-index: 1000; display: flex;
            align-items: center; justify-content: center;
        `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
            background: #8d6e63; padding: 25px; border-radius: 12px;
            width: 90%; max-width: 1100px; max-height: 90vh; overflow-y: auto;
            color: white; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        `;

            // âœ… ä¿®æ­£ï¼šç¢ºä¿æ¨¡æ¿å­—ä¸²æ­£ç¢ºçµæŸ
            dialog.innerHTML = `
            <h2 style="text-align:center; margin-top:0;">ğŸ“¸ æ™ºæ…§è­˜åˆ¥èˆ‡å±€é¢ç·¨è¼¯</h2>
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <!-- å·¦å´æˆªåœ–å€åŸŸ -->
            <div style="flex: 1; min-width: 300px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
            <div id="ocr-status" style="background: #4CAF50; padding: 8px; border-radius: 4px; text-align: center; margin-bottom: 10px;">
            ç¬¬ä¸€æ­¥ï¼šä¸Šå‚³æˆªåœ–
            </div>
            <div id="screenshot-area" style="position: relative; border: 2px dashed #ccc; min-height: 200px; cursor: crosshair;">
            <canvas id="ocr-canvas" style="max-width: 100%; display: block;"></canvas>
            <div id="canvas-hint" style="position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; pointer-events:none;">
            é»æ“Šä¸‹æ–¹æŒ‰éˆ•ä¸Šå‚³æˆªåœ–
            </div>
            </div>
            <input type="file" id="file-input" accept="image/*" style="display:none">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
    <button id="btn-upload" style="flex: 1; padding:10px; background:#4CAF50; border:none; color:white; border-radius:5px; cursor:pointer; font-weight: bold;">ğŸ“ é¸æ“‡åœ–ç‰‡</button>
    <button id="btn-paste" style="flex: 1; padding:10px; background:#2196F3; border:none; color:white; border-radius:5px; cursor:pointer; font-weight: bold;">ğŸ“‹ å¾å‰ªè²¼ç°¿è²¼ä¸Š</button>
</div>

<div style="display: flex; gap: 10px; margin-top: 8px;">
    <button id="btn-undo" style="flex: 1; padding:8px; background:#FF9800; border:none; color:white; border-radius:5px; cursor:pointer; font-weight: bold;">â†¶ å€’é€€ä¸€æ­¥</button>
    <button id="btn-restart" style="flex: 1; padding:8px; background:#f44336; border:none; color:white; border-radius:5px; cursor:pointer; font-weight: bold;">ğŸ”„ é‡æ–°é–‹å§‹</button>
</div>

<div id="paste-hint" style="text-align: center; margin-top: 8px; font-size: 12px; color: #FFD700; display: none;">
    ğŸ’¡ æˆ–ç›´æ¥æŒ‰ Ctrl+V è²¼ä¸Šæˆªåœ–
</div>
            </div>

                <!-- å³å´ç·¨è¼¯å€åŸŸ -->
            <div style="flex: 1; min-width: 300px;">
                <!-- BFEN å€åŸŸ -->
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <label>BFEN ç¢¼ï¼š</label>
            <div style="display: flex; gap: 5px; margin-top: 5px;">
            <input type="text" id="bfen-io" style="flex:1; padding:5px; color: #333;" placeholder="è‡ªå‹•ç”Ÿæˆæˆ–æ‰‹å‹•è¼¸å…¥...">
            <button id="btn-import" style="padding:5px 10px; background:#2196F3; border:none; color:white; border-radius:3px; cursor:pointer;">åŒ¯å…¥</button>
            </div>
            </div>

          <!-- ç·¨è¼¯æ£‹ç›¤ -->
<div id="edit-board-grid" style="display:grid; grid-template-columns:repeat(8, 1fr); gap:2px; background:#5d4037; padding:10px; border-radius:5px; width:100%; max-width:320px; margin: 0 auto; box-sizing:border-box; aspect-ratio: 1/1;">
</div>
                <!-- é é¸æ–¹å¡Šä½ -->
            <div id="edit-pieces-slots" style="display:flex; justify-content:center; gap:10px; margin-top:20px;">
            <div class="edit-piece-slot" data-slot="0" style="width:120px; height:120px; border:3px dashed #4e342e; border-radius:8px; position:relative; background:rgba(255,255,255,0.1);"></div>
            <div class="edit-piece-slot" data-slot="1" style="width:120px; height:120px; border:3px dashed #4e342e; border-radius:8px; position:relative; background:rgba(255,255,255,0.1);"></div>
            <div class="edit-piece-slot" data-slot="2" style="width:120px; height:120px; border:3px dashed #4e342e; border-radius:8px; position:relative; background:rgba(255,255,255,0.1);"></div>
            </div>

                <!-- âœ… æœå°‹æ–¹å¡Šå€åŸŸ -->
            <input type="text" id="shape-search" placeholder="æœå°‹æ–¹å¡Šåç¨±ï¼ˆä¾‹å¦‚ï¼šæ©«ä¸‰ã€Lå­—ã€ç”°å­—ï¼‰"
            style="width:100%; padding:10px; margin-top:15px; border-radius:5px; border:2px solid #4e342e; box-sizing:border-box;">
            <div id="shape-list" style="max-height:150px; overflow-y:auto; background:rgba(255,255,255,0.9); border-radius:5px; margin-top:10px;"></div>
            </div>
            </div>

                <!-- åº•éƒ¨æŒ‰éˆ• -->
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
            <button id="btn-apply" style="padding:10px 30px; background:#4CAF50; border:none; color:white; border-radius:5px; font-weight:bold; cursor:pointer;">âœ“ ç¢ºå®šå¥—ç”¨</button>
            <button id="clear-edit" style="padding:10px 30px; background:#FF9800; border:none; color:white; border-radius:5px; font-weight:bold; cursor:pointer;">âŸ² æ¸…ç©ºæ£‹ç›¤</button>
            <button id="btn-close" style="padding:10px 30px; background:#f44336; border:none; color:white; border-radius:5px; font-weight:bold; cursor:pointer;">âœ• å–æ¶ˆ</button>
            </div>
            `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
    /* ========================================
       ğŸ–¥ï¸ é›»è…¦ç‰ˆæ¨£å¼ï¼ˆé è¨­ï¼‰
       ======================================== */

    #edit-board-grid {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 2px;
        aspect-ratio: 1/1;
    }

    .edit-cell {
        width: 100%;
        height: 100%;
        aspect-ratio: 1/1;
    }

    /* ========================================
       ğŸ“± æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼ï¼ˆ768px ä»¥ä¸‹ï¼‰
       ======================================== */

    @media (max-width: 768px) {
        /* å½ˆçª—æ•´é«” */
        #ocr-overlay > div {
            width: 95% !important;
            max-width: 95% !important;
            padding: 12px !important;
            max-height: 95vh !important;
            overflow-y: auto !important;
        }

        #ocr-overlay h2 {
            font-size: 18px !important;
            margin-bottom: 10px !important;
        }

        /* å·¦å³å€åŸŸå‚ç›´æ’åˆ— */
        #ocr-overlay > div > div:first-of-type {
            flex-direction: column !important;
            gap: 15px !important;
        }

        /* ç·¨è¼¯æ£‹ç›¤ */
        #edit-board-grid {
            width: 100% !important;
            max-width: min(85vw, 300px) !important;
            padding: 6px !important;
            gap: 1px !important;
        }

        /* é é¸æ–¹å¡Šå€åŸŸ */
        #edit-pieces-slots {
            flex-wrap: wrap !important;
            gap: 10px !important;
            justify-content: center !important;
            margin-top: 15px !important;
        }

        .edit-piece-slot {
            width: min(90px, 28vw) !important;
            height: min(90px, 28vw) !important;
            flex-shrink: 0 !important;
        }

        /* æ–¹å¡Šé è¦½ç¸®æ”¾ */
        .slot-piece-container {
            transform-origin: center !important;
        }

        /* æœå°‹å€åŸŸ */
        #shape-search {
            padding: 8px !important;
            font-size: 14px !important;
            margin-top: 12px !important;
        }

        #shape-list {
            max-height: 150px !important;
            font-size: 13px !important;
        }

        .shape-item {
            padding: 8px !important;
        }

        /* æˆªåœ–å€åŸŸ */
        #screenshot-area {
            min-height: 180px !important;
        }

        #ocr-canvas {
            max-width: 100% !important;
            height: auto !important;
        }

        #canvas-hint {
            font-size: 13px !important;
        }

        /* BFEN å€åŸŸ */
        #bfen-io {
            font-size: 13px !important;
            padding: 6px !important;
        }

        /* æŒ‰éˆ• */
        #ocr-overlay button {
            padding: 10px 15px !important;
            font-size: 13px !important;
            white-space: nowrap !important;
        }

        /* åº•éƒ¨æŒ‰éˆ•å€ */
        #ocr-overlay > div > div:last-child {
            flex-wrap: wrap !important;
            gap: 8px !important;
        }

        #btn-apply, #clear-edit, #btn-close {
            flex: 1 1 calc(50% - 4px) !important;
            min-width: 120px !important;
        }

        /* ä¸Šå‚³æŒ‰éˆ•å€ */
        #btn-upload, #btn-paste {
            font-size: 13px !important;
            padding: 10px !important;
        }

/* æ–°å¢ï¼šå€’é€€å’Œé‡æ–°é–‹å§‹æŒ‰éˆ• */
#btn-undo, #btn-restart {
    font-size: 12px !important;
    padding: 8px !important;
}



        #paste-hint {
            font-size: 11px !important;
        }
    }

    /* ========================================
       ğŸ“± è¶…å°è¢å¹•ï¼ˆ360px ä»¥ä¸‹ï¼‰
       ======================================== */

    @media (max-width: 360px) {
        #ocr-overlay > div {
            padding: 10px !important;
        }

        #ocr-overlay h2 {
            font-size: 16px !important;
        }

        #edit-board-grid {
            max-width: min(82vw, 260px) !important;
            padding: 5px !important;
        }

        .edit-piece-slot {
            width: min(75px, 26vw) !important;
            height: min(75px, 26vw) !important;
        }

        #ocr-overlay button {
            padding: 8px 10px !important;
            font-size: 12px !important;
        }

        #shape-search {
            font-size: 12px !important;
        }

        #shape-list {
            max-height: 120px !important;
            font-size: 12px !important;
        }
    }

    /* ========================================
       ğŸ–¥ï¸ å¤§è¢å¹•å„ªåŒ–ï¼ˆ1200px ä»¥ä¸Šï¼‰
       ======================================== */

    @media (min-width: 1200px) {
        #edit-board-grid {
            max-width: 380px !important;
            padding: 12px !important;
        }

        .edit-piece-slot {
            width: 140px !important;
            height: 140px !important;
        }
    }
`;
            document.head.appendChild(style);
            // ========================================
            // âœ… ç„¶å¾Œæ‰é–‹å§‹æŸ¥è©¢å…ƒç´ å’Œç¶å®šäº‹ä»¶
            // ========================================

            let points = [];
            let imgData = null;
            const canvas = document.getElementById('ocr-canvas');
            const ctx = canvas.getContext('2d');
            let editBoardState = Array(8).fill().map(() => Array(8).fill(0));
            let editBoardColors = Array(8).fill().map(() => Array(8).fill(null));
            let selectedShape = null;
            let editPieces = [null, null, null];

            // è¤‡è£½ç•¶å‰é é¸æ–¹å¡Š
            const currentPieces = getCurrentPieces();
            currentPieces.forEach((piece, index) => {
                if (index < 3 && piece && piece.s) {
                    editPieces[index] = cloneShape(piece);
                }
            });

            // âœ… ç¾åœ¨æ‰æŸ¥è©¢å…ƒç´ 
            const editBoard = document.getElementById('edit-board-grid');
            const searchInput = document.getElementById('shape-search');
            const shapeList = document.getElementById('shape-list');

        // åˆå§‹åŒ–ç·¨è¼¯æ£‹ç›¤
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const cell = document.createElement('div');
                cell.className = 'edit-cell';
                cell.dataset.row = r;
                cell.dataset.col = c;
                cell.style.cssText = 'width:100%; height:100%; background:#4e342e; border-radius:3px; cursor:pointer;';

                // è¤‡è£½ç•¶å‰æ£‹ç›¤ç‹€æ…‹
                if (boardState[r][c]) {
                    editBoardState[r][c] = 1;
                    cell.classList.add('filled');
                    const mainCell = boardElement.children[r * 8 + c];
                    const color = mainCell.style.backgroundColor || '#81c784';
                    cell.style.backgroundColor = color;
                    editBoardColors[r][c] = color;
                }

                cell.addEventListener('click', function(e) {
                    if (selectedShape) return;

                    const row = parseInt(this.dataset.row);
                    const col = parseInt(this.dataset.col);

                    if (editBoardState[row][col]) {
                        editBoardState[row][col] = 0;
                        editBoardColors[row][col] = null;
                        this.classList.remove('filled', 'user-placed');
                        this.style.backgroundColor = '';
                    } else {
                        editBoardState[row][col] = 1;
                        editBoardColors[row][col] = '#ffd54f';
                        this.classList.add('user-placed');
                        this.style.backgroundColor = '#ffd54f';
                    }

                    updateBFENOutput();
                });

                editBoard.appendChild(cell);
            }
        }

            // æ¸²æŸ“é é¸æ–¹å¡Š
            editPieces.forEach((shapeObj, slotIndex) => {
                if (!shapeObj || !shapeObj.s) return;

                const slot = document.querySelector(`.edit-piece-slot[data-slot="${slotIndex}"]`);
                if (!slot) return;

                const container = document.createElement('div');
                container.className = 'slot-piece-container';

                const width = shapeObj.s[0].length * 40;
                const height = shapeObj.s.length * 40;
                const maxDimension = Math.max(width, height);

                // âœ… å‹•æ…‹ç²å– slot å°ºå¯¸
                const slotSize = slot.offsetWidth || 120;
                let scale = maxDimension > slotSize * 0.8 ? (slotSize * 0.8) / maxDimension : 1;

                container.style.cssText = `
        position: absolute;
        left: 50%;
        top: 50%;
        width: ${width}px;
        height: ${height}px;
        transform: translate(-50%, -50%) scale(${scale});
        transform-origin: center;
    `;

                shapeObj.s.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const div = document.createElement('div');
                            div.className = 'slot-p-cell filled';
                            div.style.cssText = `
                    position: absolute;
                    width: 40px;
                    height: 40px;
                    background-color: ${shapeObj.color};
                    left: ${c * 40}px;
                    top: ${r * 40}px;
                    border-radius: 4px;
                `;
                            container.appendChild(div);
                        }
                    });
                });

                slot.appendChild(container);
                slot.classList.add('has-piece');
            });

        // ========================================
        // æˆªåœ–è­˜åˆ¥åŠŸèƒ½
        // ========================================
        document.getElementById('btn-upload').onclick = () => document.getElementById('file-input').click();

            // ========================================
// å‰ªè²¼ç°¿è²¼ä¸ŠåŠŸèƒ½
// ========================================

// æŒ‰éˆ•é»æ“Šæç¤º
            document.getElementById('btn-paste').onclick = function() {
                document.getElementById('paste-hint').style.display = 'block';

                // å˜—è©¦ç›´æ¥è®€å–å‰ªè²¼ç°¿ï¼ˆæŸäº›ç€è¦½å™¨æ”¯æ´ï¼‰
                if (navigator.clipboard && navigator.clipboard.read) {
                    navigator.clipboard.read().then(items => {
                        for (let item of items) {
                            for (let type of item.types) {
                                if (type.startsWith('image/')) {
                                    item.getType(type).then(blob => {
                                        loadImageFromBlob(blob);
                                    });
                                    return;
                                }
                            }
                        }
                        showNotification('å‰ªè²¼ç°¿ä¸­æ²’æœ‰åœ–ç‰‡\n\nè«‹å…ˆæˆªåœ–ä¸¦è¤‡è£½ï¼ˆCtrl+Cï¼‰ï¼Œç„¶å¾ŒæŒ‰ Ctrl+V è²¼ä¸Š', 'warning', 5000);
                    }).catch(err => {
                        showNotification('è«‹æŒ‰ Ctrl+V è²¼ä¸Šæˆªåœ–', 'info', 3000);
                    });
                } else {
                    showNotification('è«‹æŒ‰ Ctrl+V è²¼ä¸Šæˆªåœ–', 'info', 3000);
                }

            };

// ç›£è½å…¨åŸŸ paste äº‹ä»¶
            document.addEventListener('paste', function(e) {
                // æª¢æŸ¥å°è©±æ¡†æ˜¯å¦é–‹å•Ÿ
                if (!document.getElementById('ocr-overlay')) return;

                const items = e.clipboardData?.items;
                if (!items) return;

                for (let item of items) {
                    if (item.type.startsWith('image/')) {
                        const blob = item.getAsFile();
                        loadImageFromBlob(blob);
                        document.getElementById('paste-hint').style.display = 'none';
                        e.preventDefault();
                        return;
                    }
                }
            });

// çµ±ä¸€çš„åœ–ç‰‡è¼‰å…¥å‡½æ•¸
            function loadImageFromBlob(blob) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        document.getElementById('canvas-hint').style.display = 'none';
                        points = [];
                        updateOCRStatus();


                        // é¡¯ç¤ºæˆåŠŸæç¤º
                        const status = document.getElementById('ocr-status');
                        status.textContent = 'âœ… åœ–ç‰‡å·²è¼‰å…¥ï¼é–‹å§‹æ¨™è¨˜å››å€‹è§’(ç”±å·¦ä¸Šè§’é–‹å§‹æ¨™è¨˜)';
                        status.style.background = '#4CAF50';
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(blob);
            }

            document.getElementById('file-input').onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadImageFromBlob(file);
                }
            };

            // å€’é€€æŒ‰éˆ•åŠŸèƒ½
            document.getElementById('btn-undo').onclick = () => {
                if (points.length === 0) {
                    showNotification('æ²’æœ‰å¯ä»¥å€’é€€çš„æ­¥é©Ÿ', 'info', 2000);
                    return;
                }

                points.pop();

                // é‡ç¹ªç•«å¸ƒ
                if (imgData) {
                    ctx.putImageData(imgData, 0, 0);
                    points.forEach((p, i) => drawMarker(p.x, p.y, i + 1));
                }

                updateOCRStatus();
            };

// é‡æ–°// é‡æ–°é–‹å§‹æŒ‰éˆ•åŠŸèƒ½ï¼ˆå®Œå…¨é‡ç½®ï¼ŒåŒ…æ‹¬æ¸…é™¤åœ–ç‰‡ï¼‰
            document.getElementById('btn-restart').onclick = () => {
                // æ¸…ç©ºæ¨™è¨˜é»
                points = [];

                // æ¸…ç©ºç•«å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // æ¸…ç©ºåœ–ç‰‡æ•¸æ“š
                imgData = null;

                // é‡ç½®ç•«å¸ƒå°ºå¯¸
                canvas.width = 0;
                canvas.height = 0;

                // é¡¯ç¤ºæç¤ºæ–‡å­—
                document.getElementById('canvas-hint').style.display = 'block';

                // é‡ç½®ç‹€æ…‹æç¤º
                const status = document.getElementById('ocr-status');
                status.textContent = 'ç¬¬ä¸€æ­¥ï¼šä¸Šå‚³æˆªåœ–';
                status.style.background = '#4CAF50';

                // éš±è—è²¼ä¸Šæç¤º
                document.getElementById('paste-hint').style.display = 'none';

                // é‡ç½®æª”æ¡ˆè¼¸å…¥
                document.getElementById('file-input').value = '';
            };

// æ›´æ–°æŒ‰éˆ•é¡¯ç¤ºç‹€æ…‹


        canvas.onclick = (e) => {
            if (!imgData || points.length >= 5) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            points.push({x, y});
            drawMarker(x, y, points.length);
            updateOCRStatus();


            if (points.length === 5) {
                processOCR();
            }
        };

            function drawMarker(x, y, num) {
                // æ ¹æ“šè¢å¹•å¯¬åº¦èª¿æ•´å¤§å°
                const isMobile = window.innerWidth <= 768;
                const outerRadius = isMobile ? 28 : 15;      // âœ… æ”¹æˆ 40pxï¼ˆæ›´å¤§ï¼‰
                const fontSize = isMobile ? 38 : 18;          // âœ… æ”¹æˆ 38pxï¼ˆæ›´å¤§ï¼‰
                const lineWidth = isMobile ? 6 : 3;           // âœ… æ”¹æˆ 6pxï¼ˆæ›´ç²—ï¼‰

                // å¤–åœˆï¼ˆç´…è‰²ï¼‰
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
                ctx.fill();

                // ç™½è‰²é‚Šæ¡†
                ctx.strokeStyle = 'white';
                ctx.lineWidth = lineWidth;
                ctx.stroke();

                // æ•¸å­—
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num, x, y);
            }

        // åœ¨ openOCRDialog() å‡½æ•¸å…§

        function updateOCRStatus() {
            const tips = ['æ¨™è¨˜å·¦ä¸Šè§’', 'æ¨™è¨˜å³ä¸Šè§’', 'æ¨™è¨˜å³ä¸‹è§’', 'æ¨™è¨˜å·¦ä¸‹è§’', 'é»æ“Šä»»æ„ç©ºæ ¼åƒè€ƒ', 'è­˜åˆ¥å®Œæˆï¼'];
            document.getElementById('ocr-status').textContent = `æ­¥é©Ÿï¼š${tips[points.length] || 'Done'}`;
        }

        function processOCR() {
            const [topLeft, topRight, bottomRight, bottomLeft, ref] = points;

            // ========================================
            // ç¹ªè£½ç¶ è‰²é‚Šæ¡†ï¼ˆæ¨™è¨˜æ£‹ç›¤å€åŸŸï¼‰
            // ========================================
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(topLeft.x, topLeft.y);
            ctx.lineTo(topRight.x, topRight.y);
            ctx.lineTo(bottomRight.x, bottomRight.y);
            ctx.lineTo(bottomLeft.x, bottomLeft.y);
            ctx.closePath();
            ctx.stroke();

            // ========================================
            // ç¹ªè£½ç¶²æ ¼ç·šï¼ˆè¼”åŠ©æª¢æŸ¥åˆ‡å‰²ï¼‰
            // ========================================
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.3)';
            ctx.lineWidth = 1;

            // å‚ç›´ç·šï¼ˆ9 æ¢ï¼‰
            for (let c = 0; c <= 8; c++) {
                const ratio = c / 8;
                const topX = topLeft.x * (1 - ratio) + topRight.x * ratio;
                const topY = topLeft.y * (1 - ratio) + topRight.y * ratio;
                const bottomX = bottomLeft.x * (1 - ratio) + bottomRight.x * ratio;
                const bottomY = bottomLeft.y * (1 - ratio) + bottomRight.y * ratio;

                ctx.beginPath();
                ctx.moveTo(topX, topY);
                ctx.lineTo(bottomX, bottomY);
                ctx.stroke();
            }

            // æ°´å¹³ç·šï¼ˆ9 æ¢ï¼‰
            for (let r = 0; r <= 8; r++) {
                const ratio = r / 8;
                const leftX = topLeft.x * (1 - ratio) + bottomLeft.x * ratio;
                const leftY = topLeft.y * (1 - ratio) + bottomLeft.y * ratio;
                const rightX = topRight.x * (1 - ratio) + bottomRight.x * ratio;
                const rightY = topRight.y * (1 - ratio) + bottomRight.y * ratio;

                ctx.beginPath();
                ctx.moveTo(leftX, leftY);
                ctx.lineTo(rightX, rightY);
                ctx.stroke();
            }

            // ========================================
            // ç²å–ç©ºæ ¼åƒè€ƒé¡è‰²
            // ========================================
            const refColor = getPixel(ref.x, ref.y);

            // ========================================
            // éæ­· 8x8 æ£‹ç›¤ä¸¦è­˜åˆ¥æ¯å€‹æ ¼å­
            // ========================================
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    // å¾æ ¼å­ä¸­å¿ƒå–æ¨£ï¼ˆé¿å…é‚Šç•Œèª¤å·®ï¼‰
                    const rowRatio = (r + 0.5) / 8;
                    const colRatio = (c + 0.5) / 8;

                    // ä¸Šé‚Šç•Œæ’å€¼ï¼ˆå·¦ä¸Š â†’ å³ä¸Šï¼‰
                    const topX = topLeft.x * (1 - colRatio) + topRight.x * colRatio;
                    const topY = topLeft.y * (1 - colRatio) + topRight.y * colRatio;

                    // ä¸‹é‚Šç•Œæ’å€¼ï¼ˆå·¦ä¸‹ â†’ å³ä¸‹ï¼‰
                    const bottomX = bottomLeft.x * (1 - colRatio) + bottomRight.x * colRatio;
                    const bottomY = bottomLeft.y * (1 - colRatio) + bottomRight.y * colRatio;

                    // å‚ç›´æ’å€¼ï¼ˆä¸Šé‚Šç•Œ â†’ ä¸‹é‚Šç•Œï¼‰å–æ ¼å­ä¸­å¿ƒ
                    const targetX = topX * (1 - rowRatio) + bottomX * rowRatio;
                    const targetY = topY * (1 - rowRatio) + bottomY * rowRatio;

                    // ç²å–è©²ä½ç½®çš„é¡è‰²
                    const cellColor = getPixel(targetX, targetY);

                    // è¨ˆç®—èˆ‡ç©ºæ ¼åƒè€ƒé¡è‰²çš„å·®ç•°ï¼ˆæ­æ°è·é›¢ï¼‰
                    const diff = Math.sqrt(
                        Math.pow(cellColor.r - refColor.r, 2) +
                        Math.pow(cellColor.g - refColor.g, 2) +
                        Math.pow(cellColor.b - refColor.b, 2)
                    );

                    // é–¾å€¼åˆ¤å®šï¼ˆå·®ç•° > 30 â†’ æœ‰æ–¹å¡Šï¼Œâ‰¤ 30 â†’ ç©ºæ ¼ï¼‰
                    editBoardState[r][c] = diff > 30 ? 1 : 0;

                    // ========================================
                    // å¯é¸ï¼šåœ¨ç•«å¸ƒä¸Šæ¨™è¨˜å–æ¨£é»ï¼ˆèª¿è©¦ç”¨ï¼‰
                    // ========================================
                    // ctx.fillStyle = editBoardState[r][c] ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 255, 0, 0.5)';
                    // ctx.beginPath();
                    // ctx.arc(targetX, targetY, 3, 0, Math.PI * 2);
                    // ctx.fill();
                }
            }

            // ========================================
            // æ›´æ–°ç·¨è¼¯æ£‹ç›¤çš„é¡¯ç¤º
            // ========================================
            Array.from(editBoard.children).forEach((cell, idx) => {
                const r = Math.floor(idx / 8);
                const c = idx % 8;

                if (editBoardState[r][c]) {
                    // è­˜åˆ¥ç‚ºæœ‰æ–¹å¡Š â†’ é¡¯ç¤ºé»ƒè‰²
                    cell.classList.add('user-placed');
                    cell.style.backgroundColor = '#ffd54f';
                    editBoardColors[r][c] = '#ffd54f';
                } else {
                    // è­˜åˆ¥ç‚ºç©ºæ ¼ â†’ æ¸…ç©º
                    cell.classList.remove('filled', 'user-placed');
                    cell.style.backgroundColor = '';
                    editBoardColors[r][c] = null;
                }
            });

            // ========================================
            // æ›´æ–° BFEN è¼¸å‡º
            // ========================================
            updateBFENOutput();
        }

        function getPixel(x, y) {
            const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
            return {
                r: imgData.data[idx],
                g: imgData.data[idx+1],
                b: imgData.data[idx+2]
            };
        }

        // ========================================
        // BFEN åŠŸèƒ½
        // ========================================
        function updateBFENOutput() {
            const bfenOutput = document.getElementById('bfen-io');
            if (bfenOutput) {
                bfenOutput.value = encodeBFEN(editBoardState, editPieces);
            }
        }

        document.getElementById('btn-import').addEventListener('click', function() {
            const bfenInput = document.getElementById('bfen-io');
            const bfen = bfenInput.value.trim();

            if (!bfen) {
                showNotification('è«‹è¼¸å…¥ BFEN ç¢¼', 'warning');
                return;
            }

            try {
                const decoded = decodeBFEN(bfen);
                editBoardState = decoded.boardState;
                editBoardColors = decoded.boardColors;

                Array.from(editBoard.children).forEach((cell, idx) => {
                    const r = Math.floor(idx / 8);
                    const c = idx % 8;

                    if (editBoardState[r][c]) {
                        cell.classList.add('filled', 'user-placed');
                        cell.style.backgroundColor = editBoardColors[r][c] || '#ffd54f';
                    } else {
                        cell.classList.remove('filled', 'user-placed');
                        cell.style.backgroundColor = '';
                    }
                });

                editPieces = decoded.pieces;

                document.querySelectorAll('.edit-piece-slot').forEach((slot, slotIndex) => {
                    slot.innerHTML = '';
                    slot.classList.remove('has-piece');

                    const shapeObj = editPieces[slotIndex];
                    if (shapeObj && shapeObj.s) {
                        const container = document.createElement('div');
                        container.className = 'slot-piece-container';

                        const width = shapeObj.s[0].length * 40;
                        const height = shapeObj.s.length * 40;
                        const maxDimension = Math.max(width, height);

                        // âœ… å‹•æ…‹ç²å– slot å°ºå¯¸
                        const slotSize = slot.offsetWidth || 120;
                        let scale = maxDimension > slotSize * 0.8 ? (slotSize * 0.8) / maxDimension : 1;

                        container.style.cssText = `
            position: absolute;
            left: 50%;
            top: 50%;
            width: ${width}px;
            height: ${height}px;
            transform: translate(-50%, -50%) scale(${scale});
            transform-origin: center;
        `;

                        shapeObj.s.forEach((row, r) => {
                            row.forEach((cell, c) => {
                                if (cell) {
                                    const div = document.createElement('div');
                                    div.className = 'slot-p-cell filled';
                                    div.style.cssText = `
                        position: absolute;
                        width: 40px;
                        height: 40px;
                        background-color: ${shapeObj.color};
                        left: ${c * 40}px;
                        top: ${r * 40}px;
                        border-radius: 4px;
                    `;
                                    container.appendChild(div);
                                }
                            });
                        });

                        slot.appendChild(container);
                        slot.classList.add('has-piece');
                    }
                });

                updateBFENOutput();
                showNotification('BFEN ç¢¼åŒ¯å…¥æˆåŠŸï¼', 'success');

            } catch (error) {
                showNotification(error.message, 'error');
            }
        });

        // ========================================
        // æœå°‹æ–¹å¡ŠåŠŸèƒ½
        // ========================================
        function updateShapeList(keyword = '') {
            shapeList.innerHTML = '';

            const filtered = keyword === ''
                ? allShapes
                : allShapes.filter(s => s.name.toLowerCase().includes(keyword.toLowerCase()));

            filtered.forEach(shape => {
                const item = document.createElement('div');
                item.className = 'shape-item';
                item.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            `;

                const preview = document.createElement('div');
                preview.style.position = 'relative';
                preview.style.display = 'inline-block';

                const cellSize = 20;
                preview.style.width = (shape.s[0].length * cellSize) + 'px';
                preview.style.height = (shape.s.length * cellSize) + 'px';

                shape.s.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const div = document.createElement('div');
                            div.style.cssText = `
            position: absolute;
            width: ${cellSize}px;
            height: ${cellSize}px;
            background-color: ${shape.color};
            left: ${c * cellSize}px;
            top: ${r * cellSize}px;
            border-radius: 2px;
            box-shadow: inset 2px 2px 0 rgba(255,255,255,0.4), inset -2px -2px 0 rgba(0,0,0,0.2);
            `;
                            preview.appendChild(div);
                        }
                    });
                });

                const nameSpan = document.createElement('span');
                nameSpan.textContent = shape.name;
                nameSpan.style.cssText = 'color: #333; font-weight: bold; flex: 1;';

                item.appendChild(preview);
                item.appendChild(nameSpan);

                item.addEventListener('click', function() {
                    selectedShape = cloneShape(shape);
                    searchInput.value = `å·²é¸æ“‡ï¼š${shape.name}ï¼ˆè«‹é»æ“Šé å‚™ä½æˆ–æ£‹ç›¤æ ¼å­æ”¾ç½®ï¼‰`;
                    enableShapePlacement();
                });

                item.addEventListener('mouseenter', function() {
                    this.style.background = '#e3f2fd';
                });

                item.addEventListener('mouseleave', function() {
                    this.style.background = '';
                });

                shapeList.appendChild(item);
            });
        }

        updateShapeList();

        searchInput.addEventListener('input', function() {
            const keyword = this.value.trim();
            if (keyword.startsWith('å·²é¸æ“‡ï¼š')) return;
            updateShapeList(keyword);
        });

        // ========================================
        // æ–¹å¡Šæ”¾ç½®åŠŸèƒ½
        // ========================================
        function enableShapePlacement() {
            if (!selectedShape) return;

            document.querySelectorAll('.edit-piece-slot').forEach(slot => {
                slot.style.cursor = 'pointer';
                slot.style.border = '3px solid #4CAF50';

                const slotClickHandler = function() {
                    if (!selectedShape) return;

                    const slotIndex = parseInt(this.dataset.slot);
                    this.innerHTML = '';

                    const container = document.createElement('div');
                    container.className = 'slot-piece-container';

                    const width = selectedShape.s[0].length * 40;
                    const height = selectedShape.s.length * 40;
                    const maxDimension = Math.max(width, height);

                    // âœ… å‹•æ…‹ç²å– slot å°ºå¯¸
                    const slotSize = this.offsetWidth || 120;
                    let scale = maxDimension > slotSize * 0.8 ? (slotSize * 0.8) / maxDimension : 1;

                    container.style.cssText = `
        position: absolute;
        left: 50%;
        top: 50%;
        width: ${width}px;
        height: ${height}px;
        transform: translate(-50%, -50%) scale(${scale});
        transform-origin: center;
    `;

                    selectedShape.s.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            if (cell) {
                                const div = document.createElement('div');
                                div.className = 'slot-p-cell filled';
                                div.style.cssText = `
                    position: absolute;
                    width: 40px;
                    height: 40px;
                    background-color: ${selectedShape.color};
                    left: ${c * 40}px;
                    top: ${r * 40}px;
                    border-radius: 4px;
                `;
                                container.appendChild(div);
                            }
                        });
                    });

                    this.appendChild(container);
                    this.classList.add('has-piece');
                    editPieces[slotIndex] = cloneShape(selectedShape);

                    updateBFENOutput();
                    resetShapeSelection();
                };

                slot.removeEventListener('click', slotClickHandler);
                slot.addEventListener('click', slotClickHandler);
            });

            Array.from(editBoard.children).forEach(cell => {
                cell.style.cursor = 'crosshair';
                cell.style.border = '2px solid #4CAF50';

                const cellClickHandler = function(e) {
                    e.stopPropagation();

                    if (!selectedShape) return;

                    const r = parseInt(this.dataset.row);
                    const c = parseInt(this.dataset.col);

                    if (canPlaceOnBoard(selectedShape.s, r, c, editBoardState)) {
                        selectedShape.s.forEach((row, i) => {
                            row.forEach((val, j) => {
                                if (val) {
                                    editBoardState[r + i][c + j] = 1;
                                    editBoardColors[r + i][c + j] = selectedShape.color;
                                    const targetCell = editBoard.children[(r + i) * 8 + (c + j)];
                                    targetCell.classList.add('filled');
                                    targetCell.style.backgroundColor = selectedShape.color;
                                }
                            });
                        });
                        updateBFENOutput();
                        resetShapeSelection();
                    } else {
                        showNotification('ç„¡æ³•åœ¨æ­¤ä½ç½®æ”¾ç½®æ–¹å¡Šï¼', 'error');
                    }
                };

                cell.dataset.hasShapeHandler = 'true';
                cell.addEventListener('click', cellClickHandler);
            });
        }

        function resetShapeSelection() {
            selectedShape = null;
            searchInput.value = '';
            updateShapeList();

            document.querySelectorAll('.edit-piece-slot').forEach(s => {
                s.style.cursor = '';
                s.style.border = '3px dashed #4e342e';
                if (s.classList.contains('has-piece')) {
                    s.style.border = '3px solid #66bb6a';
                }
            });

            Array.from(editBoard.children).forEach(cell => {
                cell.style.cursor = 'pointer';
                cell.style.border = '';
                if (cell.dataset.hasShapeHandler) {
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);

                    newCell.addEventListener('click', function(e) {
                        if (selectedShape) return;

                        const row = parseInt(this.dataset.row);
                        const col = parseInt(this.dataset.col);

                        if (editBoardState[row][col]) {
                            editBoardState[row][col] = 0;
                            editBoardColors[row][col] = null;
                            this.classList.remove('filled', 'user-placed');
                            this.style.backgroundColor = '';
                        } else {
                            editBoardState[row][col] = 1;
                            editBoardColors[row][col] = '#ffd54f';
                            this.classList.add('user-placed');
                            this.style.backgroundColor = '#ffd54f';
                        }

                        updateBFENOutput();
                    });
                }
            });
        }

        // ========================================
        // æŒ‰éˆ•äº‹ä»¶
        // ========================================
            document.getElementById('clear-edit').addEventListener('click', function() {
                showConfirmDialog('ç¢ºå®šè¦æ¸…ç©ºæ•´å€‹æ£‹ç›¤å—ï¼Ÿ', () => {
                    editBoardState = Array(8).fill().map(() => Array(8).fill(0));
                    editBoardColors = Array(8).fill().map(() => Array(8).fill(null));

                    Array.from(editBoard.children).forEach(cell => {
                        cell.classList.remove('filled', 'user-placed');
                        cell.style.backgroundColor = '';
                    });
                    updateBFENOutput();
                });
            });

        document.getElementById('btn-close').addEventListener('click', function() {
            overlay.remove();
        });

        overlay.addEventListener('click', function(e) {
            if (e.target === overlay) {
                overlay.remove();
            }
        });

            document.getElementById('btn-apply').addEventListener('click', function() {
                const validPieces = editPieces.filter(p => p !== null);
                if (validPieces.length === 0) {
                    showNotification('å±€é¢ä¸åˆæ³•ï¼\n\nè‡³å°‘éœ€è¦è¨­å®šä¸€å€‹é é¸æ–¹å¡Šï¼Œå¦å‰‡éŠæˆ²ç„¡æ³•ç¹¼çºŒã€‚', 'warning', 5000);
                    return;
                }

                let hasFullRow = false;
                let hasFullCol = false;
                let fullRowIndices = [];
                let fullColIndices = [];

                for (let r = 0; r < 8; r++) {
                    if (editBoardState[r].every(v => v)) {
                        hasFullRow = true;
                        fullRowIndices.push(r + 1);
                    }
                }

                for (let c = 0; c < 8; c++) {
                    if (editBoardState.every(row => row[c])) {
                        hasFullCol = true;
                        fullColIndices.push(String.fromCharCode(65 + c));
                    }
                }

                if (hasFullRow || hasFullCol) {
                    let message = 'å±€é¢ä¸åˆæ³•ï¼\n\næ£‹ç›¤ä¸­å­˜åœ¨æ»¿è¡Œæˆ–æ»¿åˆ—ï¼Œé€™æœƒå°è‡´è‡ªå‹•æ¶ˆé™¤ã€‚\n\n';
                    if (hasFullRow) {
                        message += `æ»¿è¡Œï¼šç¬¬ ${fullRowIndices.join(', ')} è¡Œ\n`;
                    }
                    if (hasFullCol) {
                        message += `æ»¿åˆ—ï¼šç¬¬ ${fullColIndices.join(', ')} åˆ—\n`;
                    }
                    message += '\nè«‹èª¿æ•´å¾Œå†å¥—ç”¨ã€‚';
                    showNotification(message, 'warning', 6000);
                    return;
                }

                // âœ…âœ… æ–°å¢ï¼šé©—è­‰å±€é¢æ˜¯å¦æœ‰è§£
                console.log('ğŸ” æ­£åœ¨åˆ†æå±€é¢æ˜¯å¦æœ‰è§£...');

                const piecesToAnalyze = validPieces.map(p => ({
                    shape: p.s || p.shape,
                    color: p.color
                }));

                console.log('ğŸ“Š æº–å‚™åˆ†æçš„æ–¹å¡Š:', piecesToAnalyze);

                const solution = performInitialStateAIAnalysis(editBoardState, piecesToAnalyze);

                if (!solution || solution.length === 0) {
                    showNotification(
                        'å±€é¢ç„¡è§£ï¼\n\n' +
                        'æ­¤å±€é¢ç„¡è«–å¦‚ä½•æ“ºæ”¾é€™äº›æ–¹å¡Šéƒ½ç„¡æ³•ç¹¼çºŒéŠæˆ²ã€‚\n\n' +
                        'è«‹èª¿æ•´æ£‹ç›¤æˆ–æ›´æ›é é¸æ–¹å¡Šå¾Œå†è©¦ã€‚',
                        'warning',
                        6000
                    );
                    console.log('âŒ å±€é¢ç„¡è§£ï¼Œå·²æ‹’çµ•å°å…¥');
                    return;
                }

                console.log('âœ… å±€é¢æœ‰è§£ï¼Œå¯ä»¥å°å…¥');
                // âœ…âœ… é©—è­‰çµæŸ

                // å¥—ç”¨åˆ°ä¸»æ£‹ç›¤
                boardState = editBoardState.map(row => [...row]);

                Array.from(boardElement.children).forEach((cell, idx) => {
                    const r = Math.floor(idx / 8);
                    const c = idx % 8;

                    if (boardState[r][c]) {
                        cell.classList.add('filled');
                        cell.style.backgroundColor = editBoardColors[r][c] || '#81c784';
                    } else {
                        cell.classList.remove('filled');
                        cell.style.backgroundColor = '';
                    }
                });

                // âœ…âœ… ä¿å­˜ç·¨è¼¯å¾Œçš„æ£‹ç›¤ç‹€æ…‹ï¼ˆé‡è¦ï¼ï¼‰
                window.initialBoardState = boardState.map(row => [...row]);
                console.log('ğŸ’¾ å·²ä¿å­˜ç·¨è¼¯å¾Œçš„æ£‹ç›¤ç‹€æ…‹');

                // å¥—ç”¨æ–¹å¡Šåˆ°é å‚™å€
                piecesArea.innerHTML = '';

                // âœ… ä½¿ç”¨æ–°çš„æ‹–æ›³ç³»çµ±æ¸²æŸ“æ–¹å¡Š
                editPieces.forEach(shapeObj => {
                    if (!shapeObj) return;

                    const container = document.createElement('div');
                    container.className = 'piece-container';

                    container.dataset.shape = JSON.stringify(shapeObj.s);

                    const width = shapeObj.s[0].length * 45;
                    const height = shapeObj.s.length * 45;
                    container.style.width = width + 'px';
                    container.style.height = height + 'px';

                    shapeObj.s.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            if (cell) {
                                const div = document.createElement('div');
                                div.className = 'p-cell filled';
                                div.style.backgroundColor = shapeObj.color;
                                div.style.left = (c * 45) + 'px';
                                div.style.top = (r * 45) + 'px';
                                container.appendChild(div);
                            }
                        });
                    });

                    setupPieceDragging(container, shapeObj);

                    piecesArea.appendChild(container);
                });

                // âœ… ä¿å­˜ç•¶å‰æ–¹å¡Šè³‡æ–™
                window.currentRoundPieces = editPieces
                    .filter(p => p !== null)
                    .map(p => ({
                        shape: JSON.parse(JSON.stringify(p.s)),
                        color: p.color
                    }));
                console.log('ğŸ’¾ å·²ä¿å­˜ç·¨è¼¯å¾Œçš„æ–¹å¡Š:', window.currentRoundPieces);

                // âœ… æ¸…ç©ºæœ¬å›åˆçš„æ”¾ç½®è¨˜éŒ„
                window.currentRoundPlacements = [];

                showNotification('å±€é¢å·²æˆåŠŸå¥—ç”¨ï¼', 'success');
                overlay.remove();
                dialog.remove();
                style.remove();
            });

        // åˆå§‹æ›´æ–° BFEN
        updateBFENOutput();
    }
    }


    // ç·¨è¼¯å±€é¢ç³»çµ±
    function addEditButton() {
        const undoButton = document.querySelector('button');
        const buttonContainer = undoButton.parentElement;

        const editButton = document.createElement('button');
        editButton.textContent = 'âœï¸ ç·¨è¼¯å±€é¢';
        editButton.style.cssText = `
        padding: 12px 20px;
        background-color: #9C27B0;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
    `;

        editButton.addEventListener('click', openEditDialog);
        buttonContainer.appendChild(editButton);

        function openEditDialog() {
            // å‰µå»ºé®ç½©
            const overlay = document.createElement('div');
            overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        `;

            // å‰µå»ºå°è©±æ¡†
            const dialog = document.createElement('div');
            dialog.id = 'edit-dialog';
            dialog.innerHTML = `
    <h2 style="margin-top: 0; color: white; text-align: center;">ç·¨è¼¯å±€é¢</h2>

    <!-- BFEN åŒ¯å…¥/åŒ¯å‡ºå€åŸŸ -->
    <div style="margin-bottom: 20px; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
            <input type="text" id="bfen-input" placeholder="è¼¸å…¥ BFEN ç¢¼ï¼ˆä¾‹å¦‚ï¼š8/8/8/3x4/3x4/8/8/8 3h,4s,5vï¼‰"
                style="flex: 1; padding: 8px; border-radius: 4px; border: 2px solid #4e342e; font-size: 12px; font-family: monospace;">
            <button id="import-bfen" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                ğŸ“¥ åŒ¯å…¥
            </button>
        </div>
        <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="bfen-output" readonly placeholder="ç›®å‰å±€é¢çš„ BFEN ç¢¼æœƒé¡¯ç¤ºåœ¨é€™è£¡"
                style="flex: 1; padding: 8px; border-radius: 4px; border: 2px solid #4e342e; font-size: 12px; font-family: monospace; background: rgba(255,255,255,0.8);">
            <button id="copy-bfen" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                ğŸ“‹ è¤‡è£½
            </button>
        </div>
        <div style="margin-top: 8px; font-size: 11px; color: #fff; opacity: 0.8;">
          ğŸ’¡ æç¤ºï¼šæ ¼å¼ç‚º ç‹€æ…‹+æ•¸é‡ï¼Œé€—è™Ÿåˆ†éš”ï¼ˆå¦‚ 05,11,02 = 5ç©º+1æ»¿+2ç©ºï¼‰ï¼Œæ–œç·šåˆ†éš”è¡Œï¼Œç©ºæ ¼åˆ†éš”æ£‹ç›¤èˆ‡æ–¹å¡Š
        </div>
    </div>

    <!-- ç·¨è¼¯æ£‹ç›¤ -->
    <div id="edit-board"></div>

    <!-- ä¸‰å€‹æ–¹å¡Šé å‚™ä½ -->
    <div id="edit-pieces-slots">
        <div class="edit-piece-slot" data-slot="0"></div>
        <div class="edit-piece-slot" data-slot="1"></div>
        <div class="edit-piece-slot" data-slot="2"></div>
    </div>

    <!-- æœå°‹æ–¹å¡Š -->
    <input type="text" id="shape-search" placeholder="æœå°‹æ–¹å¡Šåç¨±ï¼ˆä¾‹å¦‚ï¼šæ©«ä¸‰ã€Lå­—ã€ç”°å­—ï¼‰">
    <div id="shape-list"></div>

    <!-- æŒ‰éˆ• -->
    <div class="edit-buttons">
        <button id="apply-edit" style="background: #4CAF50;">âœ“ å¥—ç”¨å±€é¢</button>
        <button id="clear-edit" style="background: #FF9800;">âŸ² æ¸…ç©ºæ£‹ç›¤</button>
        <button id="cancel-edit" style="background: #F44336;">âœ• å–æ¶ˆ</button>
    </div>
`;

            // åŠ å…¥æ¨£å¼
            const style = document.createElement('style');
            style.textContent = `
            #edit-dialog {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #8d6e63;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                z-index: 1000;
                max-width: 600px;
                max-height: 90vh;
                overflow-y: auto;
            }
          #edit-board {
    display: grid;
    grid-template-columns: repeat(8, 40px);
    grid-template-rows: repeat(8, 40px);
    gap: 2px;
    background: #5d4037;
    padding: 10px;
    border-radius: 8px;
    border: 5px solid #4e342e;
    margin: 0 auto 20px auto;
    width: fit-content;
}
            .edit-cell {
                width: 40px;
                height: 40px;
                background: #4e342e;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s;
            }
            .edit-cell:hover {
                opacity: 0.8;
            }
            .edit-cell.filled {
                background: #81c784;
                box-shadow: inset 3px 3px 0 rgba(255,255,255,0.4), inset -3px -3px 0 rgba(0,0,0,0.2);
            }
            .edit-cell.user-placed {
                background: #ffd54f;
                box-shadow: inset 3px 3px 0 rgba(255,255,255,0.4), inset -3px -3px 0 rgba(0,0,0,0.2);
            }
            #edit-pieces-slots {
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-bottom: 20px;
                min-height: 120px;
            }
          .edit-piece-slot {
    width: 120px;
    height: 120px;
    border: 3px dashed #4e342e;
    border-radius: 8px;
    position: relative;
    background: rgba(255,255,255,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}
            .edit-piece-slot.has-piece {
                border-style: solid;
                border-color: #66bb6a;
            }
          .slot-piece-container {
    position: relative;
    transform: scale(0.5);
    transform-origin: center;
}
            .slot-p-cell {
                width: 40px;
                height: 40px;
                border-radius: 4px;
                position: absolute;
                cursor: pointer;
            }
            #shape-search {
                width: 100%;
                padding: 10px;
                margin-bottom: 10px;
                border-radius: 5px;
                border: 2px solid #4e342e;
                font-size: 14px;
                box-sizing: border-box;
            }
            #shape-list {
                max-height: 150px;
                overflow-y: auto;
                background: rgba(255,255,255,0.9);
                border-radius: 5px;
                margin-bottom: 20px;
            }
            .shape-item {
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #ddd;
                transition: background 0.2s;
            }
            .shape-item:hover {
                background: #e3f2fd;
            }
            .edit-buttons {
                display: flex;
                gap: 10px;
                justify-content: center;
            }
            .edit-buttons button {
                padding: 12px 24px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                color: white;
            }
        `;
            document.head.appendChild(style);

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            // åˆå§‹åŒ–ç·¨è¼¯æ£‹ç›¤
            let editBoardState = Array(8).fill().map(() => Array(8).fill(0));
            let editBoardColors = Array(8).fill().map(() => Array(8).fill(null));
            let selectedShape = null; // â† å…ˆå®£å‘Šé€™å€‹è®Šæ•¸

// è¤‡è£½ç•¶å‰é é¸æ–¹å¡Š
            // è¤‡è£½ç•¶å‰é é¸æ–¹å¡Š
            let editPieces = [null, null, null];
            const currentPieces = getCurrentPieces();
            currentPieces.forEach((piece, index) => {
                if (index < 3 && piece && piece.s) { // â† åŠ ä¸Š && piece.s æª¢æŸ¥
                    editPieces[index] = cloneShape(piece);
                }
            });

            const editBoard = document.getElementById('edit-board');
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'edit-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    // è¤‡è£½ç•¶å‰æ£‹ç›¤ç‹€æ…‹
                    if (boardState[r][c]) {
                        editBoardState[r][c] = 1;
                        cell.classList.add('filled');
                        const mainCell = boardElement.children[r * 8 + c];
                        const color = mainCell.style.backgroundColor || '#81c784';
                        cell.style.backgroundColor = color;
                        editBoardColors[r][c] = color;
                    }

                    cell.addEventListener('click', function(e) {
                        // å¦‚æœæ­£åœ¨æ”¾ç½®æ–¹å¡Šæ¨¡å¼ï¼Œä¸åŸ·è¡Œåˆ‡æ›
                        if (selectedShape) {
                            return;
                        }

                        const row = parseInt(this.dataset.row);
                        const col = parseInt(this.dataset.col);

                        if (editBoardState[row][col]) {
                            // å·²å¡«å…… â†’ æ¸…ç©º
                            editBoardState[row][col] = 0;
                            editBoardColors[row][col] = null;
                            this.classList.remove('filled', 'user-placed');
                            this.style.backgroundColor = '';
                        } else {
                            // ç©ºç™½ â†’ å¡«å……é»ƒè‰²
                            editBoardState[row][col] = 1;
                            editBoardColors[row][col] = '#ffd54f';
                            this.classList.add('user-placed');
                            this.style.backgroundColor = '#ffd54f';
                        }

                        updateBFENOutput();
                    });

                    editBoard.appendChild(cell);
                }
            }

            // æ¸²æŸ“é é¸æ–¹å¡Š
            editPieces.forEach((shapeObj, slotIndex) => {
                if (!shapeObj || !shapeObj.s) return;

                const slot = document.querySelector(`.edit-piece-slot[data-slot="${slotIndex}"]`);
                if (!slot) return;

                const container = document.createElement('div');
                container.className = 'slot-piece-container';

                const width = shapeObj.s[0].length * 40;
                const height = shapeObj.s.length * 40;
                const maxDimension = Math.max(width, height);

                // âœ… å‹•æ…‹ç²å– slot å°ºå¯¸
                const slotSize = slot.offsetWidth || 120;
                let scale = maxDimension > slotSize * 0.8 ? (slotSize * 0.8) / maxDimension : 1;

                container.style.cssText = `
        position: absolute;
        left: 50%;
        top: 50%;
        width: ${width}px;
        height: ${height}px;
        transform: translate(-50%, -50%) scale(${scale});
        transform-origin: center;
    `;

                shapeObj.s.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const div = document.createElement('div');
                            div.className = 'slot-p-cell filled';
                            div.style.cssText = `
                    position: absolute;
                    width: 40px;
                    height: 40px;
                    background-color: ${shapeObj.color};
                    left: ${c * 40}px;
                    top: ${r * 40}px;
                    border-radius: 4px;
                `;
                            container.appendChild(div);
                        }
                    });
                });

                slot.appendChild(container);
                slot.classList.add('has-piece');
            });

// æœå°‹åŠŸèƒ½ - åˆå§‹é¡¯ç¤ºæ‰€æœ‰æ–¹å¡Š

            // æœå°‹åŠŸèƒ½
            const searchInput = document.getElementById('shape-search');
            const shapeList = document.getElementById('shape-list');

// åœ¨ "å–æ¶ˆ" æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨ä¹‹å¾ŒåŠ å…¥

// æ›´æ–° BFEN è¼¸å‡ºï¼ˆæ¯æ¬¡æ£‹ç›¤æˆ–æ–¹å¡Šè®ŠåŒ–æ™‚èª¿ç”¨ï¼‰
            function updateBFENOutput() {
                const bfenOutput = document.getElementById('bfen-output');
                bfenOutput.value = encodeBFEN(editBoardState, editPieces);
            }

// åŒ¯å…¥ BFEN
            document.getElementById('import-bfen').addEventListener('click', function() {
                const bfenInput = document.getElementById('bfen-input');
                const bfen = bfenInput.value.trim();

                if (!bfen) {
                    showNotification('è«‹è¼¸å…¥ BFEN ç¢¼', 'warning');
                    return;
                }

                try {
                    const decoded = decodeBFEN(bfen);

                    // å¥—ç”¨æ£‹ç›¤ç‹€æ…‹
                    editBoardState = decoded.boardState;
                    editBoardColors = decoded.boardColors;

                    // æ›´æ–°æ£‹ç›¤é¡¯ç¤º
                    Array.from(editBoard.children).forEach((cell, idx) => {
                        const r = Math.floor(idx / 8);
                        const c = idx % 8;

                        if (editBoardState[r][c]) {
                            cell.classList.add('filled', 'user-placed');  // â† åŠ ä¸Š 'filled'
                            cell.style.backgroundColor = editBoardColors[r][c] || '#ffd54f';
                        } else {
                            cell.classList.remove('filled', 'user-placed');
                            cell.style.backgroundColor = '';
                        }
                    });

                    // å¥—ç”¨æ–¹å¡Š
                    editPieces = decoded.pieces;

                    document.querySelectorAll('.edit-piece-slot').forEach((slot, slotIndex) => {
                        slot.innerHTML = '';
                        slot.classList.remove('has-piece');

                        const shapeObj = editPieces[slotIndex];
                        if (shapeObj && shapeObj.s) {
                            const container = document.createElement('div');
                            container.className = 'slot-piece-container';

                            const width = shapeObj.s[0].length * 40;
                            const height = shapeObj.s.length * 40;
                            const maxDimension = Math.max(width, height);

                            // âœ… å‹•æ…‹ç²å– slot å°ºå¯¸
                            const slotSize = slot.offsetWidth || 120;
                            let scale = maxDimension > slotSize * 0.8 ? (slotSize * 0.8) / maxDimension : 1;

                            container.style.cssText = `
            position: absolute;
            left: 50%;
            top: 50%;
            width: ${width}px;
            height: ${height}px;
            transform: translate(-50%, -50%) scale(${scale});
            transform-origin: center;
        `;

                            shapeObj.s.forEach((row, r) => {
                                row.forEach((cell, c) => {
                                    if (cell) {
                                        const div = document.createElement('div');
                                        div.className = 'slot-p-cell filled';
                                        div.style.cssText = `
                        position: absolute;
                        width: 40px;
                        height: 40px;
                        background-color: ${shapeObj.color};
                        left: ${c * 40}px;
                        top: ${r * 40}px;
                        border-radius: 4px;
                    `;
                                        container.appendChild(div);
                                    }
                                });
                            });

                            slot.appendChild(container);
                            slot.classList.add('has-piece');
                        }
                    });

                    updateBFENOutput();
                    showNotification('BFEN ç¢¼åŒ¯å…¥æˆåŠŸï¼', 'success');

                } catch (error) {
                    showNotification(error.message, 'error');
                }
            });

// è¤‡è£½ BFEN
            document.getElementById('copy-bfen').addEventListener('click', function() {
                const bfenOutput = document.getElementById('bfen-output');
                if (!bfenOutput.value) {
                    updateBFENOutput();
                }

                bfenOutput.select();
                document.execCommand('copy');

                this.textContent = 'âœ… å·²è¤‡è£½';
                setTimeout(() => {
                    this.textContent = 'ğŸ“‹ è¤‡è£½';
                }, 2000);
            });

// åˆå§‹æ›´æ–° BFEN è¼¸å‡º
            updateBFENOutput();

            function updateShapeList(keyword = '') {
                shapeList.innerHTML = '';

                const filtered = keyword === ''
                    ? allShapes
                    : allShapes.filter(s => s.name.toLowerCase().includes(keyword.toLowerCase()));

                filtered.forEach(shape => {
                    const item = document.createElement('div');
                    item.className = 'shape-item';
                    item.style.display = 'flex';
                    item.style.alignItems = 'center';
                    item.style.gap = '15px';
                    item.style.padding = '10px 12px';

                    // å‰µå»ºæ–¹å¡Šé è¦½
                    const preview = document.createElement('div');
                    preview.style.position = 'relative';
                    preview.style.display = 'inline-block';

                    const maxSize = Math.max(shape.s.length, shape.s[0].length);
                    const cellSize = 20; // é è¦½æ ¼å­å¤§å°
                    preview.style.width = (shape.s[0].length * cellSize) + 'px';
                    preview.style.height = (shape.s.length * cellSize) + 'px';

                    shape.s.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            if (cell) {
                                const div = document.createElement('div');
                                div.style.position = 'absolute';
                                div.style.width = cellSize + 'px';
                                div.style.height = cellSize + 'px';
                                div.style.backgroundColor = shape.color;
                                div.style.left = (c * cellSize) + 'px';
                                div.style.top = (r * cellSize) + 'px';
                                div.style.borderRadius = '2px';
                                div.style.boxShadow = 'inset 2px 2px 0 rgba(255,255,255,0.4), inset -2px -2px 0 rgba(0,0,0,0.2)';
                                preview.appendChild(div);
                            }
                        });
                    });

                    // æ–¹å¡Šåç¨±
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = shape.name;
                    nameSpan.style.color = '#333';
                    nameSpan.style.fontWeight = 'bold';
                    nameSpan.style.flex = '1';

                    item.appendChild(preview);
                    item.appendChild(nameSpan);

                    item.addEventListener('click', function() {
                        selectedShape = cloneShape(shape);
                        searchInput.value = `å·²é¸æ“‡ï¼š${shape.name}ï¼ˆè«‹é»æ“Šé å‚™ä½æˆ–æ£‹ç›¤æ ¼å­æ”¾ç½®ï¼‰`;
                        enableShapePlacement();
                    });

                    shapeList.appendChild(item);
                });
            }

// åˆå§‹é¡¯ç¤ºæ‰€æœ‰æ–¹å¡Š
            updateShapeList();

            searchInput.addEventListener('input', function() {
                const keyword = this.value.trim();
                if (keyword.startsWith('å·²é¸æ“‡ï¼š')) return; // é¿å…æ¸…é™¤é¸æ“‡æç¤º
                updateShapeList(keyword);
            });

            // å•Ÿç”¨æ–¹å¡Šæ”¾ç½®åŠŸèƒ½
            function enableShapePlacement() {
                if (!selectedShape) return;

                // é»æ“Šé å‚™ä½æ”¾ç½®
                document.querySelectorAll('.edit-piece-slot').forEach(slot => {
                    slot.style.cursor = 'pointer';
                    slot.style.border = '3px solid #4CAF50';

                    const slotClickHandler = function() {
                        if (!selectedShape) return;

                        const slotIndex = parseInt(this.dataset.slot);
                        this.innerHTML = '';

                        const container = document.createElement('div');
                        container.className = 'slot-piece-container';

                        const width = selectedShape.s[0].length * 40;
                        const height = selectedShape.s.length * 40;
                        const maxDimension = Math.max(width, height);

                        // âœ… å‹•æ…‹ç²å– slot å°ºå¯¸
                        const slotSize = this.offsetWidth || 120;
                        let scale = maxDimension > slotSize * 0.8 ? (slotSize * 0.8) / maxDimension : 1;

                        container.style.cssText = `
        position: absolute;
        left: 50%;
        top: 50%;
        width: ${width}px;
        height: ${height}px;
        transform: translate(-50%, -50%) scale(${scale});
        transform-origin: center;
    `;

                        selectedShape.s.forEach((row, r) => {
                            row.forEach((cell, c) => {
                                if (cell) {
                                    const div = document.createElement('div');
                                    div.className = 'slot-p-cell filled';
                                    div.style.cssText = `
                    position: absolute;
                    width: 40px;
                    height: 40px;
                    background-color: ${selectedShape.color};
                    left: ${c * 40}px;
                    top: ${r * 40}px;
                    border-radius: 4px;
                `;
                                    container.appendChild(div);
                                }
                            });
                        });

                        this.appendChild(container);
                        this.classList.add('has-piece');
                        editPieces[slotIndex] = cloneShape(selectedShape);

                        updateBFENOutput();
                        resetShapeSelection();
                    };

                    slot.removeEventListener('click', slotClickHandler);
                    slot.addEventListener('click', slotClickHandler);
                });

                // é»æ“Šæ£‹ç›¤æ ¼å­æ”¾ç½®æ–¹å¡Š
                // é»æ“Šæ£‹ç›¤æ ¼å­æ”¾ç½®æ–¹å¡Š
                Array.from(editBoard.children).forEach(cell => {
                    cell.style.cursor = 'crosshair';
                    cell.style.border = '2px solid #4CAF50';

                    const cellClickHandler = function(e) {
                        e.stopPropagation(); // é˜²æ­¢äº‹ä»¶å†’æ³¡

                        if (!selectedShape) return;

                        const r = parseInt(this.dataset.row);
                        const c = parseInt(this.dataset.col);

                        // æª¢æŸ¥æ˜¯å¦èƒ½æ”¾ç½®
                        if (canPlaceOnBoard(selectedShape.s, r, c, editBoardState)) {
                            // æ”¾ç½®æ–¹å¡Š
                            selectedShape.s.forEach((row, i) => {
                                row.forEach((val, j) => {
                                    if (val) {
                                        editBoardState[r + i][c + j] = 1;
                                        editBoardColors[r + i][c + j] = selectedShape.color;
                                        const targetCell = editBoard.children[(r + i) * 8 + (c + j)];
                                        targetCell.classList.add('filled');
                                        targetCell.style.backgroundColor = selectedShape.color;
                                    }
                                });
                            });
                            updateBFENOutput();
                            // é‡ç½®
                            resetShapeSelection();
                        } else {
                            showNotification('ç„¡æ³•åœ¨æ­¤ä½ç½®æ”¾ç½®æ–¹å¡Šï¼', 'error');
                        }
                    };

                    // ä½¿ç”¨ once: falseï¼Œä½†æ‰‹å‹•ç§»é™¤
                    cell.dataset.hasShapeHandler = 'true';
                    cell.addEventListener('click', cellClickHandler);
                });

                function resetShapeSelection() {
                    selectedShape = null;
                    searchInput.value = '';
                    updateShapeList();

                    document.querySelectorAll('.edit-piece-slot').forEach(s => {
                        s.style.cursor = '';
                        s.style.border = '3px dashed #4e342e';
                        if (s.classList.contains('has-piece')) {
                            s.style.border = '3px solid #66bb6a';
                        }
                    });

                    // ç§»é™¤æ‰€æœ‰æ–¹å¡Šæ”¾ç½®è™•ç†å™¨
                    Array.from(editBoard.children).forEach(cell => {
                        cell.style.cursor = 'pointer';
                        cell.style.border = '';
                        if (cell.dataset.hasShapeHandler) {
                            // å‰µå»ºæ–°å…ƒç´ æ›¿æ›èˆŠçš„ï¼ˆç§»é™¤æ‰€æœ‰äº‹ä»¶ç›£è½å™¨ï¼‰
                            const newCell = cell.cloneNode(true);
                            cell.parentNode.replaceChild(newCell, cell);

                            // é‡æ–°ç¶å®šåŸæœ¬çš„åˆ‡æ›äº‹ä»¶
                            newCell.addEventListener('click', function(e) {
                                if (selectedShape) return;

                                const row = parseInt(this.dataset.row);
                                const col = parseInt(this.dataset.col);

                                if (editBoardState[row][col]) {
                                    editBoardState[row][col] = 0;
                                    editBoardColors[row][col] = null;
                                    this.classList.remove('filled', 'user-placed');
                                    this.style.backgroundColor = '';
                                } else {
                                    editBoardState[row][col] = 1;
                                    editBoardColors[row][col] = '#ffd54f';
                                    this.classList.add('user-placed');
                                    this.style.backgroundColor = '#ffd54f';
                                }

                                updateBFENOutput();

                            });
                        }
                    });
                }
            }

            // æ¸…ç©ºæ£‹ç›¤
            document.getElementById('clear-edit').addEventListener('click', function() {
                showConfirmDialog('ç¢ºå®šè¦æ¸…ç©ºæ•´å€‹æ£‹ç›¤å—ï¼Ÿ', () => {
                    editBoardState = Array(8).fill().map(() => Array(8).fill(0));
                    editBoardColors = Array(8).fill().map(() => Array(8).fill(null));

                    Array.from(editBoard.children).forEach(cell => {
                        cell.classList.remove('filled', 'user-placed');
                        cell.style.backgroundColor = '';
                    });
                    updateBFENOutput();
                });
            });

            // å–æ¶ˆ
            document.getElementById('cancel-edit').addEventListener('click', function() {
                overlay.remove();
                dialog.remove();
                style.remove();
            });

            overlay.addEventListener('click', function() {
                overlay.remove();
                dialog.remove();
                style.remove();
            });

            // å¥—ç”¨å±€é¢
            document.getElementById('apply-edit').addEventListener('click', function() {
                // é©—è­‰1ï¼šæª¢æŸ¥é é¸æ–¹å¡Šï¼ˆè‡³å°‘è¦æœ‰ä¸€å€‹ï¼‰
                const validPieces = editPieces.filter(p => p !== null);
                if (validPieces.length === 0) {
                    showNotification('å±€é¢ä¸åˆæ³•ï¼\n\nè‡³å°‘éœ€è¦è¨­å®šä¸€å€‹é é¸æ–¹å¡Šï¼Œå¦å‰‡éŠæˆ²ç„¡æ³•ç¹¼çºŒã€‚', 'warning', 5000);
                    return;
                }

                // é©—è­‰2ï¼šæª¢æŸ¥æ˜¯å¦æœ‰æ»¿è¡Œæˆ–æ»¿åˆ—
                let hasFullRow = false;
                let hasFullCol = false;
                let fullRowIndices = [];
                let fullColIndices = [];

                for (let r = 0; r < 8; r++) {
                    if (editBoardState[r].every(v => v)) {
                        hasFullRow = true;
                        fullRowIndices.push(r + 1);
                    }
                }

                for (let c = 0; c < 8; c++) {
                    if (editBoardState.every(row => row[c])) {
                        hasFullCol = true;
                        fullColIndices.push(String.fromCharCode(65 + c));
                    }
                }

                if (hasFullRow || hasFullCol) {
                    let message = 'å±€é¢ä¸åˆæ³•ï¼\n\næ£‹ç›¤ä¸­å­˜åœ¨æ»¿è¡Œæˆ–æ»¿åˆ—ï¼Œé€™æœƒå°è‡´è‡ªå‹•æ¶ˆé™¤ã€‚\n\n';
                    if (hasFullRow) {
                        message += `æ»¿è¡Œï¼šç¬¬ ${fullRowIndices.join(', ')} è¡Œ\n`;
                    }
                    if (hasFullCol) {
                        message += `æ»¿åˆ—ï¼šç¬¬ ${fullColIndices.join(', ')} åˆ—\n`;
                    }
                    message += '\nè«‹èª¿æ•´å¾Œå†å¥—ç”¨ã€‚';
                    showNotification(message, 'warning', 6000);
                    return;
                }

                // é©—è­‰3ï¼šæª¢æŸ¥å±€é¢æ˜¯å¦æœ‰è§£
                console.log('ğŸ” æ­£åœ¨åˆ†æå±€é¢æ˜¯å¦æœ‰è§£...');

                // æº–å‚™è¦åˆ†æçš„æ–¹å¡Šæ•¸æ“š - ä¿®æ­£é€™è£¡
                const piecesToAnalyze = validPieces.map(p => ({
                    shape: p.s || p.shape,  // å…¼å®¹å…©ç¨®æ ¼å¼
                    color: p.color
                }));

                console.log('ğŸ“Š æº–å‚™åˆ†æçš„æ–¹å¡Š:', piecesToAnalyze);

                // èª¿ç”¨éœé»˜åˆ†æå‡½æ•¸
                const solution = performInitialStateAIAnalysis(editBoardState, piecesToAnalyze);

                if (!solution || solution.length === 0) {
                    showNotification(
                        'å±€é¢ç„¡è§£ï¼\n\n' +
                        'æ­¤å±€é¢ç„¡è«–å¦‚ä½•æ“ºæ”¾é€™äº›æ–¹å¡Šéƒ½ç„¡æ³•ç¹¼çºŒéŠæˆ²ã€‚\n\n' +
                        'è«‹èª¿æ•´æ£‹ç›¤æˆ–æ›´æ›é é¸æ–¹å¡Šå¾Œå†è©¦ã€‚',
                        'warning',
                        6000
                    );
                    console.log('âŒ å±€é¢ç„¡è§£ï¼Œå·²æ‹’çµ•å°å…¥');
                    return;
                }

                console.log('âœ… å±€é¢æœ‰è§£ï¼Œå¯ä»¥å°å…¥');

                // å¥—ç”¨åˆ°ä¸»æ£‹ç›¤
                boardState = editBoardState.map(row => [...row]);

                // æ›´æ–°é¡¯ç¤º
                const cells = boardElement.children;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const idx = r * 8 + c;
                        if (boardState[r][c]) {
                            cells[idx].classList.add('filled');
                            cells[idx].style.backgroundColor = editBoardColors[r][c] || '#81c784';
                        } else {
                            cells[idx].classList.remove('filled');
                            cells[idx].style.backgroundColor = '';
                        }
                    }
                }

                // å¥—ç”¨é é¸æ–¹å¡Š
                piecesArea.innerHTML = '';

                validPieces.forEach((pieceData, index) => {
                    const container = document.createElement('div');
                    container.className = 'piece-container';

                    // ç²å–æ­£ç¢ºçš„ shape æ•¸æ“š
                    const shapeData = pieceData.s || pieceData.shape;
                    container.dataset.shape = JSON.stringify(shapeData);

                    const width = shapeData[0].length * 45;
                    const height = shapeData.length * 45;
                    container.style.width = width + 'px';
                    container.style.height = height + 'px';

                    shapeData.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            if (cell) {
                                const div = document.createElement('div');
                                div.className = 'p-cell filled';
                                div.style.backgroundColor = pieceData.color;
                                div.style.left = (c * 45) + 'px';
                                div.style.top = (r * 45) + 'px';
                                container.appendChild(div);
                            }
                        });
                    });

                    // ç‚º setupPieceDragging æº–å‚™æ­£ç¢ºæ ¼å¼çš„æ•¸æ“š
                    const shapeObj = {
                        s: shapeData,
                        color: pieceData.color
                    };

                    if (typeof setupPieceDragging === 'function') {
                        setupPieceDragging(container, shapeObj);
                    }

                    piecesArea.appendChild(container);
                });

                // ä¿å­˜åˆå§‹ç‹€æ…‹å’Œæ–¹å¡Šï¼ˆé‡è¦ï¼ï¼‰
                window.initialBoardState = boardState.map(row => [...row]);
                window.currentRoundPieces = validPieces.map(p => ({
                    shape: JSON.parse(JSON.stringify(p.s || p.shape)),
                    color: p.color
                }));
                window.currentRoundPlacements = [];

                console.log('âœ… å±€é¢å·²å¥—ç”¨');
                console.log('ğŸ“Š åˆå§‹æ£‹ç›¤:', window.initialBoardState);
                console.log('ğŸ“Š ç•¶å‰æ–¹å¡Š:', window.currentRoundPieces);

// âœ… ä½¿ç”¨æ­£ç¢ºçš„é¸æ“‡å™¨
                const overlayEl = overlay;  // ç›´æ¥ä½¿ç”¨å¤–å±¤ä½œç”¨åŸŸçš„è®Šé‡
                const dialogEl = dialog;
                const styleEl = style;

                overlayEl.remove();
                dialogEl.remove();
                styleEl.remove();

                showNotification('å±€é¢å·²æˆåŠŸå¥—ç”¨ï¼', 'success');
            });
        }
    }

    function addAIAnalysisButton() {
        // å…ˆç¢ºèªå¿…è¦çš„å…¨åŸŸè®Šæ•¸æ˜¯å¦å­˜åœ¨
        if (typeof boardElement === 'undefined' || typeof boardState === 'undefined') {
            console.error('ç¼ºå°‘å¿…è¦è®Šæ•¸: boardElement æˆ– boardState');
            return;
        }

        const style = document.createElement('style');
        style.textContent = `
   /* AI æç¤ºé‚Šæ¡† - é è¨­å–®ä¸€é¡è‰² */
.hint-step-1 {
    box-shadow: inset 0 0 0 4px #00FF00, inset 0 0 10px #00FF00 !important;
    z-index: 10;
}

.hint-step-2 {
    box-shadow: inset 0 0 0 4px #FF0000, inset 0 0 10px #FF0000 !important;
    z-index: 10;
}

.hint-step-3 {
    box-shadow: inset 0 0 0 4px #0000FF, inset 0 0 10px #0000FF !important;
    z-index: 10;
}

/* åªæœ‰ç•¶æ ¼å­åŒæ™‚æœ‰å¤šå€‹ class æ™‚æ‰é¡¯ç¤ºå¤šé‡é‚Šæ¡† */
.hint-step-1.hint-step-2 {
    box-shadow: inset 0 0 0 4px #00FF00, inset 0 0 0 8px #FF0000, inset 0 0 10px #FF0000 !important;
}

.hint-step-1.hint-step-3 {
    box-shadow: inset 0 0 0 4px #00FF00, inset 0 0 0 8px #0000FF, inset 0 0 10px #0000FF !important;
}

.hint-step-2.hint-step-3 {
    box-shadow: inset 0 0 0 4px #FF0000, inset 0 0 0 8px #0000FF, inset 0 0 10px #0000FF !important;
}

.hint-step-1.hint-step-2.hint-step-3 {
    box-shadow: inset 0 0 0 4px #00FF00, inset 0 0 0 8px #FF0000, inset 0 0 0 12px #0000FF, inset 0 0 10px #0000FF !important;
}

  /* AI åˆ†æé¢æ¿ - ç¸®å°ç‰ˆ + å¯æ‹–æ›³ */
#ai-analysis-panel {
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.5);
    z-index: 2000;
    max-width: 280px;
    max-height: 70vh;
    overflow-y: auto;
    font-family: 'Arial', sans-serif;
    animation: slideInRight 0.3s ease-out;
    cursor: grab;
    user-select: none;
}

#ai-analysis-panel:active {
    cursor: grabbing;
}

#ai-analysis-panel h2 {
    margin: 0 0 12px 0;
    font-size: 16px;
    text-align: left;
}

/* åˆ†ææ­¥é©Ÿ */
.analysis-step {
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(255,255,255,0.15);
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 10px;
}

.step-number {
    font-size: 20px;
    font-weight: bold;
    min-width: 30px;
    text-align: center;
    flex-shrink: 0;
}

.step-preview {
    display: grid;
    gap: 2px;
    flex-shrink: 0;
}

.step-preview-cell {
    width: 15px;
    height: 15px;
    border-radius: 2px;
    border: 1px solid rgba(255,255,255,0.3);
}

.step-info {
    flex: 1;
    line-height: 1.4;
    font-size: 12px;
}

/* é—œé–‰æŒ‰éˆ• */
#close-analysis-btn {
    width: 100%;
    padding: 10px;
    background: rgba(255,255,255,0.25);
    border: 2px solid rgba(255,255,255,0.4);
    color: white;
    border-radius: 8px;
    font-size: 13px;
    font-weight: bold;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.2s;
}

#close-analysis-btn:hover {
    background: rgba(255,255,255,0.35);
    transform: scale(1.02);
}

/* AI ç®­é ­æç¤º */
.ai-arrow {
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    text-shadow: 2px 2px 4px #000;
    pointer-events: none;
    animation: aiBounce 0.5s infinite alternate;
    z-index: 100;
}

@keyframes aiBounce {
    from { transform: translateX(-50%) translateY(0); }
    to { transform: translateX(-50%) translateY(-8px); }
}

/* æ»‘å…¥å‹•ç•« */
@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(50px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* ========================================
   ğŸ“± æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼
   ======================================== */
@media (max-width: 768px) {
    #ai-analysis-panel {
        top: 10px;
        right: 10px;
        max-width: 220px;
        padding: 12px;
        max-height: 60vh;
    }

    #ai-analysis-panel h2 {
        font-size: 14px;
        margin-bottom: 10px;
    }

    .analysis-step {
        padding: 8px;
        gap: 8px;
        margin-bottom: 8px;
    }

    .step-number {
        font-size: 18px;
        min-width: 25px;
    }

    .step-preview-cell {
        width: 12px;
        height: 12px;
    }

    .step-info {
        font-size: 11px;
    }

    #close-analysis-btn {
        padding: 8px;
        font-size: 12px;
    }

    .ai-arrow {
        font-size: 20px;
        top: -25px;
    }
}

@media (max-width: 360px) {
    #ai-analysis-panel {
        max-width: 180px;
        padding: 10px;
        max-height: 55vh;
    }

    #ai-analysis-panel h2 {
        font-size: 13px;
    }

    .analysis-step {
        padding: 6px;
        gap: 6px;
        margin-bottom: 6px;
    }

    .step-number {
        font-size: 16px;
        min-width: 22px;
    }

    .step-preview-cell {
        width: 10px;
        height: 10px;
    }

    .step-info {
        font-size: 10px;
    }

    #close-analysis-btn {
        padding: 7px;
        font-size: 11px;
    }

    .ai-arrow {
        font-size: 18px;
        top: -22px;
    }
}
`;
        document.head.appendChild(style);
        // ========== è¼”åŠ©å‡½æ•¸ ==========

        // æª¢æŸ¥æ–¹å¡Šæ˜¯å¦å¯ä»¥æ”¾åœ¨æ£‹ç›¤ä¸Š
        function canPlaceOnBoard(shape, row, col, board) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const br = row + r;
                        const bc = col + c;
                        // è¶…å‡ºé‚Šç•Œæˆ–ä½ç½®å·²è¢«ä½”ç”¨
                        if (br >= 8 || bc >= 8 || board[br][bc] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // æ¨¡æ“¬æ”¾ç½®æ–¹å¡Š
        function simulatePlace(shape, row, col, board) {
            const newBoard = board.map(r => [...r]); // æ·±æ‹·è²
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        newBoard[row + r][col + c] = 1;
                    }
                }
            }
            return newBoard;
        }

        // ===== æ­£ç¢ºçš„å®Œæ•´æ¶ˆé™¤é‚è¼¯ =====
        function simulateLineClear(board) {
            let currentBoard = cloneBoard(board);
            let iteration = 0;
            const maxIterations = 20; // é˜²æ­¢ç„¡é™å¾ªç’°

            while (iteration < maxIterations) {
                iteration++;

                // ğŸ”‘ é—œéµï¼šæ¯ä¸€è¼ªéƒ½è¦ã€ŒåŒæ™‚æª¢æŸ¥ã€æ‰€æœ‰è¡Œå’Œåˆ—
                const rowsToClear = [];
                const colsToClear = [];

                // 1ï¸âƒ£ æ‰¾å‡ºæ‰€æœ‰éœ€è¦æ¶ˆé™¤çš„è¡Œ
                for (let r = 0; r < 8; r++) {
                    if (currentBoard[r].every(v => v)) {
                        rowsToClear.push(r);
                    }
                }

                // 2ï¸âƒ£ æ‰¾å‡ºæ‰€æœ‰éœ€è¦æ¶ˆé™¤çš„åˆ—
                for (let c = 0; c < 8; c++) {
                    if (currentBoard.every(row => row[c])) {
                        colsToClear.push(c);
                    }
                }

                // 3ï¸âƒ£ å¦‚æœæ²’æœ‰å¯æ¶ˆé™¤çš„ï¼ŒçµæŸå¾ªç’°
                if (rowsToClear.length === 0 && colsToClear.length === 0) {
                    break;
                }

                // 4ï¸âƒ£ åŸ·è¡Œæ¶ˆé™¤ï¼ˆå‰µå»ºæ–°æ£‹ç›¤ï¼‰
                const newBoard = [];

                // ğŸ”‘ é—œéµä¿®æ­£ï¼šé€æ ¼æª¢æŸ¥æ˜¯å¦åœ¨è¦æ¶ˆé™¤çš„è¡Œæˆ–åˆ—ä¸­
                for (let r = 0; r < 8; r++) {
                    newBoard[r] = [];
                    for (let c = 0; c < 8; c++) {
                        // å¦‚æœé€™å€‹æ ¼å­åœ¨è¦æ¶ˆé™¤çš„è¡Œæˆ–åˆ—ä¸­ï¼Œè¨­ç‚º0
                        if (rowsToClear.includes(r) || colsToClear.includes(c)) {
                            newBoard[r][c] = 0;
                        } else {
                            // å¦å‰‡ä¿ç•™åŸå€¼
                            newBoard[r][c] = currentBoard[r][c];
                        }
                    }
                }

                currentBoard = newBoard;
            }

            // âœ… åªåœ¨ç•°å¸¸æƒ…æ³è¼¸å‡ºè­¦å‘Šï¼ˆå¯é¸ï¼Œä¹Ÿå¯åˆªé™¤ï¼‰
            if (iteration >= maxIterations) {
                console.warn('âš ï¸ æ¶ˆé™¤å¾ªç’°é”åˆ°ä¸Šé™ï¼Œå¯èƒ½å­˜åœ¨é‚è¼¯å•é¡Œ');
            }

            return currentBoard;
        }


        // ========== æŒ‰éˆ•å»ºç«‹ ==========



        const btn = document.createElement('button');
        btn.innerText = "ğŸ¤– AI åˆ†æ";
        btn.style.cssText = `
    padding: 12px 20px;
    background-color: #673ab7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
`;



        btn.onclick = () => {
            console.log('=== AI åˆ†æé–‹å§‹ ===');


            // 1. æ¸…é™¤èˆŠæç¤º
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('hint-step-1', 'hint-step-2', 'hint-step-3');
                c.style.boxShadow = ''; // æ¸…é™¤ box-shadow
                const arrow = c.querySelector('.ai-arrow');
                if (arrow) arrow.remove();
            });

            // 2. æ‰¾åˆ°æ–¹å¡Šå®¹å™¨
            let piecesArea = document.getElementById('pieces-area') ||
                document.querySelector('.pieces-area') ||
                document.querySelector('[class*="piece"]')?.parentElement;

            if (!piecesArea) {
                showNotification('æ‰¾ä¸åˆ°æ–¹å¡Šå€åŸŸï¼', 'error');
                return;
            }

            // 3. æŠ“å–å¯ç”¨æ–¹å¡Š
            const currentPieces = [];

            for (let child of piecesArea.children) {
                const isVisible = child.style.visibility !== 'hidden' &&
                    child.style.display !== 'none' &&
                    child.offsetParent !== null;

                if (!isVisible) continue;

                let shape = null;

                // å¾ dataset.shape å–å¾—
                if (child.dataset?.shape) {
                    try {
                        const parsed = JSON.parse(child.dataset.shape);
                        shape = parsed.s || parsed.shape || parsed;
                    } catch (e) {
                        console.warn('JSON è§£æå¤±æ•—:', e);
                    }
                }

                // å¾è¦–è¦ºåæ¨å½¢ç‹€
                if (!shape) {
                    const cells = child.querySelectorAll('.piece-cell, [class*="cell"]');
                    if (cells.length > 0) {
                        // åˆ†ææ ¼å­çš„å¯¦éš›ä½ç½®ä¾†é‡å»ºå½¢ç‹€
                        const positions = Array.from(cells).map(cell => {
                            const rect = cell.getBoundingClientRect();
                            return {x: rect.left, y: rect.top, cell};
                        });

                        // æ‰¾å‡ºæœ€å°xå’Œyä¾†æ¨™æº–åŒ–
                        const minX = Math.min(...positions.map(p => p.x));
                        const minY = Math.min(...positions.map(p => p.y));
                        const cellSize = positions[0]?.cell.offsetWidth || 45;

                        // è½‰æ›ç‚ºæ ¼å­åº§æ¨™
                        const coords = positions.map(p => ({
                            r: Math.round((p.y - minY) / cellSize),
                            c: Math.round((p.x - minX) / cellSize)
                        }));

                        // å»ºç«‹å½¢ç‹€çŸ©é™£
                        const maxR = Math.max(...coords.map(p => p.r));
                        const maxC = Math.max(...coords.map(p => p.c));
                        shape = Array(maxR + 1).fill(0).map(() => Array(maxC + 1).fill(0));
                        coords.forEach(({r, c}) => shape[r][c] = 1);
                    }
                }

                if (shape && shape.length > 0) {
                    currentPieces.push({
                        id: child.id || 'piece-' + currentPieces.length,
                        shape: shape,
                        element: child
                    });
                    console.log('æ‰¾åˆ°æ–¹å¡Š:', shape);
                }
            }

            console.log('ç¸½å…±æ‰¾åˆ°', currentPieces.length, 'å€‹æ–¹å¡Š');

            if (currentPieces.length === 0) {
                showNotification('ç›®å‰æ²’æœ‰å¯åˆ†æçš„æ–¹å¡Šï¼', 'warning');
                return;
            }

            // 4. æ’åˆ—çµ„åˆ
            const permutations = (arr) => {
                if (arr.length <= 1) return [arr];
                let res = [];
                for (let i = 0; i < arr.length; i++) {
                    let rest = permutations(arr.slice(0, i).concat(arr.slice(i + 1)));
                    rest.forEach(r => res.push([arr[i], ...r]));
                }
                return res;
            };

            // 5. DFS æœå°‹
            function solve(board, pieces, steps = []) {
                if (pieces.length === 0) return steps;

                const p = pieces[0];
                const rows = p.shape.length;
                const cols = p.shape[0].length;

                for (let r = 0; r <= 8 - rows; r++) {
                    for (let c = 0; c <= 8 - cols; c++) {
                        if (canPlaceOnBoard(p.shape, r, c, board)) {
                            let nextBoard = simulatePlace(p.shape, r, c, board);
                            nextBoard = simulateLineClear(nextBoard);

                            const result = solve(nextBoard, pieces.slice(1), [...steps, {r, c, shape: p.shape}]);
                            if (result) return result;
                        }
                    }
                }
                return null;
            }

            // 6. é–‹å§‹åˆ†æ
            console.log('é–‹å§‹çª®èˆ‰,å…±', permutations(currentPieces).length, 'ç¨®æ’åˆ—');
            let finalSteps = null;
            const allOrders = permutations(currentPieces);

            for (let i = 0; i < allOrders.length; i++) {
                console.log(`å˜—è©¦ç¬¬ ${i+1}/${allOrders.length} ç¨®æ’åˆ—`);
                finalSteps = solve(boardState, allOrders[i]);
                if (finalSteps) {
                    console.log('âœ… æ‰¾åˆ°è§£æ³•!');
                    break;
                }
            }

            // 7. é¡¯ç¤ºçµæœ
            if (finalSteps && finalSteps.length > 0) {
                const stepNumbers = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨'];

                // åªé¡¯ç¤ºå‰ 3 æ­¥
                const displaySteps = finalSteps.slice(0, 3);

                // å…ˆæ¨™è¨˜æ‰€æœ‰æ ¼å­
                displaySteps.forEach((step, idx) => {
                    step.shape.forEach((row, ir) => {
                        row.forEach((val, ic) => {
                            if (val) {
                                const cellIndex = (step.r + ir) * 8 + (step.c + ic);
                                const targetCell = boardElement.children[cellIndex];
                                if (targetCell) {
                                    // ç´¯åŠ  classï¼Œå¯¦ç¾å¤šé‡é‚Šæ¡†
                                    if (idx === 0) targetCell.classList.add('hint-step-1');
                                    if (idx === 1) targetCell.classList.add('hint-step-2');
                                    if (idx === 2) targetCell.classList.add('hint-step-3');


                                }
                            }
                        });
                    });
                });

                // å‰µå»ºåˆ†æé¢æ¿
                showAnalysisPanel(displaySteps, stepNumbers);

            } else {
                console.log('âŒ ç„¡è§£');
                const stepNumbers = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨'];
                showAnalysisPanel(null, stepNumbers); // å‚³å…¥ null è¡¨ç¤ºç„¡è§£
            }
        }; // â† btn.onclick çµæŸ

        // ========== æ’å…¥æŒ‰éˆ• (ç§»åˆ° onclick å¤–é¢) ==========
        const undoButton = document.querySelector('button');
        const buttonContainer = undoButton.parentElement;

        buttonContainer.appendChild(btn);
        console.log('âœ… AI åˆ†ææŒ‰éˆ•å·²åŠ å…¥');
    }


    // ========== 3. æ–°å¢å‡½æ•¸ - é¡¯ç¤ºåˆ†æé¢æ¿ ==========

    function showAnalysisPanel(steps, stepNumbers) {
        // ç§»é™¤èˆŠé¢æ¿å’Œè¨ˆæ™‚å™¨
        const oldPanel = document.getElementById('ai-analysis-panel');
        if (oldPanel) {
            oldPanel.remove();
            if (window.aiPanelTimer) clearTimeout(window.aiPanelTimer);
            if (window.aiCountdownTimer) clearInterval(window.aiCountdownTimer);
        }

        // å‰µå»ºé¢æ¿
        const panel = document.createElement('div');
        panel.id = 'ai-analysis-panel';

        let html = '';

        // åˆ¤æ–·æ˜¯å¦æœ‰è§£
        if (steps === null || steps.length === 0) {
            // ç„¡è§£çš„æƒ…æ³
            html = `
            <h2 style="color: #ff4757; margin: 0 0 10px 0; font-size: 16px;">ğŸ˜µ æ­¤å±€é¢ç„¡è§£</h2>
            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.15); border-radius: 8px;">
                <div style="font-size: 32px; margin-bottom: 10px;">ğŸš«</div>
                <div style="font-size: 13px; line-height: 1.6;">
                    ç„¡è«–å¦‚ä½•æ’åˆ—çµ„åˆ<br>
                    å‰©é¤˜æ–¹å¡Šéƒ½ç„¡æ³•å®Œå…¨æ”¾å…¥æ£‹ç›¤<br><br>
                    <span style="opacity: 0.8; font-size: 11px;">å»ºè­°é‡æ–°é–‹å±€æˆ–ä½¿ç”¨å…¶ä»–æ–¹å¡Š</span>
                </div>
            </div>
        `;
        } else {
            // æœ‰è§£çš„æƒ…æ³
            html = '<h2 style="margin: 0 0 10px 0; font-size: 16px;">ğŸ¤– AI è§£æ³•åˆ†æ</h2>';

            steps.forEach((step, idx) => {
                const colors = ['#00FF00', '#FF0000', '#0000FF'];
                const colorNames = ['ç¶ è‰²', 'ç´…è‰²', 'è—è‰²'];

                // ç”Ÿæˆæ–¹å¡Šé è¦½
                const rows = step.shape.length;
                const cols = step.shape[0].length;
                let previewHTML = `<div class="step-preview" style="grid-template-columns: repeat(${cols}, 15px);">`;

                step.shape.forEach(row => {
                    row.forEach(cell => {
                        const bgColor = cell ? colors[idx] : 'transparent';
                        previewHTML += `<div class="step-preview-cell" style="background: ${bgColor};"></div>`;
                    });
                });
                previewHTML += '</div>';

                html += `
                <div class="analysis-step">
                    <div class="step-number" style="color: ${colors[idx]};">${stepNumbers[idx]}</div>
                    ${previewHTML}
                    <div class="step-info">
                        <div style="font-weight: bold; margin-bottom: 2px; font-size: 12px;">
                            ç¬¬ ${idx + 1} æ­¥ - ${colorNames[idx]}é‚Šæ¡†
                        </div>
                        <div style="opacity: 0.9; font-size: 11px;">
                            ä½ç½®: ç¬¬ ${step.r + 1} è¡Œï¼Œç¬¬ ${step.c + 1} åˆ—
                        </div>
                    </div>
                </div>
            `;
            });
        }

        html += '<button id="close-analysis-btn">âŒ é—œé–‰ <span id="countdown">(20)</span></button>';

        panel.innerHTML = html;
        document.body.appendChild(panel);

        // ========================================
        // ğŸ”¥ æ•´å€‹é¢æ¿å¯æ‹–æ›³
        // ========================================
        let isDragging = false;
        let currentX, currentY, initialX, initialY;

        panel.addEventListener('mousedown', dragStart);
        panel.addEventListener('touchstart', dragStart);

        function dragStart(e) {
            // å¦‚æœé»æ“Šçš„æ˜¯é—œé–‰æŒ‰éˆ•ï¼Œä¸è§¸ç™¼æ‹–æ›³
            if (e.target.id === 'close-analysis-btn' || e.target.closest('#close-analysis-btn')) {
                return;
            }

            if (e.type === 'touchstart') {
                initialX = e.touches[0].clientX - panel.offsetLeft;
                initialY = e.touches[0].clientY - panel.offsetTop;
            } else {
                initialX = e.clientX - panel.offsetLeft;
                initialY = e.clientY - panel.offsetTop;
            }

            isDragging = true;
            panel.style.cursor = 'grabbing';

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);
        }

        function drag(e) {
            if (!isDragging) return;

            e.preventDefault();

            if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
            } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
            }

            // é™åˆ¶åœ¨è¦–çª—ç¯„åœå…§
            const maxX = window.innerWidth - panel.offsetWidth;
            const maxY = window.innerHeight - panel.offsetHeight;

            currentX = Math.max(0, Math.min(currentX, maxX));
            currentY = Math.max(0, Math.min(currentY, maxY));

            panel.style.left = currentX + 'px';
            panel.style.top = currentY + 'px';
            panel.style.right = 'auto';
            panel.style.bottom = 'auto';
        }

        function dragEnd() {
            isDragging = false;
            panel.style.cursor = 'grab';

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', dragEnd);
            document.removeEventListener('touchend', dragEnd);
        }

        // æ¸…é™¤æç¤ºçš„å‡½æ•¸
        const clearAnalysis = () => {
            panel.remove();
            if (window.aiPanelTimer) clearTimeout(window.aiPanelTimer);
            if (window.aiCountdownTimer) clearInterval(window.aiCountdownTimer);
            // æ¸…é™¤æ‰€æœ‰æç¤º
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('hint-step-1', 'hint-step-2', 'hint-step-3');
                c.style.boxShadow = '';
                const arrow = c.querySelector('.ai-arrow');
                if (arrow) arrow.remove();
            });
        };

        // ç¶å®šé—œé–‰æŒ‰éˆ•
        document.getElementById('close-analysis-btn').onclick = clearAnalysis;

        // å€’æ•¸è¨ˆæ™‚é¡¯ç¤º
        let countdown = 20;
        const countdownEl = document.getElementById('countdown');
        window.aiCountdownTimer = setInterval(() => {
            countdown--;
            if (countdownEl) countdownEl.innerText = `(${countdown})`;
        }, 1000);

        // 20 ç§’å¾Œè‡ªå‹•é—œé–‰
        window.aiPanelTimer = setTimeout(clearAnalysis, 20000);
    }

    // ========== AI æŒ‡å°åŠŸèƒ½ ==========

    // å®Œæ•´æ–¹å¡Šåº«ï¼ˆç”¨æ–¼åç¨±åŒ¹é…ï¼‰
    const SHAPE_LIBRARY = [
        // === Monomino (1æ ¼) ===
        { s: [[1]], color: '#ffd54f', name: 'å–®æ ¼' },

        // === Domino (2æ ¼) ===
        { s: [[1,1]], color: '#81c784', name: 'æ©«äºŒ' },
        { s: [[1],[1]], color: '#81c784', name: 'ç›´äºŒ' },

        // === æ–œå‘ 2æ ¼ ===
        { s: [[1,0],[0,1]], color: '#ffb74d', name: 'å³æ–œäºŒ' },
        { s: [[0,1],[1,0]], color: '#ffb74d', name: 'å·¦æ–œäºŒ' },

        // === Tromino (3æ ¼) ===
        { s: [[1,1,1]], color: '#64b5f6', name: 'æ©«ä¸‰' },
        { s: [[1],[1],[1]], color: '#64b5f6', name: 'ç›´ä¸‰' },

        // Lå‹ 4 å€‹æ–¹å‘
        { s: [[1,1],[1,0]], color: '#4fc3f7', name: 'å·¦ä¸‹L3' },
        { s: [[1,1],[0,1]], color: '#4fc3f7', name: 'å³ä¸‹L3' },
        { s: [[1,0],[1,1]], color: '#4fc3f7', name: 'å·¦ä¸ŠL3' },
        { s: [[0,1],[1,1]], color: '#4fc3f7', name: 'å³ä¸ŠL3' },

        // === æ–œå‘ 3æ ¼ ===
        { s: [[1,0,0],[0,1,0],[0,0,1]], color: '#f06292', name: 'å³æ–œä¸‰' },
        { s: [[0,0,1],[0,1,0],[1,0,0]], color: '#f06292', name: 'å·¦æ–œä¸‰' },

        // === Tetromino (4æ ¼) ===
        { s: [[1,1,1,1]], color: '#42a5f5', name: 'æ©«å››' },
        { s: [[1],[1],[1],[1]], color: '#42a5f5', name: 'ç›´å››' },
        { s: [[1,1],[1,1]], color: '#66bb6a', name: 'ç”°å­—' },

        // Tå­— 4å€‹æ–¹å‘
        { s: [[1,1,1],[0,1,0]], color: '#ba68c8', name: 'Tå­—ä¸Š' },
        { s: [[0,1,0],[1,1,1]], color: '#ba68c8', name: 'Tå­—ä¸‹' },
        { s: [[1,0],[1,1],[1,0]], color: '#ba68c8', name: 'Tå­—å·¦' },
        { s: [[0,1],[1,1],[0,1]], color: '#ba68c8', name: 'Tå­—å³' },

        // Lå­— 4å€‹æ–¹å‘
        { s: [[1,1,1],[1,0,0]], color: '#ffa726', name: 'Lå­—å·¦ä¸Š' },
        { s: [[1,0,0],[1,1,1]], color: '#ffa726', name: 'Lå­—å·¦ä¸‹' },
        { s: [[1,1],[0,1],[0,1]], color: '#ffa726', name: 'Lå­—å³ä¸Š' },
        { s: [[0,1],[0,1],[1,1]], color: '#ffa726', name: 'Lå­—å³ä¸‹' },

        // Zå­— 4å€‹æ–¹å‘
        { s: [[1,1,0],[0,1,1]], color: '#ef5350', name: 'Zå­—å³' },
        { s: [[0,1,1],[1,1,0]], color: '#ef5350', name: 'Zå­—å·¦' },
        { s: [[0,1],[1,1],[1,0]], color: '#ef5350', name: 'Zå­—ä¸Š' },
        { s: [[1,0],[1,1],[0,1]], color: '#ef5350', name: 'Zå­—ä¸‹' },

        // å‡¸å­—å‹ 4å€‹æ–¹å‘
        { s: [[0,0,1],[1,1,1],[1,0,0]], color: '#4dd0e1', name: 'å‡¸å­—å³ä¸Š' },
        { s: [[1,0,0],[1,1,1],[0,0,1]], color: '#4dd0e1', name: 'å‡¸å­—å·¦ä¸Š' },
        { s: [[1,0],[1,1],[0,1]], color: '#4dd0e1', name: 'å‡¸å­—å³ä¸‹' },
        { s: [[0,1],[1,1],[1,0]], color: '#4dd0e1', name: 'å‡¸å­—å·¦ä¸‹' },

        // å‡¹å­—å‹ 4å€‹æ–¹å‘
        { s: [[1,0,1],[1,1,1]], color: '#ffb300', name: 'å‡¹å­—ä¸‹' },
        { s: [[1,1,1],[1,0,1]], color: '#ffb300', name: 'å‡¹å­—ä¸Š' },
        { s: [[1,1],[0,1],[1,1]], color: '#ffb300', name: 'å‡¹å­—å·¦' },
        { s: [[1,1],[1,0],[1,1]], color: '#ffb300', name: 'å‡¹å­—å³' },

        // åå­—å‹
        { s: [[0,1,0],[1,1,1],[0,1,0]], color: '#8e24aa', name: 'åå­—' },

        // === Pentomino (5æ ¼) ===
        { s: [[1,1,1,1,1]], color: '#ab47bc', name: 'æ©«äº”' },
        { s: [[1],[1],[1],[1],[1]], color: '#ab47bc', name: 'ç›´äº”' },

        // å¤§L 4å€‹æ–¹å‘
        { s: [[1,1,1],[1,0,0],[1,0,0]], color: '#ec407a', name: 'å¤§Lå·¦ä¸Š' },
        { s: [[1,1,1],[0,0,1],[0,0,1]], color: '#ec407a', name: 'å¤§Lå³ä¸Š' },
        { s: [[1,0,0],[1,0,0],[1,1,1]], color: '#ec407a', name: 'å¤§Lå·¦ä¸‹' },
        { s: [[0,0,1],[0,0,1],[1,1,1]], color: '#ec407a', name: 'å¤§Lå³ä¸‹' },

        // å¤§T 4å€‹æ–¹å‘
        { s: [[1,1,1],[0,1,0],[0,1,0]], color: '#26c6da', name: 'å¤§Tä¸Š' },
        { s: [[0,1,0],[0,1,0],[1,1,1]], color: '#26c6da', name: 'å¤§Tä¸‹' },
        { s: [[1,0,0],[1,1,1],[1,0,0]], color: '#26c6da', name: 'å¤§Tå·¦' },
        { s: [[0,0,1],[1,1,1],[0,0,1]], color: '#26c6da', name: 'å¤§Tå³' },

        // é•·L 4å€‹æ–¹å‘
        { s: [[1,1,1,1],[1,0,0,0]], color: '#7e57c2', name: 'é•·Lå·¦ä¸Š' },
        { s: [[1,1,1,1],[0,0,0,1]], color: '#7e57c2', name: 'é•·Lå³ä¸Š' },
        { s: [[1,1],[1,0],[1,0],[1,0]], color: '#5c6bc0', name: 'é•·Lå·¦ä¸‹' },
        { s: [[1,1],[0,1],[0,1],[0,1]], color: '#5c6bc0', name: 'é•·Lå³ä¸‹' },

        // èƒ–L 4å€‹æ–¹å‘
        { s: [[1,1,1],[1,1,0]], color: '#9ccc65', name: 'å¯¬Lå·¦ä¸‹' },
        { s: [[1,1,0],[1,1,1]], color: '#9ccc65', name: 'å¯¬Lå³ä¸‹' },
        { s: [[0,1,1],[1,1,1]], color: '#9ccc65', name: 'å¯¬Lå³ä¸Š' },
        { s: [[1,1,1],[0,1,1]], color: '#9ccc65', name: 'å¯¬Lå·¦ä¸Š' },

        { s: [[1,1],[1,1],[0,1]], color: '#9ccc65', name: 'é«˜Lå·¦ä¸‹' },
        { s: [[1,1],[1,1],[1,0]], color: '#9ccc65', name: 'é«˜Lå³ä¸‹' },
        { s: [[0,1],[1,1],[1,1]], color: '#9ccc65', name: 'é«˜Lå·¦ä¸Š' },
        { s: [[1,0],[1,1],[1,1]], color: '#9ccc65', name: 'é«˜Lå³ä¸Š' },

        // === æ–œå‘ 5æ ¼ ===
        { s: [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]], color: '#e91e63', name: 'å³æ–œäº”' },
        { s: [[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0]], color: '#e91e63', name: 'å·¦æ–œäº”' },

        // === ç‰¹æ®Šå¤§æ–¹å¡Š ===
        { s: [[1,1,1],[1,1,1]], color: '#ff7043', name: 'èƒ–ç”°3x2' },
        { s: [[1,1],[1,1],[1,1]], color: '#ff7043', name: 'é«˜ç”°2x3' },
        { s: [[1,1,1],[1,1,1],[1,1,1]], color: '#f44336', name: 'ä¹å®®æ ¼' },
    ];

    function matchShapeName(shape) {
        const shapeStr = JSON.stringify(shape);

        for (let lib of SHAPE_LIBRARY) {
            if (JSON.stringify(lib.s) === shapeStr) {
                return lib.name;
            }
        }

        // æ‰¾ä¸åˆ°å°±ç”¨é€šç”¨æè¿°
        const cellCount = shape.flat().filter(c => c === 1).length;
        return `${cellCount}æ ¼æ–¹å¡Š`;
    }

    function addAIGuideButton() {
        if (document.getElementById('ai-guide-btn')) return;

        // æ‰¾åˆ°æŒ‰éˆ•å®¹å™¨ï¼ˆè·Ÿå…¶ä»–æŒ‰éˆ•åœ¨åŒä¸€å€‹åœ°æ–¹ï¼‰
        const buttonContainer = document.querySelector('button').parentElement;

        const guideBtn = document.createElement('button');
        guideBtn.id = 'ai-guide-btn';
        guideBtn.textContent = 'ğŸ¯ AI æŒ‡å°';
        guideBtn.style.cssText = `
        padding: 12px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
    `;

        guideBtn.onclick = showAIGuidePanel;
        buttonContainer.appendChild(guideBtn);  // â† åŠ åˆ°æŒ‰éˆ•å®¹å™¨ä¸­
    }

    function showAIGuidePanel() {
        const steps = performSilentAIAnalysis();

        if (!steps || steps.length === 0) {
            showNoSolutionPanel();  // â† æ”¹æˆé€™è¡Œ
            return;
        }

        // å‰µå»ºé®ç½©å±¤
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
    `;

        // å‰µå»ºæŒ‡å°é¢æ¿
        const panel = document.createElement('div');
        panel.id = 'ai-guide-panel';
        panel.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 1200px;
        max-height: 85vh;
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        z-index: 10001;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    `;

        // æ¨™é¡Œå€
        const header = document.createElement('div');
        header.style.cssText = `
        padding: 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
    `;
        header.innerHTML = `
        <h2 style="margin: 0; font-size: 24px;">ğŸ¯ æ”¾ç½®æ­¥é©ŸæŒ‡å°</h2>
        <button id="close-guide-btn" style="
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        ">âœ• é—œé–‰</button>
    `;

        // å…§å®¹å€
        const content = document.createElement('div');
        content.style.cssText = `
        padding: 24px;
        overflow-y: auto;
        flex: 1;
    `;

        // ç”Ÿæˆæ­¥é©Ÿå®¹å™¨
        const stepsContainer = document.createElement('div');
        stepsContainer.style.cssText = `
        display: flex;
        gap: 20px;
        justify-content: center;
        flex-wrap: wrap;
    `;

        // ç‚ºæ¯å€‹æ­¥é©Ÿå‰µå»ºæ¼”ç¤º
        steps.forEach((step, index) => {
            const stepDiv = createStepVisualization(step, index, steps);
            stepsContainer.appendChild(stepDiv);
        });

        content.appendChild(stepsContainer);
        panel.appendChild(header);
        panel.appendChild(content);

        document.body.appendChild(overlay);
        document.body.appendChild(panel);

        // é—œé–‰æŒ‰éˆ•äº‹ä»¶
        document.getElementById('close-guide-btn').onclick = () => {
            panel.remove();
            overlay.remove();
        };

        // é»æ“Šé®ç½©é—œé–‰
        overlay.onclick = () => {
            panel.remove();
            overlay.remove();
        };
    }

    function createStepVisualization(step, stepIndex, allSteps) {
        const stepDiv = document.createElement('div');
        stepDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 12px;
        min-width: 300px;
    `;

        // æ­¥é©Ÿæ¨™é¡Œ
        const title = document.createElement('div');
        title.style.cssText = `
        font-size: 18px;
        font-weight: bold;
        color: #333;
    `;
        title.textContent = `æ­¥é©Ÿ ${stepIndex + 1}`;

        // æ£‹ç›¤æ¼”ç¤º
        const boardDiv = createBoardVisualization(step, stepIndex, allSteps);

        // èªªæ˜æ–‡å­—
        const explanation = createExplanation(step, stepIndex, allSteps);

        stepDiv.appendChild(title);
        stepDiv.appendChild(boardDiv);
        stepDiv.appendChild(explanation);

        return stepDiv;
    }

    function createBoardVisualization(currentStep, stepIndex, allSteps) {
        const boardDiv = document.createElement('div');
        boardDiv.style.cssText = `
        display: grid;
        grid-template-columns: repeat(8, 35px);
        grid-template-rows: repeat(8, 35px);
        gap: 2px;
        background: #ddd;
        padding: 4px;
        border-radius: 8px;
    `;

        const board = Array(8).fill(0).map(() => Array(8).fill(0));
        const boardColors = Array(8).fill(0).map(() => Array(8).fill(null));

        // 1. å…ˆåŠ è¼‰åŸæœ¬æ£‹ç›¤ä¸Šå·²æœ‰çš„æ–¹å¡Šï¼ˆçµ±ä¸€é»ƒè‰²ï¼‰
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (boardState[r][c]) {
                    board[r][c] = 0.5;
                    boardColors[r][c] = '#ffd54f';
                }
            }
        }

        // å®šç¾©æ¯å€‹æ­¥é©Ÿçš„å›ºå®šé¡è‰²ï¼ˆç¶ ã€ç´…ã€è—ï¼‰
        const stepColors = ['#66bb6a', '#ef5350', '#42a5f5'];

        // 2. åŠ ä¸Š AI å»ºè­°çš„æ­¥é©Ÿæ–¹å¡Š
        for (let i = 0; i <= stepIndex; i++) {
            const step = allSteps[i];
            const stepColor = stepColors[i % 3];

            // æ”¾ç½®æ–¹å¡Š
            for (let r = 0; r < step.shape.length; r++) {
                for (let c = 0; c < step.shape[0].length; c++) {
                    if (step.shape[r][c]) {
                        const br = step.r + r;
                        const bc = step.c + c;
                        board[br][bc] = 1;
                        boardColors[br][bc] = stepColor;
                    }
                }
            }

            // å¦‚æœä¸æ˜¯ç•¶å‰æ­¥é©Ÿï¼Œè¦æ¨¡æ“¬æ¶ˆé™¤
            if (i < stepIndex) {
                // æ¶ˆé™¤æ»¿è¡Œ
                for (let r = 0; r < 8; r++) {
                    if (board[r].every(cell => cell !== 0)) {
                        board[r].fill(0);
                        boardColors[r].fill(null);
                    }
                }

                // æ¶ˆé™¤æ»¿åˆ—
                for (let c = 0; c < 8; c++) {
                    let isFull = true;
                    for (let r = 0; r < 8; r++) {
                        if (board[r][c] === 0) {
                            isFull = false;
                            break;
                        }
                    }
                    if (isFull) {
                        for (let r = 0; r < 8; r++) {
                            board[r][c] = 0;
                            boardColors[r][c] = null;
                        }
                    }
                }
            }
        }

        // æª¢æŸ¥å¯æ¶ˆé™¤çš„è¡Œå’Œåˆ—
        const clearableLines = new Set();
        for (let r = 0; r < 8; r++) {
            if (board[r].every(cell => cell !== 0)) {
                clearableLines.add(`row-${r}`);
            }
        }
        for (let c = 0; c < 8; c++) {
            let isFull = true;
            for (let r = 0; r < 8; r++) {
                if (board[r][c] === 0) {
                    isFull = false;
                    break;
                }
            }
            if (isFull) {
                clearableLines.add(`col-${c}`);
            }
        }

        // ç¹ªè£½æ£‹ç›¤
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const cell = document.createElement('div');
                cell.style.cssText = `
                width: 35px;
                height: 35px;
                border-radius: 4px;
                position: relative;
            `;

                const isRowClearable = clearableLines.has(`row-${r}`);
                const isColClearable = clearableLines.has(`col-${c}`);

                if (board[r][c] === 1) {
                    // AI æ”¾ç½®çš„æ–¹å¡Šï¼ˆç¶ /ç´…/è—ï¼‰
                    cell.style.background = boardColors[r][c] || '#7c9bff';
                    if (isRowClearable || isColClearable) {
                        cell.style.boxShadow = 'inset 0 0 0 3px black';
                    }
                } else if (board[r][c] === 0.5) {
                    // åŸæœ¬æ£‹ç›¤æ–¹å¡Šï¼ˆé»ƒè‰²ï¼‰
                    cell.style.background = '#ffd54f';
                    cell.style.opacity = '0.8';
                    if (isRowClearable || isColClearable) {
                        cell.style.boxShadow = 'inset 0 0 0 3px black';
                    }
                } else {
                    // ç©ºæ ¼
                    cell.style.background = '#e8eaf6';
                }

                boardDiv.appendChild(cell);
            }
        }

        return boardDiv;
    }

    function createExplanation(currentStep, stepIndex, allSteps) {
        const explanationDiv = document.createElement('div');
        explanationDiv.style.cssText = `
        padding: 16px;
        background: white;
        border-radius: 8px;
        border: 2px solid #e0e0e0;
        font-size: 14px;
        line-height: 1.6;
        color: #333;
        max-width: 300px;
        text-align: center;
    `;

        const shapeName = matchShapeName(currentStep.shape);
        const positionDesc = `ç¬¬ ${currentStep.r + 1} è¡Œï¼Œç¬¬ ${currentStep.c + 1} åˆ—`;

        // è¨ˆç®—æ¶ˆé™¤çš„è¡Œåˆ—ï¼ˆåŒ…å«åŸæœ¬æ£‹ç›¤ç‹€æ…‹ï¼‰
        const board = Array(8).fill(0).map(() => Array(8).fill(0));

        // å…ˆåŠ è¼‰åŸæœ¬æ£‹ç›¤
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (boardState[r][c]) {
                    board[r][c] = 1;
                }
            }
        }

        // å†åŠ ä¸Šæ‰€æœ‰æ­¥é©Ÿ
        for (let i = 0; i <= stepIndex; i++) {
            const step = allSteps[i];
            for (let r = 0; r < step.shape.length; r++) {
                for (let c = 0; c < step.shape[0].length; c++) {
                    if (step.shape[r][c]) {
                        board[step.r + r][step.c + c] = 1;
                    }
                }
            }
        }

        const clearedRows = [];
        const clearedCols = [];

        for (let r = 0; r < 8; r++) {
            if (board[r].every(cell => cell !== 0)) {
                clearedRows.push(r + 1);
            }
        }

        for (let c = 0; c < 8; c++) {
            let isFull = true;
            for (let r = 0; r < 8; r++) {
                if (board[r][c] === 0) {
                    isFull = false;
                    break;
                }
            }
            if (isFull) {
                clearedCols.push(c + 1);
            }
        }

        let explanation = '';

        if (clearedRows.length > 0 || clearedCols.length > 0) {
            explanation = `å°‡ <strong style="color: #ff9800;">${shapeName}</strong> æ–¹å¡Šæ”¾å…¥ <strong>${positionDesc}</strong> ä½ç½®ï¼Œ`;

            if (clearedRows.length > 0 && clearedCols.length > 0) {
                explanation += `å¯ä½¿ç¬¬ ${clearedRows.join('ã€')} è¡Œèˆ‡ç¬¬ ${clearedCols.join('ã€')} åˆ—åŒæ™‚æ¶ˆé™¤`;
            } else if (clearedRows.length > 0) {
                explanation += `å¯ä½¿ç¬¬ ${clearedRows.join('ã€')} è¡Œæ¶ˆé™¤`;
            } else {
                explanation += `å¯ä½¿ç¬¬ ${clearedCols.join('ã€')} åˆ—æ¶ˆé™¤`;
            }

            if (stepIndex < allSteps.length - 1) {
                explanation += 'ï¼Œç‚ºå¾ŒçºŒæ–¹å¡Šè£½é€ ç©ºé–“';
            }
        } else {
            explanation = `å°‡ <strong style="color: #ff9800;">${shapeName}</strong> æ–¹å¡Šæ”¾å…¥ <strong>${positionDesc}</strong> ä½ç½®`;

            if (stepIndex < allSteps.length - 1) {
                explanation += 'ï¼Œç‚ºå¾ŒçºŒæ¶ˆé™¤åšæº–å‚™';
            } else {
                explanation += 'ï¼Œå®Œæˆæ”¾ç½®';
            }
        }

        const completedInfo = document.createElement('div');
        completedInfo.style.cssText = `
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #e0e0e0;
        font-size: 12px;
        color: #666;
    `;

        const totalCleared = clearedRows.length + clearedCols.length;
        completedInfo.textContent = `å®Œæˆæ¶ˆé™¤ï¼š${totalCleared} è¡Œ/åˆ—`;

        explanationDiv.innerHTML = explanation;
        explanationDiv.appendChild(completedInfo);

        return explanationDiv;
    }

    function addRestartButton() {
        const undoButton = document.querySelector('button');
        const buttonContainer = undoButton.parentElement;

        const restartButton = document.createElement('button');
        restartButton.textContent = 'ğŸ”„ é‡æ–°é–‹å§‹';
        restartButton.style.cssText = `
        padding: 12px 20px;
        background-color: #ff9800;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        margin-left: 10px;
    `;

        restartButton.addEventListener('click', function() {
            showConfirmDialog('ç¢ºå®šè¦é‡æ–°é–‹å§‹éŠæˆ²å—ï¼Ÿç›®å‰é€²åº¦å°‡æœƒéºå¤±ï¼', () => {
                restartGame();
            });
        });

        buttonContainer.appendChild(restartButton);
    }

    function restartGame() {
        // 1. é‡ç½®æ£‹ç›¤ç‹€æ…‹
        boardState = Array(8).fill().map(() => Array(8).fill(0));

        // 2. é‡ç½®åˆ†æ•¸ç³»çµ±
        if (typeof score !== 'undefined') {
            score = 0;
            const scoreElement = document.getElementById('score');
            if (scoreElement) {
                scoreElement.textContent = score;
            }
        }

        // 3. é‡ç½®é€£çºŒæ¶ˆé™¤
        streakCount = 0;
        lastMoveCleared = false;

        // 4. æ¸…ç©ºç§»å‹•æ­·å²
        if (typeof moveHistory !== 'undefined') {
            moveHistory = [];
        }

        // 5. æ¸…ç©º AI è§£æ³•
        aiSolution = null;

        // 6. æ¸…ç©ºç•¶å‰å›åˆè¨˜éŒ„
        window.currentRoundPlacements = [];
        window.initialBoardState = null;
        window.currentRoundPieces = null;

        // 7. é‡ç½®ç„¡ç›¡æ¨¡å¼ç›¸é—œ
        if (endlessModeActive) {
            endlessModeActive = false;
            endlessModeType = null;
            if (endlessModeTimer) {
                clearInterval(endlessModeTimer);
                endlessModeTimer = null;
            }
            endlessModeTimeRemaining = 0;
            endlessModeStartTime = 0;
            endlessModeScore = 0;

            // éš±è—ç„¡ç›¡æ¨¡å¼ UI
            const endlessUI = document.getElementById('endless-mode-ui');
            if (endlessUI) {
                endlessUI.style.display = 'none';
            }
        }

        // 8. æ¸…é™¤ AI è¦–è¦ºæ•ˆæœ
        const cells = boardElement.querySelectorAll('.cell');
        cells.forEach(cell => {
            cell.classList.remove('hint-step-1', 'hint-step-2', 'hint-step-3');
            // ç§»é™¤ AI ç®­é ­
            const arrow = cell.querySelector('.ai-arrow');
            if (arrow) {
                arrow.remove();
            }
        });

        // 9. é—œé–‰æ‰€æœ‰å°è©±æ¡†
        const dialogs = ['notation-dialog', 'ai-analysis-panel'];
        dialogs.forEach(id => {
            const dialog = document.getElementById(id);
            if (dialog) {
                dialog.remove();
            }
        });

        // ç§»é™¤é®ç½©
        const overlays = document.querySelectorAll('#notation-overlay, [id*="overlay"]');
        overlays.forEach(overlay => overlay.remove());

        // 10. æ¸…ç©ºæ£‹ç›¤ DOM
        boardElement.innerHTML = '';

        // 11. é‡æ–°åˆå§‹åŒ–éŠæˆ²ï¼ˆç”Ÿæˆéš¨æ©Ÿæ®˜å±€ + æ–°æ–¹å¡Šï¼‰
        init();

        console.log('ğŸ® éŠæˆ²å·²é‡æ–°é–‹å§‹ï¼ˆæ–°æ®˜å±€ï¼‰');
    }


    // ========== çµ±ä¸€å½ˆçª—ç³»çµ± ==========

    /**
     * é¡¯ç¤ºè‡ªè¨‚å½ˆçª—
     * @param {string} message - è¦é¡¯ç¤ºçš„è¨Šæ¯
     * @param {string} type - é¡å‹: 'success', 'error', 'warning', 'info'
     * @param {number} duration - è‡ªå‹•é—œé–‰æ™‚é–“(æ¯«ç§’)ï¼Œ0 è¡¨ç¤ºéœ€è¦æ‰‹å‹•é—œé–‰
     * @param {function} onClose - é—œé–‰å¾Œçš„å›èª¿å‡½æ•¸
     */
    function showNotification(message, type = 'info', duration = 3000, onClose = null) {
        // ç§»é™¤èˆŠçš„å½ˆçª—ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const existingNotif = document.getElementById('custom-notification');
        if (existingNotif) {
            existingNotif.remove();
        }

        // å»ºç«‹å½ˆçª—å…ƒç´ 
        const notification = document.createElement('div');
        notification.id = 'custom-notification';
        notification.className = `notification notification-${type}`;

        // æ ¹æ“šé¡å‹é¸æ“‡åœ–æ¨™
        const icons = {
            success: 'âœ…',
            error: 'âŒ',
            warning: 'âš ï¸',
            info: 'â„¹ï¸'
        };

        notification.innerHTML = `
        <div class="notification-content">
            <span class="notification-icon">${icons[type] || 'â„¹ï¸'}</span>
            <span class="notification-message">${message}</span>
            <button class="notification-close" onclick="this.parentElement.parentElement.remove()">Ã—</button>
        </div>
    `;

        // æ·»åŠ åˆ°é é¢
        document.body.appendChild(notification);

        // æ·»åŠ é€²å…¥å‹•ç•«
        setTimeout(() => {
            notification.classList.add('show');
        }, 10);

        // è‡ªå‹•é—œé–‰
        if (duration > 0) {
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    notification.remove();
                    if (onClose) onClose();
                }, 300);
            }, duration);
        }
    }

    /**
     * é¡¯ç¤ºç¢ºèªå°è©±æ¡†
     * @param {string} message - è¦é¡¯ç¤ºçš„è¨Šæ¯
     * @param {function} onConfirm - ç¢ºèªå¾Œçš„å›èª¿
     * @param {function} onCancel - å–æ¶ˆå¾Œçš„å›èª¿
     */
    function showConfirmDialog(message, onConfirm, onCancel = null) {
        // ç§»é™¤èˆŠçš„å°è©±æ¡†
        const existingDialog = document.getElementById('custom-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        const dialog = document.createElement('div');
        dialog.id = 'custom-dialog';
        dialog.className = 'dialog-overlay';

        dialog.innerHTML = `
        <div class="dialog-box">
            <div class="dialog-content">
                <div class="dialog-icon">â“</div>
                <div class="dialog-message">${message}</div>
            </div>
            <div class="dialog-buttons">
                <button class="dialog-btn dialog-btn-cancel" onclick="this.closest('.dialog-overlay').remove(); ${onCancel ? 'arguments[0]()' : ''}">å–æ¶ˆ</button>
                <button class="dialog-btn dialog-btn-confirm" onclick="this.closest('.dialog-overlay').remove(); arguments[0]()">ç¢ºå®š</button>
            </div>
        </div>
    `;

        document.body.appendChild(dialog);

        // ç¶å®šæŒ‰éˆ•äº‹ä»¶
        const confirmBtn = dialog.querySelector('.dialog-btn-confirm');
        const cancelBtn = dialog.querySelector('.dialog-btn-cancel');

        confirmBtn.onclick = () => {
            dialog.remove();
            if (onConfirm) onConfirm();
        };

        cancelBtn.onclick = () => {
            dialog.remove();
            if (onCancel) onCancel();
        };

        // é»æ“ŠèƒŒæ™¯é—œé–‰
        dialog.onclick = (e) => {
            if (e.target === dialog) {
                dialog.remove();
                if (onCancel) onCancel();
            }
        };

        setTimeout(() => {
            dialog.classList.add('show');
        }, 10);
    }


    function addGameManualButton() {
        const undoButton = document.querySelector('button');
        const buttonContainer = undoButton.parentElement;

        const manualButton = document.createElement('button');
        manualButton.textContent = 'ğŸ“– éŠæˆ²èªªæ˜';
        manualButton.style.cssText = `
        padding: 12px 20px;
        background-color: #2196F3;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        margin-left: 10px;
    `;

        manualButton.addEventListener('click', function() {
            showGameManual();
        });

        buttonContainer.appendChild(manualButton);
    }

    function showGameManual() {
        // å‰µå»ºé®ç½©å±¤
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto;
        padding: 20px;
    `;

        // å‰µå»ºèªªæ˜è¦–çª—
        const manualBox = document.createElement('div');
        manualBox.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 15px;
        max-width: 900px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    `;

        // å‰µå»ºé—œé–‰æŒ‰éˆ•
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = 'âœ•';
        closeBtn.style.cssText = `
        position: sticky;
        top: 10px;
        right: 10px;
        float: right;
        background-color: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        font-size: 24px;
        cursor: pointer;
        z-index: 10;
        transition: all 0.3s;
        margin: 10px;
    `;
        closeBtn.addEventListener('mouseover', () => {
            closeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
            closeBtn.style.transform = 'rotate(90deg)';
        });
        closeBtn.addEventListener('mouseout', () => {
            closeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
            closeBtn.style.transform = 'rotate(0deg)';
        });

        // å‰µå»ºå…§å®¹å®¹å™¨
        const content = document.createElement('div');
        content.style.cssText = `
        padding: 40px;
        color: white;
        clear: both;
    `;

        content.innerHTML = `
        <h1 style="text-align: center; font-size: 36px; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
            ğŸ§© æ™ºèƒ½æ–¹å¡Šè§£è¬è¨“ç·´ç³»çµ±éŠæˆ²èªªæ˜
        </h1>

        <div style="background: rgba(255, 255, 255, 0.1); padding: 25px; border-radius: 10px; margin-bottom: 30px; border-left: 5px solid #ffd54f;">
            <h2 style="font-size: 24px; margin-bottom: 15px;">ğŸ‘¨â€ğŸ’» é–‹ç™¼è€…çš„è©±</h2>
            <p style="line-height: 1.8; font-size: 16px; text-align: justify;">
                å—¨ï¼Œæˆ‘æ˜¯é€™å€‹å¹³å°çš„é–‹ç™¼è€…ï¼Œä¸€å€‹ç†±æ„›ç¨‹å¼è¨­è¨ˆçš„é«˜äºŒå­¸ç”Ÿã€‚
            </p>
            <p style="line-height: 1.8; font-size: 16px; text-align: justify; margin-top: 15px;">
                æœ€è¿‘ï¼ŒBlock Blastï¼ˆæ–¹å¡Šçˆ†ç ´ï¼‰é¡å‹çš„éŠæˆ²åœ¨æ ¡åœ’è£¡æ€èµ·äº†ä¸€è‚¡ç†±æ½®ã€‚ä½†æˆ‘ç™¼ç¾å¸‚é¢ä¸Šçš„å¤§å¤šæ•¸éŠæˆ²å­˜åœ¨ä¸€äº›ä»¤äººå›°æ“¾çš„å•é¡Œâ€”â€”<strong>æœ‰äº›æœƒæ•…æ„ç”Ÿæˆç„¡è§£çš„æ–¹å¡Šçµ„åˆ</strong>ï¼Œé€¼è¿«ç©å®¶è§€çœ‹å»£å‘Šä¾†ã€Œå¾©æ´»ã€ï¼›<strong>æœ‰äº›å‰‡ç¼ºä¹æœ‰æ•ˆçš„å­¸ç¿’è¼”åŠ©</strong>ï¼Œè®“ç©å®¶åœ¨é‡åˆ°ç“¶é ¸æ™‚ç„¡å¾æ”¹é€²ï¼Œåªèƒ½ä¸æ–·é‡è¤‡åŒæ¨£çš„éŒ¯èª¤ã€‚
            </p>
            <p style="line-height: 1.8; font-size: 16px; text-align: justify; margin-top: 15px;">
                æ­£æ˜¯é€™äº›è§€å¯Ÿï¼Œä¿ƒä½¿æˆ‘å»ºç«‹äº†é€™å€‹<strong>æ™ºèƒ½è¨“ç·´å¹³å°</strong>ã€‚æˆ‘çš„ç›®æ¨™å¾ˆç°¡å–®ï¼š<strong>å‰µé€ ä¸€å€‹ç´”ç²¹ã€å…¬å¹³ã€æœ‰æ•™è‚²æ„ç¾©çš„éŠæˆ²ç’°å¢ƒ</strong>ã€‚åœ¨é€™è£¡ï¼Œæ¯ä¸€çµ„æ–¹å¡Šéƒ½æ˜¯ã€Œ<span style="color: #ffd54f;">ä¿è­‰æœ‰è§£</span>ã€çš„ï¼Œæ¯ä¸€å€‹æ­»å±€éƒ½èƒ½é€éæ™ºèƒ½åˆ†ææ‰¾åˆ°æ›´å¥½çš„é¸æ“‡ï¼Œæ¯ä¸€æ¬¡éŠç©éƒ½æ˜¯é‚è¼¯æ€ç¶­çš„é›éŠã€‚
            </p>
            <p style="line-height: 1.8; font-size: 16px; text-align: justify; margin-top: 15px;">
                æˆ‘ç›¸ä¿¡ï¼Œ<strong>çœŸæ­£çš„éŠæˆ²æ¨‚è¶£ä¸æ‡‰è©²å»ºç«‹åœ¨æŒ«æŠ˜æ„Ÿèˆ‡å¼·è¿«è§€çœ‹å»£å‘Šä¸Š</strong>ã€‚é€éé€™å€‹å¹³å°ï¼Œæˆ‘å¸Œæœ›ç©å®¶ä¸åƒ…èƒ½è¨“ç·´æ‰‹çœ¼å”èª¿èˆ‡ä½ˆå±€ç­–ç•¥ï¼Œæ›´èƒ½ä¸çŸ¥ä¸è¦ºåœ°åŸ¹é¤Šå‡ºä¸€ç¨®<strong>é æ¸¬æœªä¾†ã€è¨ˆç®—å¯èƒ½æ€§çš„é«˜éšæ€ç¶­èƒ½åŠ›</strong>â€”â€”é€™ç¨®èƒ½åŠ›ï¼Œç„¡è«–åœ¨éŠæˆ²ä¸­é‚„æ˜¯ç¾å¯¦ç”Ÿæ´»ä¸­ï¼Œéƒ½æ˜¯æ¥µå…¶å¯¶è²´çš„ã€‚
            </p>
            <p style="line-height: 1.8; font-size: 16px; text-align: justify; margin-top: 15px; font-style: italic; color: #ffd54f;">
                ã€Œæ¯ä¸€å€‹æ–¹å¡Šï¼Œéƒ½æ˜¯ä¸€æ¬¡æ€è€ƒçš„æ©Ÿæœƒï¼›æ¯ä¸€æ¬¡æ¶ˆé™¤ï¼Œéƒ½æ˜¯ä¸€æ¬¡é‚è¼¯çš„å‹åˆ©ã€‚ã€
            </p>
        </div>

        <div style="background: rgba(255, 255, 255, 0.1); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
            <h2 style="font-size: 24px; margin-bottom: 15px;">ğŸ® åŸºç¤æ ¸å¿ƒç©æ³•</h2>
            <h3 style="font-size: 20px; margin-top: 20px; color: #ffd54f;">é…ç½®èˆ‡æ¶ˆé™¤</h3>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li>åœ¨ 8x8 æ£‹ç›¤ä¸Šæ”¾ç½®æ–¹å¡Š</li>
                <li>ç•¶æ©«å‘æˆ–ç¸±å‘å¡«æ»¿æ™‚å³è§¸ç™¼æ¶ˆé™¤</li>
            </ul>

            <h3 style="font-size: 20px; margin-top: 20px; color: #ffd54f;">é€²åŒ–åŠ åˆ†ç³»çµ±</h3>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li><strong>Combo (é€£æ¶ˆ)</strong>ï¼šå–®å›åˆåŒæ™‚æ¶ˆé™¤å¤šè¡Œ/åˆ—å¯ç²å¾—é«˜é” 100 åˆ†çš„é¡å¤–çå‹µ</li>
                <li><strong>Streak (é€£æ“Š)</strong>ï¼šæ¯é€£çºŒä¸€å€‹å›åˆç”¢ç”Ÿæ¶ˆé™¤ï¼Œåˆ†æ•¸å€ç‡å°‡ä»¥ 5% ç´¯åŠ ï¼ˆç„¡ä¸Šé™ï¼‰</li>
            </ul>

            <h3 style="font-size: 20px; margin-top: 20px; color: #ffd54f;">çµ‚æ¥µç›®æ¨™</h3>
            <p style="line-height: 1.8; font-size: 16px;">
                åœ¨æ£‹ç›¤ç©ºé–“è€—ç›¡å‰ï¼Œé€éç­–ç•¥ä½ˆå±€è¿½æ±‚æ¥µé™é«˜åˆ†
            </p>
        </div>

        <div style="background: rgba(255, 255, 255, 0.1); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
            <h2 style="font-size: 24px; margin-bottom: 15px;">ğŸ“ æ”¾ç½®ç´€éŒ„ç³»çµ± (Notation System)</h2>
            <p style="line-height: 1.8; font-size: 16px;">
                ç³»çµ±æœƒè‡ªå‹•è¿½è¹¤æ¯ä¸€æ‰‹æ“ä½œï¼Œä¸¦å°‡å…¶è½‰åŒ–ç‚ºå°ˆæ¥­çš„æ£‹è­œæ ¼å¼ï¼Œæ–¹ä¾¿ç©å®¶é€²è¡Œè¦†ç›¤èˆ‡ç­–ç•¥åˆ†äº«
            </p>

            <h3 style="font-size: 20px; margin-top: 20px; color: #ffd54f;">åº§æ¨™å®šç¾©</h3>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li><strong>æ©«è»¸ (A-H)</strong>ï¼šå¾å·¦è‡³å³åˆ†åˆ¥ç‚º A åˆ° H</li>
                <li><strong>ç¸±è»¸ (1-8)</strong>ï¼šå¾ä¸Šè‡³ä¸‹åˆ†åˆ¥ç‚º 1 åˆ° 8</li>
                <li><strong>ç¯„ä¾‹</strong>ï¼šå·¦ä¸Šè§’ç¬¬ä¸€æ ¼ç‚º A1ï¼Œå³ä¸‹è§’æœ€å¾Œä¸€æ ¼ç‚º H8</li>
            </ul>

            <h3 style="font-size: 20px; margin-top: 20px; color: #ffd54f;">è¨˜éŒ„æ ¼å¼</h3>
            <p style="line-height: 1.8; font-size: 16px;">
                æ¯ä¸€æ¢ç´€éŒ„åŒ…å«ã€Œæ–¹å¡Šåç¨±ã€ã€ã€Œæ”¾ç½®ä½ç½®ã€åŠã€Œå¾—åˆ†å›é¥‹ã€<br>
                æ”¾ç½®ä½ç½®å®šç¾©ï¼šä»¥æ–¹å¡Šæœ€å°åŒ…åœçŸ©å½¢çš„å·¦ä¸Šè§’åº§æ¨™ç‚ºè¨˜éŒ„åŸºæº–<br>
                <strong>ç¯„ä¾‹</strong>ï¼šLå­—å·¦ä¸‹ @ C4 (+100åˆ†) â€” è¡¨ç¤ºå°‡ L å­—å·¦ä¸‹å‹æ–¹å¡Šæ”¾ç½®æ–¼ C4 ä½ç½®ä¸”å‰›å¥½æ¶ˆé™¤1è¡Œæˆ–1åˆ—
            </p>
        </div>

        <div style="background: rgba(255, 255, 255, 0.1); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
            <h2 style="font-size: 24px; margin-bottom: 15px;">ğŸ§  æ™ºèƒ½æ¼”ç®—æ³•å°ˆé¡Œ</h2>
            <p style="line-height: 1.8; font-size: 16px; margin-bottom: 20px;">
                æœ¬ç³»çµ±é‹ä½œæ™‚ï¼Œå¾Œå°åŒæ™‚é‹è¡Œå››ç¨®æ ¸å¿ƒæ¼”ç®—æ³•ï¼Œç¢ºä¿å±€é¢çš„ç§‘å­¸æ€§èˆ‡å¯è§£æ€§ï¼š
            </p>

            <div style="margin-left: 20px;">
                <h3 style="font-size: 18px; margin-top: 15px; color: #81c784;">1. ğŸ›¡ï¸ æ™ºèƒ½å‡ºå¡Šæ¼”ç®—æ³• (Smart Spawner) â€” ã€Œä¿è­‰æœ‰è§£ã€</h3>
                <ul style="line-height: 1.8; font-size: 15px;">
                    <li>ç³»çµ±åœ¨ç”Ÿæˆä¸‹ä¸€è¼ªä¸‰å€‹æ–¹å¡Šå‰ï¼Œæœƒé å…ˆæƒææ£‹ç›¤å¯†åº¦</li>
                    <li>æ¼”ç®—æ³•æœƒé€²è¡Œã€Œæš´åŠ›éæ­·ã€ï¼Œç¢ºä¿ç”Ÿæˆçš„æ–¹å¡Šçµ„åˆè‡³å°‘å­˜åœ¨ä¸€ç¨®é †åºèƒ½å®Œå…¨æ”¾å…¥</li>
                    <li>ç•¶ç©ºé–“ç‹¹çª„æ™‚ï¼Œç³»çµ±æœƒè‡ªå‹•èª¿é«˜å°æ–¹å¡Šçš„æ¬Šé‡</li>
                </ul>

                <h3 style="font-size: 18px; margin-top: 15px; color: #81c784;">2. ğŸ” å•Ÿç™¼å¼è·¯å¾‘æœå°‹ (Heuristic Search)</h3>
                <ul style="line-height: 1.8; font-size: 15px;">
                    <li>æ ¹æ“šã€Œå‰©é¤˜ç©ºä½ã€ã€ã€Œç©ºæ´å°é–‰ç‡ã€ã€ã€Œæ£‹ç›¤å¹³æ•´åº¦ã€é€²è¡Œå¤šç¶­æ¬Šé‡è©•åˆ†</li>
                    <li>AI æœƒè¨ˆç®—æ‰€æœ‰æ’åˆ—çµ„åˆï¼Œæ‰¾å‡ºæœŸæœ›åˆ†æ•¸æœ€é«˜çš„è·¯å¾‘</li>
                </ul>

                <h3 style="font-size: 18px; margin-top: 15px; color: #81c784;">3. ğŸ•¸ï¸ è·¯å¾‘ä¾è³´è¬é¡Œç”Ÿæˆ (Path Dependency)</h3>
                <ul style="line-height: 1.8; font-size: 15px;">
                    <li>ç³»çµ±æœƒåˆ»æ„ç”Ÿæˆå…·æœ‰ã€Œå”¯ä¸€è§£é †åºã€çš„çµ„åˆ</li>
                    <li>è¨“ç·´ç©å®¶çš„é•·ç·šæ¼”ç®—æ³•æ€è€ƒ</li>
                </ul>

                <h3 style="font-size: 18px; margin-top: 15px; color: #81c784;">4. ğŸ‘ï¸ è¦–è¦ºè­˜åˆ¥æ¼”ç®—æ³• (CV/OCR)</h3>
                <ul style="line-height: 1.8; font-size: 15px;">
                    <li>æ”¯æ´ä¸Šå‚³éŠæˆ²æˆªåœ–ï¼ŒAI æœƒè‡ªå‹•è­˜åˆ¥æ£‹ç›¤ç‹€æ…‹</li>
                    <li>å°‡å¯¦é«”ç‹€æ…‹æ•¸ä½åŒ–ä»¥ä¾¿é€²è¡Œå¾ŒçºŒåˆ†æ</li>
                </ul>
            </div>
        </div>

        <div style="background: rgba(255, 255, 255, 0.1); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
            <h2 style="font-size: 24px; margin-bottom: 15px;">ğŸš€ å°ˆæ¥­åˆ†æèˆ‡è¼”åŠ©å·¥å…·</h2>

            <h3 style="font-size: 18px; margin-top: 15px; color: #ffd54f;">âª æ‚”æ£‹èˆ‡æ­»å±€å›é¡§</h3>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li><strong>æ‚”æ£‹åŠŸèƒ½</strong>ï¼šå…è¨±ç©å®¶å›æº¯æ­¥é©Ÿï¼Œä¿®æ­£éŒ¯èª¤æ±ºç­–</li>
                <li><strong>æ­»å±€å›é¡§</strong>ï¼šç•¶åˆ¤å®šç‚º GameOver æ™‚ï¼Œç³»çµ±æœƒå•Ÿå‹•ã€Œå¾©ç›¤åˆ†æã€</li>
            </ul>

            <h3 style="font-size: 18px; margin-top: 15px; color: #ffd54f;">ğŸ¤– AI æ™ºèƒ½è¼”åŠ©</h3>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li><strong>AI Analysis</strong>ï¼šå³æ™‚é¡¯ç¤ºç•¶å‰å±€é¢çš„æœ€ä½³æ”¾ç½®é»</li>
                <li><strong>AI Guide</strong>ï¼šå½ˆå‡ºåˆ†æ­¥é©Ÿè¦–çª—ï¼Œè¦–è¦ºåŒ–æ¨™ç¤ºå»ºè­°é †åº</li>
            </ul>

            <h3 style="font-size: 18px; margin-top: 15px; color: #ffd54f;">ğŸ› ï¸ å±€é¢ç·¨è¼¯å™¨èˆ‡ BFEN ç¢¼</h3>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li>é»æ“Šå¾…é¸æ–¹å¡Šé€²å…¥ã€Œé¸å–ç‹€æ…‹ã€</li>
                <li>åœ¨æ£‹ç›¤é»æ“Šæ”¾ç½®ä½ç½®</li>
                <li>ä½¿ç”¨ BFEN ç³»çµ±å¿«é€Ÿåˆ†äº«è¨“ç·´å±€é¢</li>
            </ul>
        </div>

        <div style="background: rgba(255, 255, 255, 0.1); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
            <h2 style="font-size: 24px; margin-bottom: 15px;">ğŸ† è¨“ç·´æ¨¡å¼</h2>
            <ul style="line-height: 1.8; font-size: 16px;">
                <li><strong>â¬œ å…¨ç©ºæ¨¡å¼</strong>ï¼šå‚³çµ±é–‹å±€ï¼Œç·´ç¿’åŸºç¤ä½ˆå±€ç­–ç•¥</li>
                <li><strong>ğŸ² éš¨æ©Ÿæ¨¡å¼</strong>ï¼šåˆå§‹å¡«å…… 20% é›œè³ªï¼Œç·´ç¿’éš¨æ©Ÿæ‡‰è®Š</li>
                <li><strong>ğŸ”¥ æ®˜å±€æ¨¡å¼</strong>ï¼šåˆå§‹å¡«å……é” 65%ï¼Œè€ƒé©—é«˜å£“ä¸‹çš„ç©ºé–“æŒ–æ˜èƒ½åŠ›</li>
                <li><strong>â±ï¸ é™æ™‚æŒ‘æˆ°</strong>ï¼š10 åˆ†é˜å…§æŒ‘æˆ°æœ€é«˜è¼¸å‡º</li>
                <li><strong>â™¾ï¸ ç„¡é™è¨“ç·´</strong>ï¼šå°ˆæ³¨æ–¼é•·ç·šç”Ÿå­˜æŠ€å·§</li>
            </ul>
        </div>

        <div style="background: rgba(255, 255, 255, 0.15); padding: 30px; border-radius: 10px; margin-top: 40px;">
            <h2 style="font-size: 24px; margin-bottom: 25px; text-align: center;">ğŸ“¦ æ‰€æœ‰æ–¹å¡Šå½¢ç‹€å°ç…§è¡¨</h2>
            <div id="shapesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 20px; margin-top: 20px;">
            </div>
        </div>

        <div style="text-align: center; margin-top: 40px; padding: 30px; background: rgba(255, 215, 79, 0.2); border-radius: 10px;">
            <h2 style="font-size: 28px; margin-bottom: 15px;">ğŸ¯ æº–å‚™å¥½æŒ‘æˆ°ä½ çš„é‚è¼¯æ¥µé™äº†å—ï¼Ÿ</h2>
            <p style="font-size: 18px; line-height: 1.6;">
                ç¾åœ¨å°±é–‹å§‹æ‚¨çš„æ™ºèƒ½è¨“ç·´ä¹‹æ—…ï¼<br>
                æ¯ä¸€æ¬¡éŠç©ï¼Œéƒ½æ˜¯ä¸€æ¬¡æˆé•·çš„æ©Ÿæœƒã€‚
            </p>
        </div>

        <div style="text-align: center; margin-top: 30px; padding: 20px;">
    <img src="./signature/signature.png" alt="å‰µä½œè€…ç°½å" style="max-width: 300px; height: auto; opacity: 0.9;">
</div>
    `;

        // ç”Ÿæˆæ–¹å¡Šåœ–å½¢ - å®Œæ•´ç‰ˆæœ¬
        const shapesGrid = content.querySelector('#shapesGrid');
        const allShapes = [
            // === Monomino (1æ ¼) ===
            { s: [[1]], color: '#ffd54f', name: 'å–®æ ¼', code: '1' },

            // === Domino (2æ ¼) ===
            { s: [[1,1]], color: '#81c784', name: 'æ©«äºŒ', code: '2h' },
            { s: [[1],[1]], color: '#81c784', name: 'ç›´äºŒ', code: '2v' },

            // === æ–œå‘ 2æ ¼ ===
            { s: [[1,0],[0,1]], color: '#ffb74d', name: 'å³æ–œäºŒ', code: '2dr' },
            { s: [[0,1],[1,0]], color: '#ffb74d', name: 'å·¦æ–œäºŒ', code: '2dl' },

            // === Tromino (3æ ¼) ===
            { s: [[1,1,1]], color: '#64b5f6', name: 'æ©«ä¸‰', code: '3h' },
            { s: [[1],[1],[1]], color: '#64b5f6', name: 'ç›´ä¸‰', code: '3v' },

            // Lå‹ 4 å€‹æ–¹å‘
            { s: [[1,1],[1,0]], color: '#4fc3f7', name: 'å·¦ä¸‹L3', code: '3Lld' },
            { s: [[1,1],[0,1]], color: '#4fc3f7', name: 'å³ä¸‹L3', code: '3Lrd' },
            { s: [[1,0],[1,1]], color: '#4fc3f7', name: 'å·¦ä¸ŠL3', code: '3Llu' },
            { s: [[0,1],[1,1]], color: '#4fc3f7', name: 'å³ä¸ŠL3', code: '3Lru' },

            // === æ–œå‘ 3æ ¼ ===
            { s: [[1,0,0],[0,1,0],[0,0,1]], color: '#f06292', name: 'å³æ–œä¸‰', code: '3dr' },
            { s: [[0,0,1],[0,1,0],[1,0,0]], color: '#f06292', name: 'å·¦æ–œä¸‰', code: '3dl' },

            // === Tetromino (4æ ¼) ===
            { s: [[1,1,1,1]], color: '#42a5f5', name: 'æ©«å››', code: '4h' },
            { s: [[1],[1],[1],[1]], color: '#42a5f5', name: 'ç›´å››', code: '4v' },
            { s: [[1,1],[1,1]], color: '#66bb6a', name: 'ç”°å­—', code: '4s' },

            // === æ–œå‘ 4æ ¼ ===
            { s: [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], color: '#ff6f00', name: 'å³æ–œå››', code: '4dr' },
            { s: [[0,0,0,1],[0,0,1,0],[0,1,0,0],[1,0,0,0]], color: '#ff6f00', name: 'å·¦æ–œå››', code: '4dl' },

            // Tå­— 4å€‹æ–¹å‘
            { s: [[1,1,1],[0,1,0]], color: '#ba68c8', name: 'Tå­—ä¸Š', code: '4Tu' },
            { s: [[0,1,0],[1,1,1]], color: '#ba68c8', name: 'Tå­—ä¸‹', code: '4Td' },
            { s: [[1,0],[1,1],[1,0]], color: '#ba68c8', name: 'Tå­—å·¦', code: '4Tl' },
            { s: [[0,1],[1,1],[0,1]], color: '#ba68c8', name: 'Tå­—å³', code: '4Tr' },

            // Lå­— 4å€‹æ–¹å‘
            { s: [[1,1,1],[1,0,0]], color: '#ffa726', name: 'Lå­—å·¦ä¸Š', code: '4Llu' },
            { s: [[1,0,0],[1,1,1]], color: '#ffa726', name: 'Lå­—å·¦ä¸‹', code: '4Lld' },
            { s: [[1,1],[0,1],[0,1]], color: '#ffa726', name: 'Lå­—å³ä¸Š', code: '4Lru' },
            { s: [[0,1],[0,1],[1,1]], color: '#ffa726', name: 'Lå­—å³ä¸‹', code: '4Lrd' },

            // Jå­— 4å€‹æ–¹å‘
            { s: [[1,1,1],[0,0,1]], color: '#ff9800', name: 'Jå­—å³ä¸Š', code: '4Jru' },
            { s: [[0,0,1],[1,1,1]], color: '#ff9800', name: 'Jå­—å³ä¸‹', code: '4Jrd' },
            { s: [[1,1],[1,0],[1,0]], color: '#ff9800', name: 'Jå­—å·¦ä¸Š', code: '4Jlu' },
            { s: [[1,0],[1,0],[1,1]], color: '#ff9800', name: 'Jå­—å·¦ä¸‹', code: '4Jld' },

            // Zå­— 4å€‹æ–¹å‘
            { s: [[1,1,0],[0,1,1]], color: '#ef5350', name: 'Zå­—å³', code: '4Zr' },
            { s: [[0,1,1],[1,1,0]], color: '#ef5350', name: 'Zå­—å·¦', code: '4Zl' },
            { s: [[0,1],[1,1],[1,0]], color: '#ef5350', name: 'Zå­—ä¸Š', code: '4Zu' },
            { s: [[1,0],[1,1],[0,1]], color: '#ef5350', name: 'Zå­—ä¸‹', code: '4Zd' },

            // å‡¸å­—å‹ 4å€‹æ–¹å‘
            { s: [[0,0,1],[1,1,1],[1,0,0]], color: '#4dd0e1', name: 'å‡¸å­—å³ä¸Š', code: '4Cru' },
            { s: [[1,0,0],[1,1,1],[0,0,1]], color: '#4dd0e1', name: 'å‡¸å­—å·¦ä¸Š', code: '4Clu' },
            { s: [[1,0],[1,1],[0,1]], color: '#4dd0e1', name: 'å‡¸å­—å³ä¸‹', code: '4Crd' },
            { s: [[0,1],[1,1],[1,0]], color: '#4dd0e1', name: 'å‡¸å­—å·¦ä¸‹', code: '4Cld' },

            // å‡¹å­—å‹ 4å€‹æ–¹å‘
            { s: [[1,0,1],[1,1,1]], color: '#ffb300', name: 'å‡¹å­—ä¸‹', code: '4Vd' },
            { s: [[1,1,1],[1,0,1]], color: '#ffb300', name: 'å‡¹å­—ä¸Š', code: '4Vu' },
            { s: [[1,1],[0,1],[1,1]], color: '#ffb300', name: 'å‡¹å­—å·¦', code: '4Vl' },
            { s: [[1,1],[1,0],[1,1]], color: '#ffb300', name: 'å‡¹å­—å³', code: '4Vr' },

            // åå­—å‹
            { s: [[0,1,0],[1,1,1],[0,1,0]], color: '#8e24aa', name: 'åå­—', code: '4+' },

            // === Pentomino (5æ ¼) ===
            { s: [[1,1,1,1,1]], color: '#ab47bc', name: 'æ©«äº”', code: '5h' },
            { s: [[1],[1],[1],[1],[1]], color: '#ab47bc', name: 'ç›´äº”', code: '5v' },

            // å¤§L 4å€‹æ–¹å‘
            { s: [[1,1,1],[1,0,0],[1,0,0]], color: '#ec407a', name: 'å¤§Lå·¦ä¸Š', code: '5Llu' },
            { s: [[1,1,1],[0,0,1],[0,0,1]], color: '#ec407a', name: 'å¤§Lå³ä¸Š', code: '5Lru' },
            { s: [[1,0,0],[1,0,0],[1,1,1]], color: '#ec407a', name: 'å¤§Lå·¦ä¸‹', code: '5Lld' },
            { s: [[0,0,1],[0,0,1],[1,1,1]], color: '#ec407a', name: 'å¤§Lå³ä¸‹', code: '5Lrd' },

            // é•·J 4å€‹æ–¹å‘
            { s: [[1,1,1,1],[0,0,0,1]], color: '#9575cd', name: 'é•·Jå³ä¸Š', code: '5Jru' },
            { s: [[0,1],[0,1],[0,1],[1,1]], color: '#9575cd', name: 'é•·Jå³ä¸‹', code: '5Jrd' },
            { s: [[1,0,0,0],[1,1,1,1]], color: '#9575cd', name: 'é•·Jå·¦ä¸‹', code: '5Jld' },
            { s: [[1,1],[1,0],[1,0],[1,0]], color: '#9575cd', name: 'é•·Jå·¦ä¸Š', code: '5Jlu' },

            // å¤§T 4å€‹æ–¹å‘
            { s: [[1,1,1],[0,1,0],[0,1,0]], color: '#26c6da', name: 'å¤§Tä¸Š', code: '5Tu' },
            { s: [[0,1,0],[0,1,0],[1,1,1]], color: '#26c6da', name: 'å¤§Tä¸‹', code: '5Td' },
            { s: [[1,0,0],[1,1,1],[1,0,0]], color: '#26c6da', name: 'å¤§Tå·¦', code: '5Tl' },
            { s: [[0,0,1],[1,1,1],[0,0,1]], color: '#26c6da', name: 'å¤§Tå³', code: '5Tr' },

            // é•·L 4å€‹æ–¹å‘
            { s: [[1,1,1,1],[1,0,0,0]], color: '#7e57c2', name: 'é•·Lå·¦ä¸Š', code: '5LLlu' },
            { s: [[1,1,1,1],[0,0,0,1]], color: '#7e57c2', name: 'é•·Lå³ä¸Š', code: '5LLru' },
            { s: [[1,1],[1,0],[1,0],[1,0]], color: '#5c6bc0', name: 'é•·Lå·¦ä¸‹', code: '5LLld' },
            { s: [[1,1],[0,1],[0,1],[0,1]], color: '#5c6bc0', name: 'é•·Lå³ä¸‹', code: '5LLrd' },

            // å¯¬L 4å€‹æ–¹å‘
            { s: [[1,1,1],[1,1,0]], color: '#9ccc65', name: 'å¯¬Lå·¦ä¸‹', code: '5WLld' },
            { s: [[1,1,0],[1,1,1]], color: '#9ccc65', name: 'å¯¬Lå³ä¸‹', code: '5WLrd' },
            { s: [[0,1,1],[1,1,1]], color: '#9ccc65', name: 'å¯¬Lå³ä¸Š', code: '5WLru' },
            { s: [[1,1,1],[0,1,1]], color: '#9ccc65', name: 'å¯¬Lå·¦ä¸Š', code: '5WLlu' },

            // é«˜L 4å€‹æ–¹å‘
            { s: [[1,1],[1,1],[0,1]], color: '#9ccc65', name: 'é«˜Lå·¦ä¸‹', code: '5HLld' },
            { s: [[1,1],[1,1],[1,0]], color: '#9ccc65', name: 'é«˜Lå³ä¸‹', code: '5HLrd' },
            { s: [[0,1],[1,1],[1,1]], color: '#9ccc65', name: 'é«˜Lå·¦ä¸Š', code: '5HLlu' },
            { s: [[1,0],[1,1],[1,1]], color: '#9ccc65', name: 'é«˜Lå³ä¸Š', code: '5HLru' },

            // === æ–œå‘ 5æ ¼ ===
            { s: [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]], color: '#e91e63', name: 'å³æ–œäº”', code: '5dr' },
            { s: [[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0]], color: '#e91e63', name: 'å·¦æ–œäº”', code: '5dl' },

            // === ç‰¹æ®Šå¤§æ–¹å¡Š ===
            { s: [[1,1,1],[1,1,1]], color: '#ff7043', name: 'èƒ–ç”°3x2', code: '6r' },
            { s: [[1,1],[1,1],[1,1]], color: '#ff7043', name: 'é«˜ç”°2x3', code: '6c' },
            { s: [[1,1,1],[1,1,1],[1,1,1]], color: '#f44336', name: 'ä¹å®®æ ¼', code: '9' } ]

        allShapes.forEach(shape => {
            const shapeItem = document.createElement('div');
            shapeItem.style.cssText = `
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        `;

            const canvas = document.createElement('canvas');
            const cellSize = 15;
            const rows = shape.s.length;
            const cols = shape.s[0].length || 1;
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;
            canvas.style.cssText = `
    margin: 0 auto;
    display: block;
    margin-bottom: 10px;
    image-rendering: pixelated;
`;

// åœ¨ canvas ç¹ªè£½å‰åŠ å…¥ç½®ä¸­è¨ˆç®—
            const maxSize = 5; // æœ€å¤§æ–¹å¡Šå°ºå¯¸
            const offsetX = Math.floor((maxSize - cols) * cellSize / 2);
            const offsetY = Math.floor((maxSize - rows) * cellSize / 2);
            canvas.width = maxSize * cellSize;
            canvas.height = maxSize * cellSize;

            const ctx = canvas.getContext('2d');
            for (let r = 0; r < rows; r++) {
                const rowData = Array.isArray(shape.s[r]) ? shape.s[r] : [shape.s[r]];
                for (let c = 0; c < rowData.length; c++) {
                    if (rowData[c] === 1) {
                        ctx.fillStyle = shape.color;
                        ctx.fillRect(c * cellSize + offsetX, r * cellSize + offsetY, cellSize - 1, cellSize - 1);
                    }
                }
            }

            const nameDiv = document.createElement('div');
            nameDiv.style.cssText = `
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        `;
            nameDiv.textContent = shape.name;

            const codeDiv = document.createElement('div');
            codeDiv.style.cssText = `
            font-size: 12px;
            color: #ffd54f;
            font-family: monospace;
        `;
            codeDiv.textContent = shape.code;

            shapeItem.appendChild(canvas);
            shapeItem.appendChild(nameDiv);
            shapeItem.appendChild(codeDiv);
            shapesGrid.appendChild(shapeItem);
        });

        manualBox.appendChild(closeBtn);
        manualBox.appendChild(content);
        overlay.appendChild(manualBox);
        document.body.appendChild(overlay);

        // é—œé–‰åŠŸèƒ½
        const closeManual = () => {
            document.body.removeChild(overlay);
        };

        closeBtn.addEventListener('click', closeManual);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeManual();
            }
        });
    }




    function initButtonSystem() {
        // ğŸ†• ç¡®ä¿æŒ‰é’®å®¹å™¨å­˜åœ¨ä¸”åœ¨æ­£ç¡®ä½ç½®
        let buttonsContainer = document.getElementById('buttons-container');
        if (!buttonsContainer) {
            buttonsContainer = document.createElement('div');
            buttonsContainer.id = 'buttons-container';
            // ç¡®ä¿æ·»åŠ åˆ° body çš„æœ€å
            document.body.appendChild(buttonsContainer);
        }

        // å…ˆåˆå§‹åŒ–éŠæˆ²è¨­å®šç³»çµ±ï¼ˆå¿…é ˆæœ€å…ˆåŸ·è¡Œï¼‰
        if (typeof initGameSettings === 'function') {
            initGameSettings();
        }

        // å†åˆå§‹åŒ–å…¶ä»–æŒ‰éˆ•
        addUndoButton();
        addNotationButton();
        addEditButton();
        addAIAnalysisButton();
        addOCRButton();
        addAIGuideButton();
        addEndlessModeButton();
        addRestartButton();
        addGameManualButton();

        // ğŸ†• å»¶è¿Ÿæ”¶é›†æ‰€æœ‰æŒ‰é’®åˆ°å®¹å™¨ä¸­
        setTimeout(() => {
            const buttonsContainer = document.getElementById('buttons-container');
            if (buttonsContainer) {
                // æ”¶é›†æ‰€æœ‰ä¸åœ¨å®¹å™¨ä¸­çš„æŒ‰é’®
                const allButtons = Array.from(document.querySelectorAll('button'));
                allButtons.forEach(btn => {
                    // æ’é™¤å¯¹è¯æ¡†ä¸­çš„æŒ‰é’®
                    if (!btn.closest('.dialog-box') &&
                        !btn.closest('#buttons-container') &&
                        btn.id !== 'close-history') {
                        buttonsContainer.appendChild(btn);
                        btn.classList.add('game-button');
                    }
                });
            }
        }, 200);

        // æ›´æ–°åˆ†æ•¸é¡¯ç¤ºï¼ˆç§»åˆ°æœ€å¾Œï¼Œç¢ºä¿è¨­å®šç³»çµ±å·²è¼‰å…¥ï¼‰
        updateScoreDisplay();
    }

    // åŸ·è¡Œåˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initButtonSystem);
    } else {
        initButtonSystem();
    }

    function resetCell(r, c) {
        const cell = boardElement.children[r*8+c];
        cell.classList.remove('filled');
        cell.style.backgroundColor = '';
    }

    init();
</script>
</body>
</html>